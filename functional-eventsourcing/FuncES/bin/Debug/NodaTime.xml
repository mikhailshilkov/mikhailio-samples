<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NodaTime</name>
    </assembly>
    <members>
        <member name="T:NodaTime.Annotations.MutableAttribute">
            <summary>
            Indicates that a type is mutable. Some members of this type
            allow state to be visibly changed.
            </summary>
        </member>
        <member name="T:NodaTime.Annotations.ImmutableAttribute">
            <summary>
            Indicates that a type is immutable. After construction, the publicly visible
            state of the object will not change.
            </summary>
            <remarks>
            <p>
            This attribute only applies to types, not fields:
            it's entirely feasible to have a readonly field of a mutable type, or a read/write
            field of an immutable type. In such cases for reference types (classes and interfaces)
            it's important to distinguish between the value of the variable (a reference) and the
            object it refers to. Value types are more complicated as in some cases the compiler
            will copy values before operating on them; however as all value types in Noda Time are
            immutable (aside from explictily implemented serialization operations) this rarely causes
            an issue.
            </p>
            <p>
            Some types may be publicly immutable, but contain privately mutable
            aspects, e.g. caches. If it proves to be useful to indicate the kind of
            immutability we're implementing, we can add an appropriate property to this
            attribute.
            </p>
            </remarks>
        </member>
        <member name="T:NodaTime.Annotations.VisibleForTestingAttribute">
            <summary>
            Attribute indicating that a particular member would normally be private (or potentially protected)
            but is exposed for test purposes.
            </summary>
            <remarks>
            Currently this excludes nested types, fields, and events - but it could be expanded to do so. Likewise
            we don't indicate the intended access mode, which could be done via an enum. For the moment we'll
            assume everything would be private apart from for testing.
            </remarks>
        </member>
        <member name="T:NodaTime.CalendarSystem">
            <summary>
            A calendar system maps the non-calendar-specific "local time line" to human concepts
            such as years, months and days.
            </summary>
            <remarks>
            <para>
            Many developers will never need to touch this class, other than to potentially ask a calendar
            how many days are in a particular year/month and the like. Noda Time defaults to using the ISO-8601
            calendar anywhere that a calendar system is required but hasn't been explicitly specified.
            </para>
            <para>
            If you need to obtain a <see cref="T:NodaTime.CalendarSystem" /> instance, use one of the static properties or methods in this
            class, such as the <see cref="P:NodaTime.CalendarSystem.Iso" /> property or the <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" /> method.
            </para>
            <para>Although this class is currently sealed (as of Noda Time 1.2), in the future this decision may
            be reversed. In any case, there is no current intention for third-party developers to be able to implement
            their own calendar systems (for various reasons). If you require a calendar system which is not
            currently supported, please file a feature request and we'll see what we can do.
            </para>
            </remarks>
            <threadsafety>
            All calendar implementations are immutable and thread-safe. See the thread safety
            section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.CalendarSystem.ForId(System.String)">
            <summary>
            Fetches a calendar system by its unique identifier. This provides full round-tripping of a calendar
            system. It is not guaranteed that calling this method twice with the same identifier will return
            identical references, but the references objects will be equal.
            </summary>
            <param name="id">The ID of the calendar system. This is case-sensitive.</param>
            <returns>The calendar system with the given ID.</returns>
            <seealso cref="P:NodaTime.CalendarSystem.Id"/>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No calendar system for the specified ID can be found.</exception>
        </member>
        <member name="P:NodaTime.CalendarSystem.Ids">
            <summary>
            Returns the IDs of all calendar systems available within Noda Time. The order of the keys is not guaranteed.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.Iso">
            <summary>
            Returns a calendar system that follows the rules of the ISO-8601 standard,
            which is compatible with Gregorian for all modern dates.
            </summary>
            <remarks>
            <para>
            When ISO does not define a field, but it can be determined (such as AM/PM) it is included.
            </para>
            <para>
            With the exception of century related fields, the ISO calendar is exactly the
            same as the Gregorian calendar system. In the ISO system, centuries and year
            of century are zero based. For all years, the century is determined by
            dropping the last two digits of the year, ignoring sign. The year of century
            is the value of the last two year digits.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetPersianCalendar">
            <summary>
            Returns a Persian (also known as Solar Hijri) calendar system. This is the main calendar in Iran
            and Afghanistan, and is also used in some other countries where Persian is spoken.
            </summary>
            <remarks>
            The true Persian calendar is an astronomical one, where leap years depend on vernal equinox.
            A complicated algorithmic alternative approach exists, proposed by Ahmad Birashk,
            but this isn't generally used in society. The implementation here is somewhat simpler, using a
            33-year leap cycle, where years  1, 5, 9, 13, 17, 22, 26, and 30 in each cycle are leap years.
            This is the same approach taken by the BCL <c>PersianCalendar</c> class, and the dates of
            this implementation align exactly with the BCL implementation.
            </remarks>
            <returns>A Persian calendar system.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)">
            <summary>
            Returns a Hebrew calendar, as described at http://en.wikipedia.org/wiki/Hebrew_calendar. This is a
            purely mathematical calculator, applied proleptically to the period where the real calendar was observational. 
            </summary>
            <remarks>
            <para>Please note that in version 1.3.0 of Noda Time, support for the Hebrew calendar is somewhat experimental,
            particularly in terms of calculations involving adding or subtracting years. Additionally, text formatting
            and parsing using month names is not currently supported, due to the challenges of handling leap months.
            It is hoped that this will be improved in future versions.</para>
            <para>The implementation for this was taken from http://www.cs.tau.ac.il/~nachum/calendar-book/papers/calendar.ps,
            which is a public domain algorithm presumably equivalent to that given in the Calendrical Calculations book
            by the same authors (Nachum Dershowitz and Edward Reingold).
            </para>
            </remarks>
            <param name="monthNumbering">The month numbering system to use</param>
            <returns>A Hebrew calendar system for the given month numbering.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)">
            <summary>
            Returns a pure proleptic Gregorian calendar system, which defines every
            fourth year as leap, unless the year is divisible by 100 and not by 400.
            This improves upon the Julian calendar leap year rule.
            </summary>
            <remarks>
            Although the Gregorian calendar did not exist before 1582 CE, this
            calendar system assumes it did, thus it is proleptic. This implementation also
            fixes the start of the year at January 1.
            </remarks>
            <param name="minDaysInFirstWeek">The minimum number of days in the first week of the year.
            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is
            used to decide at what point the week year changes.</param>
            <returns>A suitable Gregorian calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)">
            <summary>
            Returns a pure proleptic Julian calendar system, which defines every
            fourth year as a leap year. This implementation follows the leap year rule
            strictly, even for dates before 8 CE, where leap years were actually
            irregular.
            </summary>
            <remarks>
            Although the Julian calendar did not exist before 45 BCE, this calendar
            assumes it did, thus it is proleptic. This implementation also fixes the
            start of the year at January 1.
            </remarks>
            <param name="minDaysInFirstWeek">The minimum number of days in the first week of the year.
            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is
            used to decide at what point the week year changes.</param>
            <returns>A suitable Julian calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)">
            <summary>
            Returns a Coptic calendar system, which defines every fourth year as
            leap, much like the Julian calendar. The year is broken down into 12 months,
            each 30 days in length. An extra period at the end of the year is either 5
            or 6 days in length. In this implementation, it is considered a 13th month.
            </summary>
            <remarks>
            <para>
            Year 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus
            Coptic years do not begin at the same time as Julian years. This calendar
            is not proleptic, as it does not allow dates before the first Coptic year.
            </para>
            <para>
            This implementation defines a day as midnight to midnight exactly as per
            the ISO calendar. Some references indicate that a Coptic day starts at
            sunset on the previous ISO day, but this has not been confirmed and is not
            implemented.
            </para>
            </remarks>
            <param name="minDaysInFirstWeek">The minimum number of days in the first week of the year.
            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is
            used to decide at what point the week year changes.</param>
            <returns>A suitable Coptic calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)">
            <summary>
            Returns an Islamic, or Hijri, calendar system.
            </summary>
            <remarks>
            <para>
            This returns a tablular calendar, rather than one based on lunar observation. This calendar is a
            lunar calendar with 12 months, each of 29 or 30 days, resulting in a year of 354 days (or 355 on a leap
            year).
            </para>
            <para>
            Year 1 in the Islamic calendar began on July 15th or 16th, 622 CE (Julian), thus
            Islamic years do not begin at the same time as Julian years. This calendar
            is not proleptic, as it does not allow dates before the first Islamic year.
            </para>
            <para>
            There are two basic forms of the Islamic calendar, the tabular and the
            observed. The observed form cannot easily be used by computers as it
            relies on human observation of the new moon. The tabular calendar, implemented here, is an
            arithmetic approximation of the observed form that follows relatively simple rules.
            </para>
            <para>You should choose an epoch based on which external system you wish
            to be compatible with. The epoch beginning on July 16th is the more common
            one for the tabular calendar, so using <see cref="F:NodaTime.Calendars.IslamicEpoch.Civil" />
            would usually be a logical choice. However, Windows uses July 15th, so
            if you need to be compatible with other Windows systems, you may wish to use
            <see cref="F:NodaTime.Calendars.IslamicEpoch.Astronomical" />. The fact that the Islamic calendar
            traditionally starts at dusk, a Julian day traditionally starts at noon,
            and all calendar systems in Noda Time start their days at midnight adds
            somewhat inevitable confusion to the mix, unfortunately.</para>
            <para>
            The tabular form of the calendar defines 12 months of alternately
            30 and 29 days. The last month is extended to 30 days in a leap year.
            Leap years occur according to a 30 year cycle. There are four recognised
            patterns of leap years in the 30 year cycle:
            </para>
            <list type="table">
               <listheader><term>Origin</term><description>Leap years</description></listheader>
               <item><term>Kūshyār ibn Labbān</term><description>2, 5, 7, 10, 13, 15, 18, 21, 24, 26, 29</description></item>
               <item><term>al-Fazārī</term><description>2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29</description></item>
               <item><term>Fātimid (also known as Misri or Bohra)</term><description>2, 5, 8, 10, 13, 16, 19, 21, 24, 27, 29</description></item>
               <item><term>Habash al-Hasib</term><description>2, 5, 8, 11, 13, 16, 19, 21, 24, 27, 30</description></item>
            </list>
            <para>
            The leap year pattern to use is determined from the first parameter to this factory method.
            The second parameter determines which epoch is used - the "astronomical" or "Thursday" epoch
            (July 15th 622CE) or the "civil" or "Friday" epoch (July 16th 622CE).
            </para>
            <para>
            This implementation defines a day as midnight to midnight exactly as per
            the ISO calendar. This correct start of day is at sunset on the previous
            day, however this cannot readily be modelled and has been ignored.
            </para>
            </remarks>
            <param name="leapYearPattern">The pattern of years in the 30-year cycle to consider as leap years</param>
            <param name="epoch">The kind of epoch to use (astronomical or civil)</param>
            <returns>A suitable Islamic calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.CreateIdFromNameAndMinDaysInFirstWeek(System.String,System.Int32)">
            <summary>
            Creates an ID for a calendar system which only needs to be distinguished by its name and
            the minimum number of days in the first week of the week-year.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.Id">
            <summary>
            Returns the unique identifier for this calendar system. This is provides full round-trip capability
            using <see cref="M:NodaTime.CalendarSystem.ForId(System.String)" /> to retrieve the calendar system from the identifier.
            </summary>
            <remarks>
            <para>
            A unique ID for a calendar is required when serializing types which include a <see cref="T:NodaTime.CalendarSystem"/>.
            As of 2 Nov 2012 (ISO calendar) there are no ISO or RFC standards for naming a calendar system. As such,
            the identifiers provided here are specific to Noda Time, and are not guaranteed to interoperate with any other
            date and time API.
            </para>
            <list type="table">
              <listheader>
                <term>Calendar ID</term>
                <description>Equivalent factory method</description>
              </listheader>
              <item><term>ISO</term><description><see cref="P:NodaTime.CalendarSystem.Iso"/></description></item>
              <item><term>Gregorian 1</term><description><see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)"/>(1)</description></item>
              <item><term>Gregorian 2</term><description><see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)"/>(2)</description></item>
              <item><term>Gregorian 3</term><description><see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)"/>(3)</description></item>
              <item><term>Gregorian 3</term><description><see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)"/>(4)</description></item>
              <item><term>Gregorian 5</term><description><see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)"/>(5)</description></item>
              <item><term>Gregorian 6</term><description><see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)"/>(6)</description></item>
              <item><term>Gregorian 7</term><description><see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)"/>(7)</description></item>
              <item><term>Coptic 1</term><description><see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)"/>(1)</description></item>
              <item><term>Coptic 2</term><description><see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)"/>(2)</description></item>
              <item><term>Coptic 3</term><description><see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)"/>(3)</description></item>
              <item><term>Coptic 4</term><description><see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)"/>(4)</description></item>
              <item><term>Coptic 5</term><description><see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)"/>(5)</description></item>
              <item><term>Coptic 6</term><description><see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)"/>(6)</description></item>
              <item><term>Coptic 7</term><description><see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)"/>(7)</description></item>
              <item><term>Julian 1</term><description><see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)"/>(1)</description></item>
              <item><term>Julian 2</term><description><see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)"/>(2)</description></item>
              <item><term>Julian 3</term><description><see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)"/>(3)</description></item>
              <item><term>Julian 4</term><description><see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)"/>(4)</description></item>
              <item><term>Julian 5</term><description><see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)"/>(5)</description></item>
              <item><term>Julian 6</term><description><see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)"/>(6)</description></item>
              <item><term>Julian 7</term><description><see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)"/>(7)</description></item>
              <item><term>Hijri Civil-Indian</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Indian, IslamicEpoch.Civil)</description></item>
              <item><term>Hijri Civil-Base15</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Base15, IslamicEpoch.Civil)</description></item>
              <item><term>Hijri Civil-Base16</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Base16, IslamicEpoch.Civil)</description></item>
              <item><term>Hijri Civil-HabashAlHasib</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.HabashAlHasib, IslamicEpoch.Civil)</description></item>
              <item><term>Hijri Astronomical-Indian</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Indian, IslamicEpoch.Astronomical)</description></item>
              <item><term>Hijri Astronomical-Base15</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Base15, IslamicEpoch.Astronomical)</description></item>
              <item><term>Hijri Astronomical-Base16</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Base16, IslamicEpoch.Astronomical)</description></item>
              <item><term>Hijri Astronomical-HabashAlHasib</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.HabashAlHasib, IslamicEpoch.Astronomical)</description></item>
              <item><term>Persian</term><description><see cref="M:NodaTime.CalendarSystem.GetPersianCalendar"/></description></item>
              <item><term>Hebrew</term><description><see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)"/></description></item>
            </list>
            </remarks>
        </member>
        <member name="P:NodaTime.CalendarSystem.Name">
            <summary>
            Returns the name of this calendar system. Each kind of calendar system has a unique name, but this
            does not usually provide enough information for round-tripping. (For example, the name of an
            Islamic calendar system does not indicate which kind of leap cycle it uses, and other calendars
            specify the minimum number of days in the first week of a year.)
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.UsesIsoDayOfWeek">
            <summary>
            Returns whether the day-of-week field refers to ISO days. If true, types such as <see cref="T:NodaTime.LocalDateTime" />
            can use the <see cref="T:NodaTime.IsoDayOfWeek" /> property to avoid using magic numbers.
            This defaults to true, but can be overridden by specific calendars.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.MinYear">
            <summary>
            The minimum valid year (inclusive) within this calendar.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.MaxYear">
            <summary>
            The maximum valid year (inclusive) within this calendar.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.MinTicks">
            <summary>
            Returns the minimum tick number this calendar can handle.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.MaxTicks">
            <summary>
            Returns the maximum tick number this calendar can handle.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.Eras">
            <summary>
            Returns a read-only list of eras used in this calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,NodaTime.Calendars.Era)">
            <summary>
            Returns the "absolute year" (the one used throughout most of the API, without respect to eras)
            from a year-of-era and an era.
            </summary>
            <remarks>
            For example, in the Gregorian and Julian calendar systems, the BCE era starts at year 1, which is
            equivalent to an "absolute year" of 0 (then BCE year 2 has an absolute year of -1, and so on).  The absolute
            year is the year that is used throughout the API; year-of-era is typically used primarily when formatting
            and parsing date values to and from text.
            </remarks>
            <param name="yearOfEra">The year within the era.</param>
            <param name="era">The era in which to consider the year</param>
            <returns>The absolute year represented by the specified year of era.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="yearOfEra"/> is out of the range of years for the given era.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="era"/> is not an era used in this calendar.</exception>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)">
            <summary>
            Returns the maximum valid year-of-era in the given era.
            </summary>
            <param name="era">The era in which to find the greatest year</param>
            <returns>The maximum valid year in the given era.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="era"/> is not an era used in this calendar.</exception>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)">
            <summary>
            Returns the minimum valid year-of-era in the given era.
            </summary>
            <param name="era">The era in which to find the greatest year</param>
            <returns>The minimum valid year in the given eraera.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="era"/> is not an era used in this calendar.</exception>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetEraIndex(NodaTime.Calendars.Era)">
            <summary>
            Convenience method to perform nullity and validity checking on the era, converting it to
            the index within the list of eras used in this calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetLocalInstantFromWeekYearWeekAndDayOfWeek(System.Int32,System.Int32,NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the local date corresponding to the given "week year", "week of week year", and "day of week"
            in this calendar system.
            </summary>
            <param name="weekYear">ISO-8601 week year of value to return</param>
            <param name="weekOfWeekYear">ISO-8601 week of week year of value to return</param>
            <param name="dayOfWeek">ISO-8601 day of week to return</param>
            <returns>The date corresponding to the given week year / week of week year / day of week.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetLocalInstant(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a local instant, at the start of the day formed from the given year of era, month, day, and era arguments.
            The set of given values must refer to a valid datetime.
            </summary>
            <param name="era">Era to use. This must be one of the eras used in this calendar</param>
            <param name="yearOfEra">Year of era to use</param>
            <param name="monthOfYear">Month to use</param>
            <param name="dayOfMonth">Day of month to use</param>
            <exception cref="T:System.ArgumentException"><paramref name="era"/> is not an era used in this calendar.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The year of era, month of year and day of month values don't
            form a valid date.</exception>
            <returns>A <see cref="T:NodaTime.LocalInstant"/> with the given year, month, day and era.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetLocalInstant(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a local instant, formed from the given year, month, day,
            hour, minute, second, millisecond and ticks values.
            </summary>
            <param name="year">Absolute year (not year within era; may be negative)</param>
            <param name="monthOfYear">Month of year</param>
            <param name="dayOfMonth">Day of month</param>
            <param name="hourOfDay">Hour within the day (0-23)</param>
            <param name="minuteOfHour">Minute within the hour</param>
            <param name="secondOfMinute">Second within the minute</param>
            <param name="millisecondOfSecond">Millisecond within the second</param>
            <param name="tickOfMillisecond">Tick within the millisecond</param>
            <returns>A <see cref="T:NodaTime.LocalInstant"/> with the given values.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.ToString">
            <summary>
            Converts this calendar system to text by simply returning its unique ID.
            </summary>
            <returns>The ID of this calendar system.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetIsoDayOfWeek(NodaTime.LocalInstant)">
            <summary>
            Returns the IsoDayOfWeek corresponding to the day of week for the given local instant
            if this calendar uses ISO days of the week, or throws an InvalidOperationException otherwise.
            </summary>
            <param name="localInstant">The local instant to use to find the day of the week</param>
            <returns>The day of the week as an IsoDayOfWeek</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetDaysInMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the given month within the given year.
            </summary>
            <param name="year">The year in which to consider the month</param>
            <param name="month">The month to determine the number of days in</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given year / month combination
            is invalid for this calendar.</exception>
            <returns>The number of days in the given month and year.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.IsLeapYear(System.Int32)">
            <summary>
            Returns whether or not the given year is a leap year in this calendar.
            </summary>
            <param name="year">The year to consider.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given year is invalid for this calendar.
            Note that some implementations may return a value rather than throw this exception. Failure to throw an
            exception should not be treated as an indication that the year is valid.</exception>
            <returns>True if the given year is a leap year; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetMaxMonth(System.Int32)">
            <summary>
            The maximum valid month (inclusive) within this calendar in the given year. It is assumed that
            all calendars start with month 1 and go up to this month number in any valid year.
            </summary>
            <param name="year">The year to consider.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given year is invalid for this calendar.
            Note that some implementations may return a month rather than throw this exception (for example, if all
            years have the same number of months in this calendar system). Failure to throw an exception should not be
            treated as an indication that the year is valid.</exception>
            <returns>The maximum month number within the given year.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetMaxYearOfEra(System.Int32)">
            <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)"/> - but this uses a pre-validated index.
            This default implementation returns the maximum year for this calendar, which is
            a valid implementation for single-era calendars.
            </summary>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetMinYearOfEra(System.Int32)">
            <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)" /> - but this uses a pre-validated index.
            This default implementation returns 1, but can be overridden by derived classes.
            </summary>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,System.Int32)">
            <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,NodaTime.Calendars.Era)"/> - but this uses a pre-validated index.
            This default implementation validates that the year is between 1 and MaxYear inclusive,
            but then returns it as-is, expecting that there's no further work to be
            done. This is valid for single-era calendars; the method should be overridden for multi-era calendars.
            </summary>
        </member>
        <member name="T:NodaTime.AmbiguousTimeException">
            <summary>
            Exception thrown to indicate that the specified local date/time occurs twice
            in a particular time zone due to daylight saving time changes.
            </summary>
            <remarks>
            <para>
            This occurs for transitions where the clock goes backward (usually by
            an hour). For example, suppose the time zone goes backward
            at 2am, so the second after 01:59:59 becomes 01:00:00. In that case,
            times such as 01:30:00 occur twice.
            </para>
            <para>
            This exception is used to indicate such problems, as they're usually
            not the same as other <see cref="T:System.ArgumentOutOfRangeException" /> causes,
            such as entering "15" for a month number.
            </para>
            <para>
            In theory this isn't calendar-specific; the local value will be ambiguous in
            this time zone regardless of the calendar used. However, this exception is
            always created in conjunction with a specific calendar, which leads to a more
            natural way of examining its information and constructing an error message.
            </para>
            </remarks>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.LocalDateTime">
            <summary>
            The local date and time which is ambiguous in the time zone.
            </summary>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.Zone">
            <summary>
            The time zone in which the local date and time is ambiguous.
            </summary>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.EarlierMapping">
            <summary>
            The earlier of the two occurrences of the local date and time within the time zone.
            </summary>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.LaterMapping">
            <summary>
            The later of the two occurrences of the local date and time within the time zone.
            </summary>
        </member>
        <member name="M:NodaTime.AmbiguousTimeException.#ctor(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Constructs an instance from the given information.
            </summary>
            <remarks>
            <para>
            User code is unlikely to need to deliberately call this constructor except
            possibly for testing.
            </para>
            <para>
            The two mappings must have the same local time and time zone.
            </para>
            </remarks>
            <param name="earlierMapping">The earlier possible mapping</param>
            <param name="laterMapping">The later possible mapping</param>
        </member>
        <member name="T:NodaTime.Calendars.Era">
            <summary>
            Represents an era used in a calendar.
            </summary>
            <remarks>All the built-in calendars in Noda Time use the values specified by the static
            read-only fields in this class. These may be compared for reference equality to check for specific
            eras.</remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Calendars.Era.Common">
            <summary>
            The "Common" era (CE), also known as Anno Domini (AD). This is used in the ISO, Gregorian and Julian calendars.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.Era.BeforeCommon">
            <summary>
            The "before common" era (BCE), also known as Before Christ (BC). This is used in the ISO, Gregorian and Julian calendars.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.Era.AnnoMartyrum">
            <summary>
            The "Anno Martyrum" or "Era of the Martyrs". This is the sole era used in the Coptic calendar.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.Era.AnnoMartyrm">
            <summary>
            The "Anno Martyrum" or "Era of the Martyrs". This is the sole era used in the Coptic calendar.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.Era.AnnoHegirae">
            <summary>
            The "Anno Hegira" era. This is the sole era used in the Hijri (Islamic) calendar.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.Era.AnnoMundi">
            <summary>
            The "Anno Mundi" era. This is the sole era used in the Hebrew calendar.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.Era.AnnoPersico">
            <summary>
            The "Anno Persico" era. This is the sole era used in the Persian calendar.
            </summary>
        </member>
        <member name="P:NodaTime.Calendars.Era.Name">
            <summary>
            Returns the name of this era, e.g. "CE" or "BCE".
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.Era.ToString">
            <summary>
            Returns the name of this era.
            </summary>
            <returns>The name of this era.</returns>
        </member>
        <member name="T:NodaTime.Calendars.FixedMonthYearMonthDayCalculator">
            <summary>
            Abstract implementation of a year/month/day calculator based around months which always have 30 days.
            </summary>
            <remarks>
            As the month length is fixed various calculations can be optimised.
            This implementation assumes any additional days after twelve
            months fall into a thirteenth month.
            </remarks>
        </member>
        <member name="T:NodaTime.Calendars.HebrewScripturalCalculator">
            <summary>
            Implementation of the algorithms described in
            http://www.cs.tau.ac.il/~nachum/calendar-book/papers/calendar.ps, using scriptural
            month numbering.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.GetOrPopulateCache(System.Int32)">
            <summary>
            Returns the cached "absolute day at start of year / IsHeshvanLong / IsKislevShort" combination,
            populating the cache if necessary. Bits 0-22 are the "elapsed days start of year"; bit 23 is
            "is Heshvan long"; bit 24 is "is Kislev short". If the year is out of the range for the cache,
            the value is populated but not cached.
            </summary>
            <param name="year"></param>
        </member>
        <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.ComputeCacheEntry(System.Int32)">
            <summary>
            Computes the cache entry value for the given year, but without populating the cache.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.AbsoluteFromHebrew(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the "absolute day number" for the given year, month and day in the Hebrew calendar.
            The absolute day number of 0001-01-01 AD (Gregorian) is 1.
            </summary>            
        </member>
        <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.HebrewFromAbsolute(System.Int32)">
            <summary>
            Converts an "absolute day number" into a year, month and day in the Hebrew calendar.
            The absolute day number of 0001-01-01 AD (Gregorian) is 1.
            </summary>            
        </member>
        <member name="T:NodaTime.Calendars.HebrewMonthConverter">
            <summary>
            Conversions between civil and scriptural month numbers in the Hebrew calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewMonthConverter.CivilToScriptural(System.Int32,System.Int32)">
            <summary>
            Given a civil month number and a year in which it occurs, this method returns
            the equivalent scriptural month number.
            </summary>
            <remarks>
            No validation is performed in this method: an input month number of 13 in a non-leap-year
            will return a result of 7.
            </remarks>
            <param name="year">Year during which the month occurs.</param>
            <param name="month">Civil month number.</param>
            <returns>The scriptural month number.</returns>
        </member>
        <member name="M:NodaTime.Calendars.HebrewMonthConverter.ScripturalToCivil(System.Int32,System.Int32)">
            <summary>
            Given an scriptural month number and a year in which it occurs, this method returns
            the equivalent scriptural month number.
            </summary>
            <remarks>
            No validation is performed in this method: an input month number of 13 in a non-leap-year
            will return a result of 7.
            </remarks>
            <param name="year">Year during which the month occurs.</param>
            <param name="month">Civil month number.</param>
            <returns>The scriptural month number.</returns>
        </member>
        <member name="T:NodaTime.Calendars.HebrewMonthNumbering">
            <summary>
            The month numbering to use for the Hebrew calendar.
            </summary>
            <remarks>
            When requesting a Hebrew calendar with <see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)"/>, a month numbering
            system needs to be specified. There are two main ways of numbering the Hebrew months: the civil
            system where month 1 is the start of the new year (Tishri) and scriptural system where month 1 is
            Nisan, according to biblical custom.
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.HebrewMonthNumbering.Civil">
            <summary>
            <para>
            The numbering system where month 1 is Tishri. This has the advantage of familiarity with other
            calendars where the first month is 1; it is easier to tell which date comes before which, aside
            from anything else. It is also the  numbering system used by the BCL.
            </para>
            <para>The main disadvantage is that due to leap years effectively "splitting" Adar into Adar I
            and Adar II, the months after that (Nisan, Iyyar and so on) have month numberings which depend
            on the year.</para>
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.HebrewMonthNumbering.Scriptural">
            <summary>
            <para>
            The numbering system where month 1 is Nisan. This is the numbering system which matches biblical
            custom (such as Leviticus 23:5). This has the advantage that the split of Adar is at the end of the
            numbering system, so all other month names are stable.
            </para>
            <para>The primary disadvantage of this numbering system is that months 1-6 come after months 7-12 (or 13),
            which is counter-intuitive.</para>
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.HebrewYearMonthDayCalculator">
            <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)" /> for details. This is effectively
            an adapter around <see cref="T:NodaTime.Calendars.HebrewScripturalCalculator"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewYearMonthDayCalculator.IsLeapYear(System.Int32)">
            <summary>
            Returns whether or not the given year is a leap year - that is, one with 13 months. This is
            not quite the same as a leap year in (say) the Gregorian calendar system...
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewYearMonthDayCalculator.SetYear(NodaTime.LocalInstant,System.Int32)">
            <summary>
            Change the year, maintaining month and day as well as possible. This doesn't
            work in the same way as other calendars; see http://judaism.stackexchange.com/questions/39053
            for the reasoning behind the rules.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewYearMonthDayCalculator.AbsoluteDayFromLocalInstant(NodaTime.LocalInstant)">
            <summary>
            Converts a LocalInstant into an absolute day number.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.IslamicEpoch">
            <summary>
            The epoch to use when constructing an Islamic calendar.
            </summary>
            <remarks>
            The Islamic, or Hijri, calendar can either be constructed
            starting on July 15th 622CE (in the Julian calendar) or on the following day.
            The former is the "astronomical" or "Thursday" epoch; the latter is the "civil" or "Friday" epoch.
            </remarks>
            <seealso cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>
        </member>
        <member name="F:NodaTime.Calendars.IslamicEpoch.Astronomical">
            <summary>
            Epoch beginning on July 15th 622CE (Julian), which is July 18th 622 CE in the Gregorian calendar.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicEpoch.Civil">
            <summary>
            Epoch beginning on July 16th 622CE (Julian), which is July 19th 622 CE in the Gregorian calendar.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.IslamicLeapYearPattern">
            <summary>
            The pattern of leap years to use when constructing an Islamic calendar.
            </summary>
            <remarks>
            <para>
            The Islamic, or Hijri, calendar is a lunar calendar of 12 months, each of 29 or 30 days.
            The calendar can be defined in either observational or tabular terms; 
            Noda Time implements a tabular calendar, where a pattern of leap years (in which the last month has
            an extra day) repeats every 30 years, according to one of the patterns within this enum.
            </para>
            <para>
            While the patterns themselves are reasonably commonly documented (see e.g.
            <a href="http://en.wikipedia.org/wiki/Tabular_Islamic_calendar">Wikipedia</a>)
            there is little standardization in terms of naming the patterns. I hope the current names do not
            cause offence to anyone; suggestions for better names would be welcome.
            </para>
            <seealso cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Base15">
            <summary>
            A pattern of leap years in 2, 5, 7, 10, 13, 15, 18, 21, 24, 26 and 29.
            This pattern and <see cref="F:NodaTime.Calendars.IslamicLeapYearPattern.Base16"/> are the most commonly used ones,
            and only differ in whether the 15th or 16th year is deemed leap.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Base16">
            <summary>
            A pattern of leap years in 2, 5, 7, 10, 13, 16, 18, 21, 24, 26 and 29.
            This pattern and <see cref="F:NodaTime.Calendars.IslamicLeapYearPattern.Base15"/> are the most commonly used ones,
            and only differ in whether the 15th or 16th year is deemed leap.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Indian">
            <summary>
            A pattern of leap years in 2, 5, 8, 10, 13, 16, 19, 21, 24, 27 and 29.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.HabashAlHasib">
            <summary>
            A pattern of leap years in 2, 5, 8, 11, 13, 16, 19, 21, 24, 27 and 30.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.MonthPairLength">
            <summary>Days in a pair of months, in days.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.LongMonthLength">
            <summary>The length of a long month, in days.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.ShortMonthLength">
            <summary>The length of a short month, in days.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.AverageTicksPerYear">
            <summary>The typical number of ticks in a year.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerNonLeapYear">
            <summary>The number of days in a non-leap year.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerLeapYear">
            <summary>The number of days in a leap year.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.TicksPerNonLeapYear">
            <summary>The number of ticks in a non-leap year.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.TicksAtCivilEpoch">
            <summary>The ticks for the civil (Friday) epoch of July 16th 622CE.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.TicksAtAstronomicalEpoch">
            <summary>The ticks for the civil (Thursday) epoch of July 15th 622CE.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.LeapYearCycleLength">
            <summary>The length of the cycle of leap years.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerLeapCycle">
            <summary>The number of days in leap cycle.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.leapYearPatternBits">
            <summary>The pattern of leap years within a cycle, one bit per year, for this calendar.</summary>
        </member>
        <member name="M:NodaTime.Calendars.IslamicYearMonthDayCalculator.GetLeapYearPatternBits(NodaTime.Calendars.IslamicLeapYearPattern)">
            <summary>
            Returns the pattern of leap years within a cycle, one bit per year, for the specified pattern.
            Note that although cycle years are usually numbered 1-30, the bit pattern is for 0-29; cycle year
            30 is represented by bit 0.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.IslamicYearMonthDayCalculator.GetYear1Ticks(NodaTime.Calendars.IslamicEpoch)">
            <summary>
            Returns the LocalInstant ticks at the specified epoch.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.IsoYearMonthDayCalculator">
            <summary>
            The ISO-8601 calendar is equivalent to the Gregorian calendar but the century
            and year-of-century are 0-based, and for negative centuries the year is treated as 0-based too.
            (This may be a bug in previous versions of Noda Time, but we should be backward compatible
            at least until we know for sure.)
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.NamespaceDoc">
            <summary>
            <para>
            The NodaTime.Calendars namespace contains types related to calendars beyond the
            <see cref="T:NodaTime.CalendarSystem"/> type in the core NodaTime namespace.
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.PersianYearMonthDayCalculator">
            <summary>
            Implementation of the Persian (Solar Hijri) calendar. This is an algorithmic
            implementation rather than the true observational version, and it follows the
            simple 33 year leap cycle implemented by .NET rather than the more complicated
            form of variable-length cycles and grand cycles devised by Ahmad Birashk.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.PersianYearMonthDayCalculator.TicksAtStartOfYear1Constant">
            <summary>The ticks for the epoch of March 21st 622CE.</summary>
        </member>
        <member name="T:NodaTime.Calendars.RegularYearMonthDayCalculator">
            <summary>
            Subclass of YearMonthDayCalculator for calendars with the following attributes:
            <list type="bullet">
            <item>A fixed number of months</item>
            <item>Occasional leap years which are always 1 day longer than non-leap years</item>
            </list>
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.TickArithmetic">
            <summary>
            Common operations on ticks.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.TickArithmetic.FastTicksToDays(System.Int64)">
            <summary>
            Converts a number of ticks into days, rounding down. The number of ticks must be
            non-negative (to have an easily-predictable outcome), but this is *not* validated in this method.
            This method is equivalent to dividing by NodaConstants.TicksPerStandardDay, but appears to be
            very significantly faster under the x64 JIT (and no slower under the x86 JIT).
            See http://stackoverflow.com/questions/22258070 for the inspiration.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.TickArithmetic.TicksToDays(System.Int64)">
            <summary>
            Converts a number of ticks into days, rounding down. This method works with any number of
            ticks, so long as it's not within the earliest representable 24 hours (where Noda Time arithmetic
            tends to go pear-shaped anyway...)
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.TimeOfDayCalculator">
            <summary>
            Calculator to handle time-of-day related fields.
            This is a static class because we don't intend to model
            different lengths of days, or hours etc. (We have no state
            at all, and need no polymorphism.)
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.WeekYearCalculator">
            <summary>
            Calculator for week-year, week-of-week-year and day-of-week-based calculations.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.WeekYearCalculator.GetWeekOfWeekYear(NodaTime.LocalInstant)">
            <summary>
            Finds the week-of-week year containing the given local instant, by finding out when the week year
            started, and then simply dividing "how far we are through the year" by "the number of ticks in a week".
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.WeekYearCalculator.GetWeekYearTicks(System.Int32)">
            <summary>
            Returns the ticks at the start of the given week-year.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.WeekYearCalculator.GetWeekYear(NodaTime.LocalInstant)">
            <summary>
            Finds the week-year containing the given local instant.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.YearMonthDay">
            <summary>
            Just a useful struct to be hand a whole year/month/day value in one go.
            This type is a dumb calendar-neutral type; it's just a composition of
            three integers.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.YearMonthDayCalculator.yearCache">
            <summary>
            Cache to speed up working out when a particular year starts.
            See the <see cref="T:NodaTime.Calendars.YearStartCacheEntry"/> documentation and <see cref="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInDays(System.Int32)"/>
            for more details.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.YearMonthDayCalculator.eras">
            <summary>
            Array of eras in this calculator; this is never mutated.
            </summary>
        </member>
        <member name="P:NodaTime.Calendars.YearMonthDayCalculator.TicksAtStartOfYear1">
            <summary>
            Only exposed outside the calculator for validation by tests.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetTicksFromStartOfYearToStartOfMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of ticks from the start of the given year to the start of the given month.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.CalculateStartOfYearDays(System.Int32)">
            <summary>
            Compute the start of the given year in days since 1970-01-01 ISO. The year may be outside
            the bounds advertised by the calendar, but only by a single year - this is
            used for internal calls which sometimes need to compare a valid value with
            an invalid one, for estimates etc.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.MonthsBetween(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Subtract subtrahendInstant from minuendInstant, in terms of months.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInTicks(System.Int32)">
            <summary>
            Returns the number of ticks since the Unix epoch at the start of the given year.
            This is virtual to allow GregorianCalendarSystem to override it for an ultra-efficient
            cache for modern years. This method can cope with a value for <paramref name="year"/> outside
            the normal range, so long as the resulting computation doesn't overflow. (Min and max years
            are therefore chosen to be slightly more restrictive than we would otherwise need, for the
            sake of simplicity.) This is useful for values which first involve estimates which might be out
            by a year either way.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearMonthDayTicks(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the ticks of the local instant at the start of the given year/month/day.
            This assumes all parameters have been validated previously.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearMonthTicks(System.Int32,System.Int32)">
            <summary>
            Returns the number of ticks (the LocalInstant, effectively) at the start of the
            given year/month.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetLocalInstant(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)">
            <summary>
            Era-based year/month/day: this implementation ignores the era, which is valid for single-era
            calendars, although it does validate the era first.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetEraIndex(NodaTime.Calendars.Era)">
            <summary>
            Convenience method to perform nullity and validity checking on the era, converting it to
            the index within the list of eras used in this calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearOfEra(NodaTime.LocalInstant)">
            <summary>
            Returns the year-of-era for the given local instant. The base implementation is to return the plain
            year, which is suitable for single-era calendars.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetCenturyOfEra(NodaTime.LocalInstant)">
            <summary>
            Handling for century-of-era where (say) year 123 is in century 2... but so is year 200.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearOfCentury(NodaTime.LocalInstant)">
            <summary>
            Handling for year-of-century in the range [1, 100].
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetEra(NodaTime.LocalInstant)">
            <summary>
            Returns the era for the given local instant. The base implementation is to return 0, which is
            suitable for single-era calendars.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetAbsoluteYear(System.Int32,System.Int32)">
            <summary>
            Default implementation of GetAbsoluteYear which assumes a single era.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetMinYearOfEra(System.Int32)">
            <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)" /> - but this uses a pre-validated index.
            This default implementation returns 1, but can be overridden by derived classes.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetMaxYearOfEra(System.Int32)">
            <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)"/> - but this uses a pre-validated index.
            This default implementation returns the maximum year for this calendar, which is
            a valid implementation for single-era calendars.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInDays(System.Int32)">
            <summary>
            Fetches the start of the year (in days since 1970-01-01 ISO) from the cache, or calculates
            and caches it.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.YearStartCacheEntry">
            <summary>
            Type containing as much logic as possible for how the cache of "start of year" data works.
            As of Noda Time 1.3, this is not specific to YearMonthDayCalculator - it can be used for
            other frames of reference, so long as they comply with the restrictions listed below.
            </summary>
            <remarks>
            <para>
            Each entry in the cache is a 32-bit number. The "value" part of the entry consists of the
            number of days since the Unix epoch (negative for a value before the epoch). As Noda Time
            only supports a number of ticks since the Unix epoch of between long.MinValue and long.MaxValue,
            we only need to support a number of days in the range
            [long.MinValue / TicksPerDay, long.MaxValue / TicksPerDay] which is [-10675200, 10675200] (rounding
            away from 0). This value can be stored in 25 bits.
            </para>
            <para>
            The remaining 7 bits of the value are used for validation. For any given year, the bottom
            10 bits are used as the index into the cache (which is an array). The next 7 most significant
            bits are stored in the entry. So long as we have fewer than 17 significant bits in the year value,
            this will be a unique combination. A single validation value (the most highly positive value) is
            reserved to indicate an invalid entry. The cache is initialized with all entries invalid.
            This gives us a range of year numbers greater than [-60000, 60000] without any risk of collisions. By
            contrast, the ISO calendar years are in the range [-27255, 31195] - so we'd have to be dealing with a
            calendar with either very short years, or an epoch a long way ahead or behind the Unix epoch.
            </para>
            <para>
            The fact that each cache entry is only 32 bits means that we can safely use the cache from multiple
            threads without locking. 32-bit aligned values are guaranteed to be accessed atomically, so we know we'll
            never get the value for one year with the validation bits for another, for example.
            </para>
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.YearStartCacheEntry.Invalid">
            <summary>
            Entry which is guaranteed to be obviously invalid for any real date, by having
            a validation value which is larger than any valid year number.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.YearStartCacheEntry.value">
            <summary>
            Entry value: most significant 25 bits are the number of days (e.g. since the Unix epoch); remaining 7 bits are
            the validator.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearStartCacheEntry.GetValidator(System.Int32)">
            <summary>
            Returns the validator to use for a given year, a non-negative number containing at most
            EntryValidationBits bits.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearStartCacheEntry.GetCacheIndex(System.Int32)">
            <summary>
            Returns the cache index, in [0, CacheSize), that should be used to store the given year's cache entry.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearStartCacheEntry.IsValidForYear(System.Int32)">
            <summary>
            Returns whether this cache entry is valid for the given year, and so is safe to use.  (We assume that we
            have located this entry via the correct cache index.)
            </summary>
        </member>
        <member name="P:NodaTime.Calendars.YearStartCacheEntry.StartOfYearDays">
            <summary>
            Returns the (signed) number of days since the Unix epoch for the cache entry.
            </summary>
        </member>
        <member name="T:NodaTime.DateTimeZoneProviders">
            <summary>
            Static access to date/time zone providers built into Noda Time and for global configuration where this is unavoidable.
            All properties are thread-safe, and the providers returned by the read-only properties cache their results.
            </summary>
        </member>
        <member name="P:NodaTime.DateTimeZoneProviders.Tzdb">
            <summary>
            Gets a time zone provider which uses a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>.
            The underlying source is <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default"/>, which is initialized from
            resources within the NodaTime assembly.
            </summary>
        </member>
        <member name="P:NodaTime.DateTimeZoneProviders.Default">
            <summary>
            Gets the TZDB time zone provider.
            This always returns the same value as the <see cref="P:NodaTime.DateTimeZoneProviders.Tzdb"/> property.
            </summary>
            <remarks>This method is not available in the PCL version, as it was made obsolete in Noda Time 1.1.</remarks>
            <seealso cref="P:NodaTime.DateTimeZoneProviders.Tzdb"/>
        </member>
        <member name="P:NodaTime.DateTimeZoneProviders.Bcl">
            <summary>
            Gets a time zone provider which uses a <see cref="T:NodaTime.TimeZones.BclDateTimeZoneSource"/>.
            This property is not available on the PCL build of Noda Time.
            </summary>
        </member>
        <member name="P:NodaTime.DateTimeZoneProviders.Serialization">
            <summary>
            The <see cref="T:NodaTime.IDateTimeZoneProvider"/> to use to interpret a time zone ID read as part of
            XML or binary serialization.
            </summary>
            <remarks>
            This property defaults to <see cref="P:NodaTime.DateTimeZoneProviders.Tzdb"/>. The mere existence of
            this property is unfortunate, but XML and binary serialization in .NET provide no simple way of configuring
            appropriate context. It is expected that any single application is unlikely to want to serialize
            <c>ZonedDateTime</c> values using different time zone providers.
            </remarks>
        </member>
        <member name="T:NodaTime.Fields.MonthsPeriodField">
            <summary>
            Period field which uses a <see cref="T:NodaTime.Calendars.YearMonthDayCalculator" /> to add/subtract months.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.FixedDurationPeriodField">
            <summary>
            Period field class representing a field with a fixed duration regardless of when it occurs.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.IPeriodField">
            <summary>
            General representation of the difference between two LocalInstant values in a particular unit,
            such as "months" or "hours". This is effectively a vector type: it doesn't make sense to ask
            a period field for its value at a particular local instant; instead, a number of units can be
            added to an existing local instant, and you can request the difference between two local instants
            in terms of that unit.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.IPeriodField.Add(NodaTime.LocalInstant,System.Int64)">
            <summary>
            Adds a duration value (which may be negative) to the instant. This may not
            be reversible; for example, adding a month to January 30th will result in
            February 28th or February 29th.
            </summary>
            <param name="localInstant">The local instant to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local instant</returns>
        </member>
        <member name="M:NodaTime.Fields.IPeriodField.Subtract(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Computes the difference between two local instants, as measured in the units
            of this field. Any fractional units are dropped from the result. Calling
            Subtract reverses the effect of calling Add, as far as possible.
            </summary>
            <remarks>
            The result is determined so as not to overshoot when added back: calling
            <see cref="M:NodaTime.Fields.IPeriodField.Add(NodaTime.LocalInstant,System.Int64)"/> using <paramref name="subtrahendInstant"/> and
            the result of this method will yield a value which is between <paramref name="subtrahendInstant"/>
            and <paramref name="minuendInstant"/>. (In a simpler world, it would exactly equal
            <paramref name="minuendInstant"/>, but that's not always possible.)
            </remarks>
            <param name="minuendInstant">The local instant to subtract from</param>
            <param name="subtrahendInstant">The local instant to subtract from minuendInstant</param>
            <returns>The difference in the units of this field</returns>
        </member>
        <member name="T:NodaTime.Fields.NamespaceDoc">
            <summary>
            <para>
            The NodaTime.Fields namespace contains types related to individual period fields.
            All types within this namespace are internal.
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.Fields.YearsPeriodField">
            <summary>
            Period field which uses a <see cref="T:NodaTime.Calendars.YearMonthDayCalculator" /> to add/subtract years.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.PeriodFieldSet">
            <summary>
            An immutable collection of date/time and period fields.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.PeriodFieldSet.Builder">
            <summary>
            Mutable set of fields which can be built into a full, immutable FieldSet.
            </summary>
        </member>
        <member name="T:NodaTime.Globalization.NamespaceDoc">
            <summary>
            <para>
            The NodaTime.Globalization namespace contains types related to culture-sensitive
            aspects of behaviour, principally for the sake of text formatting and parsing.
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.Globalization.NodaFormatInfo">
            <summary>
            A <see cref="T:System.IFormatProvider"/> for Noda Time types, initialised from a <see cref="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo"/>.
            This provides a single place defining how NodaTime values are formatted and displayed, depending on the culture.
            </summary>
            <remarks>
            Currently this is "shallow-immutable" - although none of these properties can be changed, the
            CultureInfo itself may be mutable. In the future we will make this fully immutable.
            </remarks>
            <threadsafety>Instances which use read-only CultureInfo instances are immutable,
            and may be used freely between threads. Instances with mutable cultures should not be shared between threads
            without external synchronization.
            See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Globalization.NodaFormatInfo.InvariantInfo">
            <summary>
            A NodaFormatInfo wrapping the invariant culture.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> class.
            </summary>
            <param name="cultureInfo">The culture info to base this on.</param>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertMonthArray(System.String[])">
            <summary>
            The BCL returns arrays of month names starting at 0; we want a read-only list starting at 1 (with 0 as null).
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertDayArray(System.String[])">
            <summary>
            The BCL returns arrays of week names starting at 0 as Sunday; we want a read-only list starting at 1 (with 0 as null)
            and with 7 as Sunday.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertGenitiveMonthArray(System.Collections.Generic.IList{System.String},System.String[],System.String[])">
            <summary>
            Checks whether any of the genitive names differ from the non-genitive names, and returns
            either a reference to the non-genitive names or a converted list as per ConvertMonthArray.
            </summary>
            <remarks>
            <para>
            Mono uses the invariant month names for the genitive month names by default, so we'll assume that
            if we see an invariant name, that *isn't* deliberately a genitive month name. A non-invariant culture
            which decided to have genitive month names exactly matching the invariant ones would be distinctly odd.
            See http://bugzilla.xamarin.com/show_bug.cgi?id=3278 for more details and progress.
            </para>
            <para>
            Mono 3.0.6 has an exciting and different bug, where all the abbreviated genitive month names are just numbers ("1" etc).
            So again, if we detect that, we'll go back to the non-genitive version.
            See http://bugzilla.xamarin.com/show_bug.cgi?id=11361 for more details and progress.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo">
            <summary>
            Gets the culture info associated with this format provider.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.CompareInfo">
            <summary>
            Gets the text comparison information associated with this format provider.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.LongMonthNames">
            <summary>
            Returns a read-only list of the names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "January".
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthNames">
            <summary>
            Returns a read-only list of the abbreviated names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "Jan".
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.LongMonthGenitiveNames">
            <summary>
            Returns a read-only list of the names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "January".
            The genitive form is used for month text where the day of month also appears in the pattern.
            If the culture does not use genitive month names, this property will return the same reference as
            <see cref="P:NodaTime.Globalization.NodaFormatInfo.LongMonthNames"/>.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthGenitiveNames">
            <summary>
            Returns a read-only list of the abbreviated names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "Jan".
            The genitive form is used for month text where the day also appears in the pattern.
            If the culture does not use genitive month names, this property will return the same reference as
            <see cref="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthNames"/>.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.LongDayNames">
            <summary>
            Returns a read-only list of the names of the days of the week for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, and the other elements correspond with the index values returned from
            <see cref="P:NodaTime.LocalDateTime.DayOfWeek"/> and similar properties.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortDayNames">
            <summary>
            Returns a read-only list of the abbreviated names of the days of the week for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, and the other elements correspond with the index values returned from
            <see cref="P:NodaTime.LocalDateTime.DayOfWeek"/> and similar properties.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.NumberFormat">
            <summary>
            Gets the number format associated with this formatting information.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.DateTimeFormat">
            <summary>
            Gets the BCL date time format associated with this formatting information.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.PositiveSign">
            <summary>
              Gets the positive sign.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.NegativeSign">
            <summary>
            Gets the negative sign.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.TimeSeparator">
            <summary>
            Gets the time separator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.DateSeparator">
            <summary>
            Gets the date separator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.AMDesignator">
            <summary>
            Gets the AM designator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.PMDesignator">
            <summary>
            Gets the PM designator.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetEraNames(NodaTime.Calendars.Era)">
            <summary>
            Returns the names for the given era in this culture.
            </summary>
            <param name="era">The era to find the names of.</param>
            <returns>A read-only list of names for the given era, or an empty list if
            the era is not known in this culture.</returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetEraPrimaryName(NodaTime.Calendars.Era)">
            <summary>
            Returns the primary name for the given era in this culture.
            </summary>
            <param name="era">The era to find the primary name of.</param>
            <returns>The primary name for the given era, or an empty string if the era name is not known.</returns>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.CurrentInfo">
            <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> object for the current thread.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternFull">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "F" pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternLong">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "L" pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternMedium">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "M" pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternShort">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "S" pattern.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ClearCache">
            <summary>
            Clears the cache. Only used for test purposes.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetFormatInfo(System.Globalization.CultureInfo)">
            <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> for the given <see cref="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo" />.
            </summary>
            <remarks>
            This method maintains a cache of results for read-only cultures.
            </remarks>
            <param name="cultureInfo">The culture info.</param>
            <returns>The <see cref="T:NodaTime.Globalization.NodaFormatInfo" />. Will never be null.</returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetInstance(System.IFormatProvider)">
            <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> for the given <see cref="T:System.IFormatProvider" />. If the
            format provider is null or if it does not provide a <see cref="T:NodaTime.Globalization.NodaFormatInfo" />
            object then the format object for the current thread is returned.
            </summary>
            <param name="provider">The <see cref="T:System.IFormatProvider" />.</param>
            <returns>The <see cref="T:NodaTime.Globalization.NodaFormatInfo" />. Will never be null.</returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
        </member>
        <member name="T:NodaTime.Globalization.NodaFormatInfo.EraDescription">
            <summary>
            The description for an era: the primary name and all possible names.
            </summary>
        </member>
        <member name="T:NodaTime.OffsetDateTime">
            <summary>
            A local date and time in a particular calendar system, combined with an offset from UTC. This is
            broadly similar to <see cref="T:System.DateTimeOffset" /> in the BCL.
            </summary>
            <remarks>
            <para>
            A value of this type unambiguously represents both a local time and an instant on the timeline,
            but does not have a well-defined time zone. This means you cannot reliably know what the local
            time would be five minutes later, for example. While this doesn't sound terribly useful, it's very common
            in text representations.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.OffsetDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.Offset)">
            <summary>
            Constructs a new offset date/time with the given local date and time, and the given offset from UTC.
            </summary>
            <param name="localDateTime">Local date and time to represent</param>
            <param name="offset">Offset from UTC</param>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Calendar">
            <summary>Gets the calendar system associated with this local date and time.</summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Year">
            <summary>Gets the year of this offset date and time.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Month">
            <summary>Gets the month of this offset date and time within the year.</summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Day">
            <summary>Gets the day of this offset date and time within the month.</summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.IsoDayOfWeek">
            <summary>
            Gets the week day of this offset date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value,
            for calendars which use ISO days of the week.
            </summary>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <seealso cref="P:NodaTime.OffsetDateTime.DayOfWeek"/>
        </member>
        <member name="P:NodaTime.OffsetDateTime.DayOfWeek">
            <summary>
            Gets the week day of this offset date and time as a number.
            </summary>
            <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
            <seealso cref="P:NodaTime.OffsetDateTime.IsoDayOfWeek"/>
        </member>
        <member name="P:NodaTime.OffsetDateTime.WeekYear">
            <summary>
            Gets the "week year" of this offset date and time.
            </summary>
            <remarks>
            <para>
            The WeekYear is the year that matches with the <see cref="P:NodaTime.OffsetDateTime.WeekOfWeekYear"/> field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day.
            </para>
            <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.OffsetDateTime.WeekOfWeekYear">
            <summary>Gets the week within the WeekYear. See <see cref="P:NodaTime.OffsetDateTime.WeekYear"/> for more details.</summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.YearOfCentury">
            <summary>Gets the year of this offset date and time within the century.</summary>
            <remarks>This always returns a value in the range 0 to 99 inclusive.</remarks>
        </member>
        <member name="P:NodaTime.OffsetDateTime.YearOfEra">
            <summary>Gets the year of this offset date and time within the era.</summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Era">
            <summary>Gets the era of this offset date and time.</summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.DayOfYear">
            <summary>Gets the day of this offset date and time within the year.</summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Hour">
            <summary>
            Gets the hour of day of this offset date and time, in the range 0 to 23 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this date and time, in the range 1 to 12 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Minute">
            <summary>
            Gets the minute of this offset date and time, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Second">
            <summary>
            Gets the second of this offset date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Millisecond">
            <summary>
            Gets the millisecond of this offset date and time within the second, in the range 0 to 999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.TickOfSecond">
            <summary>
            Gets the tick of this offset date and time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.TickOfDay">
            <summary>
            Gets the tick of this offset date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.LocalDateTime">
            <summary>
            Returns the local date and time represented within this offset date and time.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Date">
            <summary>
            Gets the local date represented by this offset date and time. The returned <see cref="T:NodaTime.LocalDate"/>
            will have the same calendar system and return the same values for each of the date-based calendar
            properties (Year, MonthOfYear and so on), but will not have any offset information.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.TimeOfDay">
            <summary>
            Gets the time portion of this offset date and time. The returned <see cref="T:NodaTime.LocalTime"/> will
            return the same values for each of the time-based properties (Hour, Minute and so on), but
            will not have any offset information.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Offset">
            <summary>
            Returns the offset from UTC.
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToInstant">
            <summary>
            Converts this offset date and time to an instant in time by subtracting the offset from the local date and time.
            </summary>
            <returns>The instant represented by this offset date and time</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.InFixedZone">
            <summary>
            Returns this value as a <see cref="T:NodaTime.ZonedDateTime"/>.
            </summary>
            <remarks>
            <para>
            This method returns a <see cref="T:NodaTime.ZonedDateTime"/> with the same local date and time as this value, using a
            fixed time zone with the same offset as the offset for this value.
            </para>
            <para>
            Note that because the resulting <c>ZonedDateTime</c> has a fixed time zone, it is generally not useful to
            use this result for arithmetic operations, as the zone will not adjust to account for daylight savings.
            </para>
            </remarks>
            <returns>A zoned date/time with the same local time and a fixed time zone using the offset from this value.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToDateTimeOffset">
            <summary>
            Returns the BCL <see cref="T:System.DateTimeOffset"/> corresponding to this offset date and time.
            </summary>
            <returns>A DateTimeOffset with the same local date/time and offset as this. The <see cref="T:System.DateTime"/> part of
            the result always has a "kind" of Unspecified.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Builds an <see cref="T:NodaTime.OffsetDateTime"/> from a BCL <see cref="T:System.DateTimeOffset"/> by converting
            the <see cref="T:System.DateTime"/> part to a <see cref="P:NodaTime.OffsetDateTime.LocalDateTime"/>, and the offset part to an <see cref="P:NodaTime.OffsetDateTime.Offset"/>.
            </summary>
            <param name="dateTimeOffset">DateTimeOffset to convert</param>
            <returns>The converted offset date and time</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a new OffsetDateTime representing the same physical date, time and offset, but in a different calendar.
            The returned OffsetDateTime is likely to have different date field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
            <param name="calendarSystem">The calendar system to convert this local date to.</param>
            <returns>The converted OffsetDateTime.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.WithOffset(NodaTime.Offset)">
            <summary>
            Creates a new OffsetDateTime representing the instant in time in the same calendar,
            but with a different offset. The local date and time is adjusted accordingly.
            </summary>
            <param name="offset">The new offset to use.</param>
            <returns>The converted OffsetDateTime.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.GetHashCode">
            <summary>
            Returns a hash code for this local date.
            </summary>
            <returns>A hash code for this local date.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime"/> values for equality. This requires
            that the local date/time values be the same (in the same calendar) and the offsets.
            </summary>
            <param name="obj">The object to compare this date with.</param>
            <returns>True if the given value is another offset date/time equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Equals(NodaTime.OffsetDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime"/> values for equality. This requires
            that the local date/time values be the same (in the same calendar) and the offsets.
            </summary>
            <param name="other">The value to compare this offset date/time with.</param>
            <returns>True if the given value is another offset date/time equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.OffsetDateTime.op_Equality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.op_Inequality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:NodaTime.OffsetDateTime.Comparer">
            <summary>
            Base class for <see cref="T:NodaTime.OffsetDateTime"/> comparers.
            </summary>
            <remarks>
            <para>Use the static properties of this class to obtain instances.</para>
            <para>For the curious: this class only exists so that in the future, it can expose more functionality - probably
            implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>. If we simply provided properties on OffsetDateTime of type
            <see cref="T:System.Collections.Generic.IComparer`1"/> we'd have no backward-compatible way of adding to the set of implemented interfaces.</para>
            </remarks>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Comparer.Local">
            <summary>
            Returns a comparer which compares <see cref="T:NodaTime.OffsetDateTime"/> values by their local date/time, without reference to
            either the offset or the calendar system.
            </summary>
            <remarks>
            <para>For example, this comparer considers 2013-03-04T20:21:00+0100 to be later than 2013-03-04T19:21:00-0700 even though
            the second value represents a later instant in time.</para>
            <para>This property will return a reference to the same instance every time it is called.</para>
            </remarks>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Comparer.Instant">
            <summary>
            Returns a comparer which compares <see cref="T:NodaTime.OffsetDateTime"/> values by the instant values obtained by applying the offset to
            the local date/time, ignoring the calendar system.
            </summary>
            <remarks>
            <para>For example, this comparer considers 2013-03-04T20:21:00+0100 to be earlier than 2013-03-04T19:21:00-0700 even though
            the second value has a local time which is earlier.</para>
            <para>This property will return a reference to the same instance every time it is called.</para>
            </remarks>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Comparer.#ctor">
            <summary>
            Internal constructor to prevent external classes from deriving from this.
            (That means we can add more abstract members in the future.)
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Comparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime"/> values and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first value to compare.</param>
            <param name="y">The second value to compare.</param>
            <returns>A signed integer that indicates the relative values of <paramref name="x"/> and <paramref name="y"/>, as shown in the following table.
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>Less than zero</term>
                  <description><paramref name="x"/> is less than <paramref name="y"/>.</description>
                </item>
                <item>
                  <term>Zero</term>
                  <description><paramref name="x"/> is equals to <paramref name="y"/>.</description>
                </item>
                <item>
                  <term>Greater than zero</term>
                  <description><paramref name="x"/> is greater than <paramref name="y"/>.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="T:NodaTime.OffsetDateTime.LocalComparer">
            <summary>
            Implementation for <see cref="P:NodaTime.OffsetDateTime.Comparer.Local"/>
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.LocalComparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.OffsetDateTime.InstantComparer">
            <summary>
            Implementation for <see cref="P:NodaTime.OffsetDateTime.Comparer.Instant"/>.
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.InstantComparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.OffsetDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.IDateTimeZoneProvider">
            <summary>
            Provides stable, performant time zone data.
            </summary>
            <remarks>
            <para>Consumers should be able to treat an <see cref="T:NodaTime.IDateTimeZoneProvider"/> like a cache: 
            lookups should be quick (after at most one lookup of a given ID), and the data for a given ID should always be
            the same (even if the specific instance returned is not).
            Consumers should not feel the need to cache data accessed through this interface.</para>
            <para>Implementations designed to work with any <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/> implementation (such as
            <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>) should not attempt to handle exceptions thrown by the source. A source-specific
            provider may do so, as it has more detailed knowledge of what can go wrong and how it can best be handled.</para>
            </remarks>
        </member>
        <member name="P:NodaTime.IDateTimeZoneProvider.VersionId">
            <summary>
            The version ID of this provider.
            </summary>
        </member>
        <member name="P:NodaTime.IDateTimeZoneProvider.Ids">
            <summary>
            Gets the list of valid time zone ids advertised by this provider.
            </summary>
            <remarks>
            <para>
            This list will be sorted in ordinal lexicographic order. It cannot be modified by callers, and
            must not be modified by the provider either: client code can safely treat it as thread-safe
            and deeply immutable.
            </para>
            <para>
            In addition to the list returned here, providers always support the fixed-offset timezones with IDs "UTC"
            and "UTC+/-Offset". These may or may not be included explicitly in this list.
            </para>
            </remarks>
            <value>The <see cref="T:System.Collections.Generic.IEnumerable`1" /> of string ids.</value>
        </member>
        <member name="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault">
            <summary>
            Gets the time zone from this provider that matches the system default time zone, if a matching time zone is
            available.
            </summary>
            <remarks>
            <para>
            Callers should be aware that this method will throw <see cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException"/> if no matching
            time zone is found. For the built-in Noda Time providers, this is unlikely to occur in practice (assuming
            the system is using a standard Windows time zone), but can occur even then, if no mapping is found. The TZDB
            source contains mappings for almost all Windows system time zones, but a few (such as "Mid-Atlantic Standard Time")
            are unmappable.
            </para>
            <para>
            If it is necessary to handle this case, callers can construct a
            <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> via <see cref="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault"/>, which returns a
            <see cref="T:NodaTime.DateTimeZone"/> that wraps the system local <see cref="T:System.TimeZoneInfo"/>, and which always
            succeeds. Note that <c>BclDateTimeZone</c> is not available on the PCL build of Noda Time, so
            this fallback strategy can only be used with the desktop version.
            </para>
            </remarks>
            <exception cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">The system default time zone is not mapped by
            this provider.</exception>
            <returns>
            The provider-specific representation of the system default time zone.
            </returns>
        </member>
        <member name="M:NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)">
            <summary>
            Returns the time zone for the given ID, if it's available.
            </summary>
            <remarks>
            <para>
            Note that this may return a <see cref="T:NodaTime.DateTimeZone"/> that has a different ID to that requested, if the ID
            provided is an alias.
            </para>
            <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone"/> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare
            as equal.
            </para>
            <para>
            The fixed-offset timezones with IDs "UTC" and "UTC+/-Offset" are always available. These must
            return instances that are equal to those returned by <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)"/>.
            </para>
            </remarks>
            <param name="id">The time zone ID to find.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone" /> for the given ID or null if the provider does not support
            the given ID.</returns>
        </member>
        <member name="P:NodaTime.IDateTimeZoneProvider.Item(System.String)">
            <summary>
            Returns the time zone for the given ID.
            </summary>
            <remarks>
            <para>
            Unlike <see cref="M:NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)"/>, this indexer will never return a null reference. If the ID is not
            supported by this provider, it will throw <see cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException" />.
            </para>
            <para>
            Note that this may return a <see cref="T:NodaTime.DateTimeZone"/> that has a different ID to that requested, if the ID
            provided is an alias.
            </para>
            <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone"/> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare
            as equal.
            </para>
            <para>
            The fixed-offset timezones with IDs "UTC" and "UTC+/-Offset" are always available. These must
            return instances that are equal to those returned by <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)"/>.
            </para>
            </remarks>
            <param name="id">The time zone id to find.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone" /> for the given ID.</returns>
            <exception cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">This provider does not support the given ID.</exception>
        </member>
        <member name="T:NodaTime.PeriodBuilder">
            <summary>
            A mutable builder class for <see cref="T:NodaTime.Period"/> values. Each property can
            be set independently, and then a Period can be created from the result
            using the <see cref="M:NodaTime.PeriodBuilder.Build"/> method.
            </summary>
            <threadsafety>
            This type is not thread-safe without extra synchronization, but has no
            thread affinity.
            </threadsafety>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Years">
            <summary>
            Gets or sets the number of years within the period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Months">
            <summary>
            Gets or sets the number of months within the period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Weeks">
            <summary>
            Gets or sets the number of weeks within the period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Days">
            <summary>
            Gets or sets the number of days within the period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Hours">
            <summary>
            Gets or sets the number of hours within the period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Minutes">
            <summary>
            Gets or sets the number of minutes within the period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Seconds">
            <summary>
            Gets or sets the number of seconds within the period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Milliseconds">
            <summary>
            Gets or sets the number of milliseconds within the period.
            </summary>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Ticks">
            <summary>
            Gets or sets the number of ticks within the period.
            </summary>
        </member>
        <member name="M:NodaTime.PeriodBuilder.#ctor">
            <summary>
            Creates a new period builder with an initially zero period.
            </summary>
        </member>
        <member name="M:NodaTime.PeriodBuilder.#ctor(NodaTime.Period)">
            <summary>
            Creates a new period builder with the values from an existing
            period. Calling this constructor instead of <see cref="M:NodaTime.Period.ToBuilder"/>
            allows object initializers to be used.
            </summary>
            <param name="period">An existing period to copy values from.</param>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Item(NodaTime.PeriodUnits)">
            <summary>
            Gets or sets the value of a single unit.
            </summary>
            <param name="unit">A single value within the <see cref="T:NodaTime.PeriodUnits"/> enumeration.</param>
            <returns>The value of the given unit within this period builder, or zero if the unit is unset.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="unit"/> is not a single unit.</exception>
        </member>
        <member name="M:NodaTime.PeriodBuilder.Build">
            <summary>
            Builds a period from the properties in this builder.
            </summary>
            <returns>A period containing the values from this builder.</returns>
        </member>
        <member name="M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.PeriodUnits">
            <summary>
            The units within a <see cref="T:NodaTime.Period"/>. When a period is created to find the difference between two local values,
            the caller may specify which units are required - for example, you can ask for the difference between two dates
            in "years and weeks". Units are always applied largest-first in arithmetic.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.None">
            <summary>
            Value indicating no units - an empty period.
            </summary>        
        </member>
        <member name="F:NodaTime.PeriodUnits.Years">
            <summary>
            Years element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Months">
            <summary>
            Months element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Weeks">
            <summary>
            Weeks element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Days">
            <summary>
            Days element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.AllDateUnits">
            <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Years"/>, <see cref="F:NodaTime.PeriodUnits.Months"/>, <see cref="F:NodaTime.PeriodUnits.Weeks"/> and <see cref="F:NodaTime.PeriodUnits.Days"/>.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.YearMonthDay">
            <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Years"/>, <see cref="F:NodaTime.PeriodUnits.Months"/> and <see cref="F:NodaTime.PeriodUnits.Days"/>.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Hours">
            <summary>
            Hours element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Minutes">
            <summary>
            Minutes element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Seconds">
            <summary>
            Seconds element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Milliseconds">
            <summary>
            Milliseconds element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Ticks">
            <summary>
            Tick element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.HourMinuteSecond">
            <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Hours"/>, <see cref="F:NodaTime.PeriodUnits.Minutes"/> and <see cref="F:NodaTime.PeriodUnits.Seconds"/>.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.AllTimeUnits">
            <summary>
            Compound value representing the combination of all time elements.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.DateAndTime">
            <summary>
            Compound value representing the combination of all possible elements except weeks.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.AllUnits">
            <summary>
            Compound value representing the combination of all possible elements.
            </summary>
        </member>
        <member name="T:NodaTime.Properties.PatternResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.Eras_AnnoHegirae">
            <summary>
              Looks up a localized string similar to A.H.|AH.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.Eras_AnnoMartyrum">
            <summary>
              Looks up a localized string similar to A.M.|AM.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.Eras_AnnoMundi">
            <summary>
              Looks up a localized string similar to A.M.|AM.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.Eras_AnnoPersico">
            <summary>
              Looks up a localized string similar to A.P.|AP.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.Eras_BeforeCommon">
            <summary>
              Looks up a localized string similar to B.C.|B.C.E.|BC|BCE.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.Eras_Common">
            <summary>
              Looks up a localized string similar to A.D.|AD|C.E.|CE.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.OffsetPatternFull">
            <summary>
              Looks up a localized string similar to +HH:mm:ss.fff.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.OffsetPatternLong">
            <summary>
              Looks up a localized string similar to +HH:mm:ss.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.OffsetPatternMedium">
            <summary>
              Looks up a localized string similar to +HH:mm.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.PatternResources.OffsetPatternShort">
            <summary>
              Looks up a localized string similar to +HH.
            </summary>
        </member>
        <member name="T:NodaTime.Properties.Messages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Format_BadQuote">
            <summary>
              Looks up a localized string similar to Format string is missing a close quote: {0}.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.FormatDefaultExceptionMessage">
            <summary>
              Looks up a localized string similar to Format error..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Noda_ArgumentNull">
            <summary>
              Looks up a localized string similar to Argument cannot be null..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Noda_CannotChangeReadOnly">
            <summary>
              Looks up a localized string similar to Cannot change a read only object..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Noda_StringEmpty">
            <summary>
              Looks up a localized string similar to The string cannot be empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Noda_StringEmptyOrWhitespace">
            <summary>
              Looks up a localized string similar to The string cannot be empty or only contain white space..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_AmbiguousLocalTime">
            <summary>
              Looks up a localized string similar to The local date/time is ambiguous in the target time zone..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_CalendarAndEra">
            <summary>
              Looks up a localized string similar to The era specifier cannot be specified in the same pattern as the calendar specifier..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_CannotParseValue">
            <summary>
              Looks up a localized string similar to The value &quot;{0}&quot; cannot be parsed into an instance of {1} using pattern &quot;{2}&quot;.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_DateSeparatorMismatch">
            <summary>
              Looks up a localized string similar to The value string does not match a date separator in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_DayOfMonthOutOfRange">
            <summary>
              Looks up a localized string similar to The day {0} is out of range in month {1} of year {2}..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_DoubleAssignment">
            <summary>
              Looks up a localized string similar to The pattern flag &apos;{0}&apos; cannot appear twice and parse different values..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_EmptyFormatsArray">
            <summary>
              Looks up a localized string similar to The list of formats cannot be empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_EmptyPeriod">
            <summary>
              Looks up a localized string similar to The specified period was empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_EmptyZPrefixedOffsetPattern">
            <summary>
              Looks up a localized string similar to The Z prefix for an Offset pattern must be followed by a custom pattern..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_EndOfString">
            <summary>
              Looks up a localized string similar to Input string ended unexpectedly early..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_EraWithoutYearOfEra">
            <summary>
              Looks up a localized string similar to The era specifier cannot be used without the &quot;year of era&quot; specifier..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_EscapeAtEndOfString">
            <summary>
              Looks up a localized string similar to The format string has an escape character (backslash &apos;\&apos;) at the end of the string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_EscapedCharacterMismatch">
            <summary>
              Looks up a localized string similar to The value string does not match an escaped character in the format string: &quot;\{0}&quot;.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_ExpectedEndOfString">
            <summary>
              Looks up a localized string similar to Expected end of input, but more data remains..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_ExtraValueCharacters">
            <summary>
              Looks up a localized string similar to The format matches a prefix of the value string but not the entire string. Part not matching: &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_FieldValueOutOfRange">
            <summary>
              Looks up a localized string similar to The value {0} is out of range for the field &apos;{1}&apos; in the {2} type..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_FormatElementInvalid">
            <summary>
              Looks up a localized string similar to The items of the format string array cannot be null or empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_FormatInvalid">
            <summary>
              Looks up a localized string similar to The format string is invalid: &quot;{0}&quot;.
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_FormatOnlyPattern">
            <summary>
              Looks up a localized string similar to This pattern is only capable of formatting, not parsing..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_FormatStringEmpty">
            <summary>
              Looks up a localized string similar to The format string is empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_Hour12PatternNotSupported">
            <summary>
              Looks up a localized string similar to The &apos;h&apos; pattern flag (12 hour format) is not supported by the {0} type..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_InconsistentDayOfWeekTextValue">
            <summary>
              Looks up a localized string similar to The specified day of the week does not matched the computed value..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_InconsistentMonthTextValue">
            <summary>
              Looks up a localized string similar to The month values specified as text and numbers are inconsistent..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_InconsistentValues2">
            <summary>
              Looks up a localized string similar to The individual values for the fields &apos;{0}&apos; and &apos;{1}&apos; created an inconsistency in the {2} type..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_InvalidHour24">
            <summary>
              Looks up a localized string similar to 24 is only valid as an hour number when the units smaller than hours are all 0..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_InvalidOffset">
            <summary>
              Looks up a localized string similar to The specified offset is invalid for the given date/time..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_InvalidUnitSpecifier">
            <summary>
              Looks up a localized string similar to The period unit specifier &apos;{0}&apos; is invalid..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MismatchedCharacter">
            <summary>
              Looks up a localized string similar to The value string does not match a simple character in the format string &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MismatchedNumber">
            <summary>
              Looks up a localized string similar to The value string does not match the required number from the format string &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MismatchedText">
            <summary>
              Looks up a localized string similar to The value string does not match the text-based field &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MisplacedUnitSpecifier">
            <summary>
              Looks up a localized string similar to The period unit specifier &apos;{0}&apos; appears at the wrong place in the input string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MissingAmPmDesignator">
            <summary>
              Looks up a localized string similar to The value string does not match the AM or PM designator for the culture at the required place..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MissingEmbeddedPatternEnd">
            <summary>
              Looks up a localized string similar to The pattern has an embedded pattern which is missing its closing character (&apos;{0}&apos;)..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MissingEmbeddedPatternStart">
            <summary>
              Looks up a localized string similar to The pattern has an embedded pattern which is missing its opening character (&apos;{0}&apos;)..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MissingEndQuote">
            <summary>
              Looks up a localized string similar to The format string is missing the end quote character &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MissingNumber">
            <summary>
              Looks up a localized string similar to The value string does not include a number in the expected position..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MissingSign">
            <summary>
              Looks up a localized string similar to The required value sign is missing..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MonthOutOfRange">
            <summary>
              Looks up a localized string similar to The month {0} is out of range in year {1}..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_MultipleCapitalDurationFields">
            <summary>
              Looks up a localized string similar to Only one of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; or &quot;S&quot; can occur in a duration format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_NoMatchingCalendarSystem">
            <summary>
              Looks up a localized string similar to The specified calendar id is not recognized..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_NoMatchingFormat">
            <summary>
              Looks up a localized string similar to None of the specified formats matches the given value string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_NoMatchingZoneId">
            <summary>
              Looks up a localized string similar to The specified time zone identifier is not recognized..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_PercentAtEndOfString">
            <summary>
              Looks up a localized string similar to A percent sign (%) appears at the end of the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_PercentDoubled">
            <summary>
              Looks up a localized string similar to A percent sign (%) is followed by another percent sign in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_PositiveSignInvalid">
            <summary>
              Looks up a localized string similar to A positive value sign is not valid at this point..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_PrecisionNotSupported">
            <summary>
              Looks up a localized string similar to The standard format &quot;{0}&quot; for type {1} does not support a precision..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_QuotedStringMismatch">
            <summary>
              Looks up a localized string similar to The value string does not match a quoted string in the pattern..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_RepeatCountExceeded">
            <summary>
              Looks up a localized string similar to There were more consecutive copies of the pattern character &quot;{0}&quot; than the maximum allowed ({1}) in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_RepeatCountUnderMinimum">
            <summary>
              Looks up a localized string similar to There were fewer consecutive copies of the pattern character &quot;{0}&quot; than the minimum allowed ({1}) in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_RepeatedFieldInPattern">
            <summary>
              Looks up a localized string similar to The field &quot;{0}&quot; is specified multiple times in the pattern..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_RepeatedUnitSpecifier">
            <summary>
              Looks up a localized string similar to The period unit specifier &apos;{0}&apos; appears multiple times in the input string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_SkippedLocalTime">
            <summary>
              Looks up a localized string similar to The local date/time is skipped in the target time zone..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_TimeSeparatorMismatch">
            <summary>
              Looks up a localized string similar to The value string does not match a time separator in the format string..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_UnexpectedEndOfString">
            <summary>
              Looks up a localized string similar to More characters were expected in the parsable string [{0}]..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_UnexpectedNegative">
            <summary>
              Looks up a localized string similar to The value string includes a negative value where only a non-negative one is allowed..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_UnknownFailure">
            <summary>
              Looks up a localized string similar to Internal Error: The specified ParseFailureKind is unknown [{0}]..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_UnknownStandardFormat">
            <summary>
              Looks up a localized string similar to The standard format &quot;{0}&quot; is not valid for the {1} type..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_UnparsableValue">
            <summary>
              Looks up a localized string similar to {0} Value being parsed: &apos;{1}&apos;. (^ indicates error position.).
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_UnparsableValuePostParse">
            <summary>
              Looks up a localized string similar to {0} Value being parsed: &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_ValueOutOfRange">
            <summary>
              Looks up a localized string similar to The value {0} is out of the legal range for the {1} type..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_ValueStringEmpty">
            <summary>
              Looks up a localized string similar to The value string is empty..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_YearOfEraOutOfRange">
            <summary>
              Looks up a localized string similar to The year {0} is out of range for the {1} era in the {2} calendar..
            </summary>
        </member>
        <member name="P:NodaTime.Properties.Messages.Parse_ZPrefixNotAtStartOfPattern">
            <summary>
              Looks up a localized string similar to The Z prefix for an Offset pattern must occur at the beginning of the pattern..
            </summary>
        </member>
        <member name="T:NodaTime.Properties.AssemblyInfo">
            <summary>
            Just a static class to house the public key, which allows us to avoid repeating it all over the place.
            </summary>
        </member>
        <member name="T:NodaTime.Text.DurationPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Duration"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.DurationPattern.RoundtripPattern">
            <summary>
            General pattern for durations using the invariant culture, with a format string of "-D:hh:mm:ss.FFFFFFF".
            This pattern round-trips.
            </summary>
        </member>
        <member name="P:NodaTime.Text.DurationPattern.PatternText">
            <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
        </member>
        <member name="P:NodaTime.Text.DurationPattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.Format(NodaTime.Duration)">
            <summary>
            Formats the given duration as text according to the rules of this pattern.
            </summary>
            <param name="value">The duration to format.</param>
            <returns>The duration formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the given pattern text and format info.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">Localization information</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.DurationPatternParser.GetPositiveTicks(NodaTime.Duration)">
            <summary>
            Returns the absolute number of ticks in a duration, as a ulong in order to handle long.MinValue sensibly.
            </summary>
        </member>
        <member name="T:NodaTime.Text.DurationPatternParser.DurationParseBucket">
            <summary>
            Provides a container for the interim parsed pieces of an <see cref="T:NodaTime.Offset" /> value.
            </summary>
        </member>
        <member name="M:NodaTime.Text.DurationPatternParser.DurationParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
            <summary>
            Calculates the value from the parsed pieces.
            </summary>
        </member>
        <member name="T:NodaTime.Text.OffsetDateTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.OffsetDateTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern">
            <summary>
            Returns an invariant offset date/time pattern based on ISO-8601 (down to the second), including offset from UTC.
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "yyyy'-'MM'-'dd'T'HH':'mm':'sso&lt;G&gt;". This pattern is available as the "G"
            standard pattern (even though it is invariant).
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern">
            <summary>
            Returns an invariant offset date/time pattern based on ISO-8601 (down to the tick), including offset from UTC.
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFo&lt;G&gt;". This will round-trip any values
            in the ISO calendar, and is available as the "o" standard pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.Rfc3339Pattern">
            <summary>
            Returns an invariant offset date/time pattern based on RFC 3339 (down to the tick), including offset from UTC
            as hours and minutes only. The minutes part of the offset is always included, but any sub-minute component
            of the offset is lost. An offset of zero is formatted as 'Z', but all of 'Z', '+00:00' and '-00:00' are parsed
            the same way. The RFC 3339 meaning of '-00:00' is not supported by Noda Time.
            Note that parsing is case-sensitive (so 'T' and 'Z' must be upper case).
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFo&lt;Z+HH:mm&gt;".
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern">
            <summary>
            Returns an invariant offset date/time pattern based on ISO-8601 (down to the tick)
            including offset from UTC and calendar ID. It corresponds to a custom pattern of
            "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFo&lt;G&gt; '('c')'". This will round-trip any value in any calendar,
            and is available as the "r" standard pattern.
            </summary>
        </member>
        <member name="T:NodaTime.Text.OffsetDateTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.PatternText">
            <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.TemplateValue">
            <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.Format(NodaTime.OffsetDateTime)">
            <summary>
            Formats the given zoned date/time as text according to the rules of this pattern.
            </summary>
            <param name="value">The zoned date/time to format.</param>
            <returns>The zoned date/time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.OffsetDateTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.OffsetDateTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithPatternText(System.String)">
            <summary>
            Creates a pattern for the same original localization information as this pattern, but with the specified
            pattern text.
            </summary>
            <param name="newPatternText">The pattern text to use in the new pattern.</param>
            <returns>A new pattern with the given pattern text.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="newFormatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithTemplateValue(NodaTime.OffsetDateTime)">
            <summary>
            Creates a pattern for the same original pattern text and culture as this pattern, but with
            the specified template value.
            </summary>
            <param name="newTemplateValue">The template value to use in the new pattern.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.IPartialPattern`1">
            <summary>
            Internal interface supporting partial parsing and formatting. This is used
            when one pattern is embedded within another.
            </summary>
            <typeparam name="T">The type of value to be parsed or formatted.</typeparam>
        </member>
        <member name="M:NodaTime.Text.IPartialPattern`1.ParsePartial(NodaTime.Text.ValueCursor)">
            <summary>
            Parses a value from the current position in the cursor. This will
            not fail if the pattern ends before the cursor does - that's expected
            in most cases.
            </summary>
            <param name="cursor">The cursor to parse from.</param>
            <returns>The result of parsing from the cursor.</returns>
        </member>
        <member name="M:NodaTime.Text.IPartialPattern`1.FormatPartial(`0,System.Text.StringBuilder)">
            <summary>
            Formats the given value by appending to an existing StringBuilder.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The builder to append to.</param>
        </member>
        <member name="T:NodaTime.Text.ZonedDateTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.ZonedDateTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern">
            <summary>
            Returns an zoned local date/time pattern based on ISO-8601 (down to the second) including offset from UTC and zone ID.
            It corresponds to a custom pattern of "yyyy'-'MM'-'dd'T'HH':'mm':'ss z '('o&lt;g&gt;')'" and is available
            as the 'G' standard pattern.
            </summary>
            <remarks>
            The calendar system is not formatted as part of this pattern, and it cannot be used for parsing as no time zone
            provider is included. Call <see cref="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)"/> on the value of this property to obtain a
            pattern which can be used for parsing.
            </remarks>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern">
            <summary>
            Returns an invariant zoned date/time pattern based on ISO-8601 (down to the tick) including offset from UTC and zone ID.
            It corresponds to a custom pattern of "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF z '('o&lt;g&gt;')'" and is available
            as the 'F' standard pattern.
            </summary>
            <remarks>
            The calendar system is not formatted as part of this pattern, and it cannot be used for parsing as no time zone
            provider is included. Call <see cref="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)"/> on the value of this property to obtain a
            pattern which can be used for parsing.
            </remarks>
        </member>
        <member name="T:NodaTime.Text.ZonedDateTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.PatternText">
            <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.TemplateValue">
            <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.Resolver">
            <summary>
            Returns the resolver which is used to map local date/times to zoned date/times,
            handling skipped and ambiguous times appropriately (where the offset isn't specified in the pattern).
            </summary>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.ZoneProvider">
            <summary>
            Returns the provider which is used to look up time zones when parsing a pattern
            which contains a time zone identifier. This may be null, in which case the pattern can
            only be used for formatting (not parsing).
            </summary>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.Format(NodaTime.ZonedDateTime)">
            <summary>
            Formats the given zoned date/time as text according to the rules of this pattern.
            </summary>
            <param name="value">The zoned date/time to format.</param>
            <returns>The zoned date/time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.TimeZones.ZoneLocalMappingResolver,NodaTime.IDateTimeZoneProvider,NodaTime.ZonedDateTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, template value, mapping resolver and time zone provider.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <param name="resolver">Resolver to apply when mapping local date/time values into the zone.</param>
            <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.TimeZones.ZoneLocalMappingResolver,NodaTime.IDateTimeZoneProvider,NodaTime.ZonedDateTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, resolver, time zone provider, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            If <paramref name="zoneProvider"/> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="resolver">Resolver to apply when mapping local date/time values into the zone.</param>
            <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture(System.String,NodaTime.IDateTimeZoneProvider)">
            <summary>
            Creates a pattern for the given pattern text and time zone provider, using a strict resolver, the invariant
            culture, and a default template value of midnight January 1st 2000 UTC.
            </summary>
            <remarks>
            The resolver is only used if the pattern text doesn't include an offset.
            If <paramref name="zoneProvider"/> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.CreateWithCurrentCulture(System.String,NodaTime.IDateTimeZoneProvider)">
            <summary>
            Creates a pattern for the given pattern text and time zone provider, using a strict resolver, the current
            culture, and a default template value of midnight January 1st 2000 UTC.
            </summary>
            <remarks>
            The resolver is only used if the pattern text doesn't include an offset.
            If <paramref name="zoneProvider"/> is null, the resulting pattern can be used for formatting
            but not parsing. Note that the current culture is captured at the time this method is called
            - it is not captured at the point of parsing or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithPatternText(System.String)">
            <summary>
            Creates a pattern for the same original localization information as this pattern, but with the specified
            pattern text.
            </summary>
            <param name="newPatternText">The pattern text to use in the new pattern.</param>
            <returns>A new pattern with the given pattern text.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="newFormatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithResolver(NodaTime.TimeZones.ZoneLocalMappingResolver)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            resolver.
            </summary>
            <param name="newResolver">The new local mapping resolver to use.</param>
            <returns>A new pattern with the given resolver.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            time zone provider.
            </summary>
            <remarks>
            If <paramref name="newZoneProvider"/> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
            <param name="newZoneProvider">The new time zone provider to use.</param>
            <returns>A new pattern with the given time zone provider.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithTemplateValue(NodaTime.ZonedDateTime)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalDateTimePatternParser">
            <summary>
            Parser for patterns of <see cref="T:NodaTime.LocalDateTime"/> values.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePatternParser.LocalDateTimeParseBucket.CombineBuckets(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket,NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket,System.String)">
            <summary>
            Combines the values in a date bucket with the values in a time bucket.
            </summary>
            <remarks>
            This would normally be the <see cref="M:NodaTime.Text.LocalDateTimePatternParser.LocalDateTimeParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)"/> method, but we want
            to be able to use the same logic when parsing an <see cref="T:NodaTime.OffsetDateTime"/>
            and <see cref="T:NodaTime.ZonedDateTime"/>.
            </remarks>
        </member>
        <member name="T:NodaTime.Text.FixedFormatInfoPatternParser`1">
            <summary>
            A pattern parser for a single format info, which caches patterns by text/style.
            </summary>
        </member>
        <member name="T:NodaTime.Text.FormatHelper">
            <summary>
              Provides helper methods for formatting values using pattern strings.
            </summary>
        </member>
        <member name="F:NodaTime.Text.FormatHelper.MaximumPaddingLength">
            <summary>
            The maximum number of characters allowed for padded values.
            </summary>
        </member>
        <member name="F:NodaTime.Text.FormatHelper.MaximumInt64Length">
            <summary>
            Maximum number of digits in a (positive) long.
            </summary>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.LeftPad(System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value left padded with zeros.
            </summary>
            <remarks>
            Left pads with zeros the value into a field of <paramref name = "length" /> characters. If the value
            is longer than <paramref name = "length" />, the entire value is formatted. If the value is negative,
            it is preceded by "-" but this does not count against the length.
            </remarks>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
            <exception cref="T:System.FormatException">if too many characters are requested. <see cref="F:NodaTime.Text.FormatHelper.MaximumPaddingLength" />.</exception>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.AppendFraction(System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value, which is an integer representation of a fraction.
            Note: current usage means this never has to cope with negative numbers.
            </summary>
            <example>
            <code>AppendFraction(1200, 4, 5, builder)</code> will result in "0120" being
            appended to the builder. The value is treated as effectively 0.01200 because
            the scale is 5, but only 4 digits are formatted.
            </example>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill. Must be at most <paramref name="scale"/>.</param>
            <param name="scale">The scale of the value i.e. the number of significant digits is the range of the value. Must be in the range [1, 7].</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.AppendFractionTruncate(System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value, which is an integer representation of a fraction,
            truncating any right-most zero digits.
            If the entire value is truncated then the preceeding decimal separater is also removed.
            Note: current usage means this never has to cope with negative numbers.
            </summary>
            <example>
            <code>AppendFractionTruncate(1200, 4, 5, builder)</code> will result in "001" being
            appended to the builder. The value is treated as effectively 0.01200 because
            the scale is 5; only 4 digits are formatted (leaving "0120") and then the rightmost
            0 digit is truncated.
            </example>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill. Must be at most <paramref name="scale"/>.</param>
            <param name="scale">The scale of the value i.e. the number of significant digits is the range of the value. Must be in the range [1, 7].</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.FormatInvariant(System.Int64,System.Text.StringBuilder)">
            <summary>
            Formats the given value using the invariant culture, with no truncation or padding.
            </summary>
            <param name="value">The value to format.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="T:NodaTime.Text.InstantPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Instant"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="F:NodaTime.Text.InstantPattern.DefaultMinLabel">
            <summary>
            Default label for <see cref="F:NodaTime.Instant.MinValue"/> when formatting.
            </summary>
        </member>
        <member name="F:NodaTime.Text.InstantPattern.DefaultMaxLabel">
            <summary>
            Default label for <see cref="F:NodaTime.Instant.MaxValue"/> when formatting.
            </summary>
        </member>
        <member name="F:NodaTime.Text.InstantPattern.OutOfRangeLabel">
            <summary>
            Label at the start of any out-of-range value.
            </summary>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.GeneralPattern">
            <summary>
            Returns the general pattern, which always uses an invariant culture. The general pattern represents
            an instant as a UTC date/time in ISO-8601 style "yyyy-MM-ddTHH:mm:ss'Z'".
            </summary>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.ExtendedIsoPattern">
            <summary>
            Returns an invariant instant pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy. (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF'Z'".
            </summary>
        </member>
        <member name="T:NodaTime.Text.InstantPattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.PatternText">
            <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.Format(NodaTime.Instant)">
            <summary>
            Formats the given instant as text according to the rules of this pattern.
            </summary>
            <param name="value">The instant to format.</param>
            <returns>The instant formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the given pattern text and format info. The default
            min/max labels are used.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <returns>A pattern for parsing and formatting instants.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting instants.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting instants.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture, using the default
            min/max labels.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting instants.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.CreateNumericPattern(System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Creates a "numeric" pattern for the given culture. The numeric format gives the
            number of ticks in decimal format, with or without thousands separators.
            </summary>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="includeThousandsSeparators">True to include thousands separators when parsing or formatting; false to omit them.</param>
            <returns>A numeric pattern for the configuration</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.WithMinMaxLabels(System.String,System.String)">
            <summary>
            Creates a new pattern for the same original pattern text and culture as this pattern, but
            with the given min/max labels.
            </summary>
            <param name="minLabel">Text to use for <see cref="F:NodaTime.Instant.MinValue"/>. Must be non-empty, and not the same as <paramref name="maxLabel"/>.</param>
            <param name="maxLabel">Text to use for <see cref="F:NodaTime.Instant.MaxValue"/>. Must be non-empty, and not the same as <paramref name="minLabel"/></param>
            <returns>A new pattern with the given min/max labels.</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:NodaTime.Text.InstantPatternParser">
            <summary>
            Pattern parsing support for <see cref="T:NodaTime.Instant" />.
            </summary>
            <remarks>
            Supported patterns:
            <list type="bullet">
              <item><description>g: general; the UTC ISO-8601 instant in the style yyyy-MM-ddTHH:mm:ssZ</description></item>
              <item><description>n: numeric; the number of ticks since the epoch using thousands separators</description></item>
              <item><description>d: numeric; the number of ticks since the epoch without thousands separators</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:NodaTime.Text.InvalidPatternException">
            <summary>
            Exception thrown to indicate that the format pattern provided for either formatting or parsing is invalid.
            </summary>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.Text.InvalidPatternException.#ctor">
            <summary>
            Creates a new InvalidPatternException with no message.
            </summary>
        </member>
        <member name="M:NodaTime.Text.InvalidPatternException.#ctor(System.String)">
            <summary>
            Creates a new InvalidPatternException with the given message.
            </summary>
            <param name="message">A message describing the nature of the failure</param>
        </member>
        <member name="M:NodaTime.Text.InvalidPatternException.#ctor(System.String,System.Object[])">
            <summary>
            Creates a new InvalidPatternException by formatting the given format string with
            the specified parameters, in the current culture.
            </summary>
            <param name="formatString">Format string to use in order to create the final message</param>
            <param name="parameters">Format string parameters</param>
        </member>
        <member name="M:NodaTime.Text.InvalidPatternException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new InvalidPatternException from the given serialization information.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:NodaTime.Text.IPattern`1">
            <summary>
            Generic interface supporting parsing and formatting. Parsing always results in a 
            <see cref="T:NodaTime.Text.ParseResult`1"/> which can represent success or failure.
            </summary>
            <remarks>
            Idiomatic text handling in Noda Time involves creating a pattern once and reusing it multiple
            times, rather than specifying the pattern text repeatedly. All patterns are immutable and thread-safe,
            and include the culture used for localization purposes.
            </remarks>
            <typeparam name="T">Type of value to parse or format.</typeparam>
        </member>
        <member name="M:NodaTime.Text.IPattern`1.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.IPattern`1.Format(`0)">
            <summary>
            Formats the given value as text according to the rules of this pattern.
            </summary>
            <param name="value">The value to format.</param>
            <returns>The value formatted according to this pattern.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalDatePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalDate"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.IsoPattern">
            <summary>
            Returns an invariant local date pattern which is ISO-8601 compatible.
            This corresponds to the text pattern "yyyy'-'MM'-'dd".
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalDatePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.PatternText">
            <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.TemplateValue">
            <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Format(NodaTime.LocalDate)">
            <summary>
            Formats the given local date as text according to the rules of this pattern.
            </summary>
            <param name="value">The local date to format.</param>
            <returns>The local date formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalDate)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDate)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture, with a template value of 2000-01-01.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="newFormatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.WithTemplateValue(NodaTime.LocalDate)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalDateTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalDateTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern">
            <summary>
            Returns an invariant local date/time pattern which is ISO-8601 compatible, down to the second.
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss", and is also used as the "sortable"
            standard pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern">
            <summary>
            Returns an invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy. (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF".
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern">
            <summary>
            Returns an invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy which are always present (including trailing zeroes). This is compatible with the
            BCL round-trip formatting of <see cref="T:System.DateTime"/> values with a kind of "unspecified".
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffff".
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern">
            <summary>
            Returns an invariant local date/time pattern which round trips values including the calendar system.
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffff '('c')'".
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalDateTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.PatternText">
            <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.TemplateValue">
            <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Format(NodaTime.LocalDateTime)">
            <summary>
            Formats the given local date/time as text according to the rules of this pattern.
            </summary>
            <param name="value">The local date/time to format.</param>
            <returns>The local date/time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalDateTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDateTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture, with a template value of midnight on 2000-01-01.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="newFormatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.WithTemplateValue(NodaTime.LocalDateTime)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalDatePatternParser">
            <summary>
            Parser for patterns of <see cref="T:NodaTime.LocalDate"/> values.
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalDatePatternParser.TwoDigitYearMax">
            <summary>
            Maximum two-digit-year in the template to treat as the current century.
            (One day we may want to make this configurable, but it feels very low
            priority.)
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket">
            <summary>
            Bucket to put parsed values in, ready for later result calculation. This type is also used
            by LocalDateTimePattern to store and calculate values.
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.ExtendedIsoPattern">
            <summary>
            Returns an invariant local time pattern which is ISO-8601 compatible, providing up to 7 decimal places.
            (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "HH':'mm':'ss;FFFFFFF".
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.PatternText">
            <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.TemplateValue">
            <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Format(NodaTime.LocalTime)">
            <summary>
            Formats the given local time as text according to the rules of this pattern.
            </summary>
            <param name="value">The local time to format.</param>
            <returns>The local time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture, with a template value of midnight.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="newFormatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.WithTemplateValue(NodaTime.LocalTime)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalTimePatternParser">
            <summary>
            Pattern parser for <see cref="T:NodaTime.LocalTime"/> values.
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket">
            <summary>
            Bucket to put parsed values in, ready for later result calculation. This type is also used
            by LocalDateTimePattern to store and calculate values.
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.FractionalSeconds">
            <summary>
            The fractions of a second in ticks, in the range [0, 9999999]
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.Hours24">
            <summary>
            The hours in the range [0, 23].
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.Hours12">
            <summary>
            The hours in the range [1, 12].
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.Minutes">
            <summary>
            The minutes in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.Seconds">
            <summary>
            The seconds in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.AmPm">
            <summary>
            AM (0) or PM (1) - or "take from the template" (2). The latter is used in situations
            where we're parsing but there is no AM or PM designator.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
            <summary>
            Calculates the value from the parsed pieces.
            </summary>            
        </member>
        <member name="T:NodaTime.Text.NamespaceDoc">
            <summary>
            <para>
            The NodaTime.Text namespace contains types related to formatting and parsing date and time
            values to and from text. Each core Noda Time type has its own "pattern" class to create a more
            object-oriented (and efficient) approach to text handling than the one taken to the BCL.
            See the user guide for more information.
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.Text.OffsetPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Offset"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="F:NodaTime.Text.OffsetPattern.GeneralInvariantPattern">
            <summary>
            The "general" offset pattern (e.g. +HH, +HH:mm, +HH:mm:ss, +HH:mm:ss.fff) for the invariant culture.
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPattern.GeneralInvariantPatternWithZ">
            <summary>
            The "general" offset pattern (e.g. +HH, +HH:mm, +HH:mm:ss, +HH:mm:ss.fff) for the invariant culture,
            but producing (and allowing) Z as a value for a zero offset.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetPattern.PatternText">
            <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetPattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetPattern.UnderlyingPattern">
            <summary>
            Returns the pattern that this object delegates to. Mostly useful to avoid this public class
            implementing an internal interface.
            </summary>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.Format(NodaTime.Offset)">
            <summary>
            Formats the given offset as text according to the rules of this pattern.
            </summary>
            <param name="value">The offset to format.</param>
            <returns>The offset formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the given pattern text and format info.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">Localization information</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="T:NodaTime.Text.OffsetPatternParser.ZPrefixPattern">
            <summary>
            Pattern which optionally delegates to another, but both parses and formats Offset.Zero as "Z".
            </summary>
        </member>
        <member name="T:NodaTime.Text.OffsetPatternParser.OffsetParseBucket">
            <summary>
            Provides a container for the interim parsed pieces of an <see cref="T:NodaTime.Offset" /> value.
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.Hours">
            <summary>
            The hours in the range [0, 23].
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.Minutes">
            <summary>
            The minutes in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.Seconds">
            <summary>
            The seconds in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.Milliseconds">
            <summary>
            The milliseconds in the range [0, 999].
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.IsNegative">
            <summary>
            Gets a value indicating whether this instance is negative.
            </summary>
            <value>
            <c>true</c> if this instance is negative; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
            <summary>
            Calculates the value from the parsed pieces.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.AbstractPattern`1">
            <summary>
            Abstract class to provide common facilities
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.AbstractPattern`1.Parse(System.String)">
            <summary>
            Performs the first part of the parse, validating the value is non-empty before
            handing over to ParseImpl for the meat of the work.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.AbstractPattern`1.ParseImpl(System.String)">
            <summary>
            Overridden by derived classes to parse the given value, which is guaranteed to be 
            non-null and non-empty. It will have been trimmed appropriately if the parse style allows leading or trailing whitespace.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.DatePatternHelper">
            <summary>
            Common methods used when parsing dates - these are used from both LocalDateTimePatternParser
            and LocalDatePatternParser.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateYearHandler``2(System.Func{``0,System.Int32},System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for the year specifier (y).
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CheckIfNextCharacterMightBeDigit(NodaTime.Text.Patterns.PatternCursor)">
            <summary>
            Returns true if the next character in the pattern might represent a digit from another value (e.g. a different
            field). Returns false otherwise, e.g. if we've reached the end of the pattern, or the next character is a literal
            non-digit. 
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateMonthOfYearHandler``2(System.Func{``0,System.Int32},System.Action{``1,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for the month-of-year specifier (M).
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateDayHandler``2(System.Func{``0,System.Int32},System.Func{``0,System.Int32},System.Action{``1,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for the day specifier (d).
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateEraHandler``2(System.Func{``0,NodaTime.Calendars.Era},System.Func{``1,NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket})">
            <summary>
            Creates a character handler for the era specifier (g).
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateCalendarHandler``2(System.Func{``0,NodaTime.CalendarSystem},System.Action{``1,NodaTime.CalendarSystem})">
            <summary>
            Creates a character handler for the calendar specifier (c).
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.IPatternParser`1">
            <summary>
            Internal interface used by FixedFormatInfoPatternParser. Unfortunately
            even though this is internal, implementations must either use public methods
            or explicit interface implementation.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.PatternCursor">
            <summary>
            Extends <see cref="T:NodaTime.Text.TextCursor"/> to simplify parsing patterns such as "yyyy-MM-dd".
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.PatternCursor.GetQuotedString(System.Char)">
            <summary>
            Gets the quoted string.
            </summary>
            <remarks>The cursor is left positioned at the end of the quoted region.</remarks>
            <param name="closeQuote">The close quote character to match for the end of the quoted string.</param>
            <returns>The quoted string sans open and close quotes. This can be an empty string but will not be null.</returns>
        </member>
        <member name="M:NodaTime.Text.Patterns.PatternCursor.GetRepeatCount(System.Int32)">
            <summary>
            Gets the pattern repeat count. The cursor is left on the final character of the
            repeated sequence.
            </summary>
            <param name="maximumCount">The maximum number of repetitions allowed.</param>
            <returns>The repetition count which is alway at least <c>1</c>.</returns>
        </member>
        <member name="M:NodaTime.Text.Patterns.PatternCursor.GetEmbeddedPattern(System.Char,System.Char)">
            <summary>
            Returns a string containing the embedded pattern within this one.
            </summary>
            <remarks>
            <para>
            The cursor is expected to be positioned before the <paramref name="startPattern"/> character,
            and onsuccess the cursor will be positioned on the <paramref name="endPattern"/> character.
            </para>
            <para>Quote characters (' and ") and escaped characters (escaped with a backslash) are handled
            but not unescaped: the resulting pattern should be ready for parsing as normal.</para>
            </remarks>
            <param name="startPattern">The character expected to start the pattern.</param>
            <param name="endPattern">The character expected to end the pattern.</param>
            <returns>The embedded pattern, not including the start/end pattern characters.</returns>
        </member>
        <member name="T:NodaTime.Text.Patterns.PatternFields">
            <summary>
            Enum representing the fields available within patterns. This single enum is shared
            by all parser types for simplicity, although most fields aren't used by most parsers.
            Pattern fields don't necessarily have corresponding duration or date/time fields,
            due to concepts such as "sign".
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.PatternBclSupport`1">
            <summary>
            Class providing simple support for the various Parse/TryParse/ParseExact/TryParseExact/Format overloads 
            provided by individual types.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.TimePatternHelper">
            <summary>
            Common methods used when parsing dates - these are used from LocalDateTimePatternParser,
            OffsetPatternParser and LocalTimePatternParser.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreatePeriodHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for a dot (period). This is *not* culture sensitive - it is
            always treated as a literal, but with the additional behaviour that if it's followed by an 'F' pattern,
            that makes the period optional.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreateCommaDotHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for a dot (period) or comma, which have the same meaning.
            Formatting always uses a dot, but parsing will allow a comma instead, to conform with
            ISO-8601. This is *not* culture sensitive.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreateFractionHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler to handle the "fraction of a second" specifier (f or F).
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.CompositePattern`1">
            <summary>
            Composite pattern which parses by trying several parse patterns in turn, and formats
            by calling a delegate (which may have come from another <see cref="T:NodaTime.Text.IPattern`1"/> to start with).
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.SteppedPatternBuilder`2">
            <summary>
            Builder for a pattern which implements parsing and formatting as a sequence of steps applied
            in turn.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.SetFormatOnly">
            <summary>
            Sets this pattern to only be capable of formatting; any attempt to parse using the
            built pattern will fail immediately.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.ParseCustomPattern(System.String,System.Collections.Generic.Dictionary{System.Char,NodaTime.Text.CharacterHandler{`0,`1}})">
            <summary>
            Performs common parsing operations: start with a parse action to move the
            value cursor onto the first character, then call a character handler for each
            character in the pattern to build up the steps. If any handler fails,
            that failure is returned - otherwise the return value is null.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.ValidateUsedFields">
            <summary>
            Validates the combination of fields used.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.Build">
            <summary>
            Returns a built pattern. This is mostly to keep the API for the builder separate from that of the pattern,
            and for thread safety (publishing a new object, thus leading to a memory barrier).
            Note that this builder *must not* be used after the result has been built.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddField(NodaTime.Text.Patterns.PatternFields,System.Char)">
            <summary>
            Registers that a pattern field has been used in this pattern, and throws a suitable error
            result if it's already been used.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddLiteral(System.String,System.Func{NodaTime.Text.ValueCursor,NodaTime.Text.ParseResult{`0}})">
            <summary>
            Adds text which must be matched exactly when parsing, and appended directly when formatting.
            This overload uses the same failure result for all text values.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.HandlePercent(NodaTime.Text.Patterns.PatternCursor,NodaTime.Text.Patterns.SteppedPatternBuilder{`0,`1})">
            <summary>
            Handle a leading "%" which acts as a pseudo-escape - it's mostly used to allow format strings such as "%H" to mean
            "use a custom format string consisting of H instead of a standard pattern H".
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.HandlePaddedField(System.Int32,NodaTime.Text.Patterns.PatternFields,System.Int32,System.Int32,System.Func{`0,System.Int32},System.Action{`1,System.Int32})">
            <summary>
            Returns a handler for a zero-padded purely-numeric field specifier, such as "seconds", "minutes", "24-hour", "12-hour" etc.
            </summary>
            <param name="maxCount">Maximum permissable count (usually two)</param>
            <param name="field">Field to remember that we've seen</param>
            <param name="minValue">Minimum valid value for the field (inclusive)</param>
            <param name="maxValue">Maximum value value for the field (inclusive)</param>
            <param name="getter">Delegate to retrieve the field value when formatting</param>
            <param name="setter">Delegate to set the field value into a bucket when parsing</param>
            <returns>The pattern parsing failure, or null on success.</returns>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddLiteral(System.Char,System.Func{NodaTime.Text.ValueCursor,System.Char,NodaTime.Text.ParseResult{`0}})">
            <summary>
            Adds a character which must be matched exactly when parsing, and appended directly when formatting.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddParseLongestTextAction(System.Char,System.Action{`1,System.Int32},System.Globalization.CompareInfo,System.Collections.Generic.IList{System.String})">
            <summary>
            Adds parse actions for a list of strings, such as days of the week or month names.
            The parsing is performed case-insensitively. All candidates are tested, and only the longest
            match is used.
            TODO: Make this much more efficient in terms of capture...
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddParseLongestTextAction(System.Char,System.Action{`1,System.Int32},System.Globalization.CompareInfo,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">
            <summary>
            Adds parse actions for two list of strings, such as non-genitive and genitive month names.
            The parsing is performed case-insensitively. All candidates are tested, and only the longest
            match is used.
            TODO: Make this much more efficient in terms of capture...
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.FindLongestMatch(System.Globalization.CompareInfo,NodaTime.Text.ValueCursor,System.Collections.Generic.IList{System.String},System.Int32@,System.Int32@)">
            <summary>
            Find the longest match from a given set of candidate strings, updating the index/length of the best value
            accordingly.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddRequiredSign(System.Action{`1,System.Boolean},System.Func{`0,System.Boolean})">
            <summary>
            Adds parse and format actions for a mandatory positive/negative sign.
            </summary>
            <param name="signSetter">Action to take when to set the given sign within the bucket</param>
            <param name="nonNegativePredicate">Predicate to detect whether the value being formatted is non-negative</param>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddNegativeOnlySign(System.Action{`1,System.Boolean},System.Func{`0,System.Boolean})">
            <summary>
            Adds parse and format actions for an "negative only" sign.
            </summary>
            <param name="signSetter">Action to take when to set the given sign within the bucket</param>
            <param name="nonNegativePredicate">Predicate to detect whether the value being formatted is non-negative</param>
        </member>
        <member name="T:NodaTime.Text.Patterns.SteppedPatternBuilder`2.IPostPatternParseFormatAction">
            <summary>
            Hack to handle genitive month names - we only know what we need to do *after* we've parsed the whole pattern.
            </summary>
        </member>
        <member name="T:NodaTime.Text.PeriodPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Period"/> values.
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Text.PeriodPattern.RoundtripPattern">
            <summary>
            Pattern which uses the normal ISO format for all the supported ISO
            fields, but extends the time part with "s" for milliseconds and "t" for ticks.
            No normalization is carried out, and a period may contain weeks as well as years, months and days.
            Each element may also be negative, independently of other elements. This pattern round-trips its
            values: a parse/format cycle will produce an identical period, including units.
            </summary>
        </member>
        <member name="F:NodaTime.Text.PeriodPattern.NormalizingIsoPattern">
            <summary>
            A "normalizing" pattern which abides by the ISO-8601 duration format as far as possible.
            Weeks are added to the number of days (after multiplying by 7). Time units are normalized
            (extending into days where necessary), and fractions of seconds are represented within the
            seconds part. Unlike ISO-8601, which pattern allows for negative values within a period.
            </summary>
            <remarks>
            Note that normalizing the period when formatting will cause an <see cref="T:System.OverflowException"/>
            if the period contains more than <see cref="F:System.Int64.MaxValue"/> ticks when the
            combined weeks/days/time portions are considered. Such a period could never
            be useful anyway, however.
            </remarks>
        </member>
        <member name="M:NodaTime.Text.PeriodPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.PeriodPattern.Format(NodaTime.Period)">
            <summary>
            Formats the given period as text according to the rules of this pattern.
            </summary>
            <param name="value">The period to format.</param>
            <returns>The period formatted according to this pattern.</returns>
        </member>
        <member name="T:NodaTime.Text.TextCursor">
            <summary>
            Provides a cursor over text being parsed. None of the methods in this class throw exceptions (unless
            there is a bug in Noda Time, in which case an exception is appropriate) and none of the methods
            have ref parameters indicating failures, unlike subclasses. This class is used as the basis for both
            value and pattern parsing, so can make no judgement about what's wrong (i.e. it wouldn't know what
            type of failure to indicate). Instead, methods return Boolean values to indicate success or failure.
            </summary>
        </member>
        <member name="F:NodaTime.Text.TextCursor.Nul">
            <summary>
            A nul character. This character is not allowed in any parsable string and is used to
            indicate that the current character is not set.
            </summary>
        </member>
        <member name="M:NodaTime.Text.TextCursor.#ctor(System.String)">
            <summary>
            Initializes a new instance to parse the given value.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Current">
            <summary>
            Gets the current character.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.HasMoreCharacters">
            <summary>
            Gets a value indicating whether this instance has more characters.
            </summary>
            <value>
            <c>true</c> if this instance has more characters; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Index">
            <summary>
            Gets the current index into the string being parsed.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Length">
            <summary>
            Gets the length of the string being parsed.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Value">
            <summary>
            Gets the string being parsed.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Remainder">
            <summary>
            Gets the remainder the string that has not been parsed yet.
            </summary>
        </member>
        <member name="M:NodaTime.Text.TextCursor.ToString">
            <summary>
              Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.Text.TextCursor.PeekNext">
            <summary>
            Returns the next character if there is one or <see cref="F:NodaTime.Text.TextCursor.Nul" /> if there isn't.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Text.TextCursor.Move(System.Int32)">
            <summary>
            Moves the specified target index. If the new index is out of range of the valid indicies
            for this string then the index is set to the beginning or the end of the string whichever
            is nearest the requested index.
            </summary>
            <param name="targetIndex">Index of the target.</param>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Text.TextCursor.MoveNext">
            <summary>
            Moves to the next character.
            </summary>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Text.TextCursor.MovePrevious">
            <summary>
            Moves to the previous character.
            </summary>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="T:NodaTime.Text.ParseBucket`1">
            <summary>
            Base class for "buckets" of parse data - as field values are parsed, they are stored in a bucket,
            then the final value is calculated at the end.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseBucket`1.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
            <summary>
            Performs the final conversion from fields to a value. The parse can still fail here, if there
            are incompatible field values.
            </summary>
            <param name="usedFields">Indicates which fields were part of the original text pattern.</param>
            <param name="value">Complete value being parsed</param>
        </member>
        <member name="M:NodaTime.Text.ParseBucket`1.IsFieldUsed(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.Patterns.PatternFields)">
            <summary>
            Convenience method to check whether a particular field has been used. It's here as it'll primarily
            be used by buckets; ideally we'd make it an extension method on PatternFields, or use Unconstrained
            Melody...
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseBucket`1.AreAllFieldsUsed(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.Patterns.PatternFields)">
            <summary>
            Convenience method to check whether a particular field set of fields has been used. This is
            similar to <see cref="M:NodaTime.Text.ParseBucket`1.IsFieldUsed(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.Patterns.PatternFields)"/>, except it's expected to be used with multiple fields,
            and will only return true if all the specified fields are present.
            </summary>
        </member>
        <member name="T:NodaTime.Text.ParseResult`1">
            <summary>
            The result of a parse operation.
            </summary>
            <typeparam name="T">The type which was parsed, such as a <see cref="T:NodaTime.LocalDateTime"/>.</typeparam>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.Text.ParseResult`1.Value">
            <summary>
            Returns the value from the parse operation if it was successful, or throws an exception indicating the parse failure
            otherwise.
            </summary>
            <remarks>
            This method is exactly equivalent to calling the <see cref="M:NodaTime.Text.ParseResult`1.GetValueOrThrow"/> method, but is terser if the code is
            already clear that it will throw if the parse failed.
            </remarks>
            <returns>The result of the parsing operation if it was successful.</returns>
        </member>
        <member name="P:NodaTime.Text.ParseResult`1.Exception">
            <summary>
            Returns an exception indicating the cause of the parse failure.
            </summary>
            <remarks>This property is typically used to wrap parse failures in higher level exceptions.</remarks>
            <returns>The exception indicating the cause of the parse failure.</returns>
            <exception cref="T:System.InvalidOperationException">The parse operation succeeded.</exception>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.GetValueOrThrow">
            <summary>
            Returns the value from the parse operation if it was successful, or throws an exception indicating the parse failure
            otherwise.
            </summary>
            <remarks>
            This method is exactly equivalent to fetching the <see cref="P:NodaTime.Text.ParseResult`1.Value"/> property, but more explicit in terms of throwing
            an exception on failure.
            </remarks>
            <returns>The result of the parsing operation if it was successful.</returns>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.TryGetValue(`0,`0@)">
            <summary>
            Returns the success value, and sets the out parameter to either
            the specified failure value of T or the successful parse result value.
            </summary>
            <param name="failureValue">The "default" value to set in <paramref name="result"/> if parsing failed.</param>
            <param name="result">The parameter to store the parsed value in on success.</param>
            <returns>True if this parse result was successful, or false otherwise.</returns>
        </member>
        <member name="P:NodaTime.Text.ParseResult`1.Success">
            <summary>
            Indicates whether the parse operation was successful.
            </summary>
            <remarks>
            This returns True if and only if fetching the value with the <see cref="P:NodaTime.Text.ParseResult`1.Value"/> property will return with no exception.
            </remarks>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.Convert``1(System.Func{`0,``0})">
            <summary>
            Converts this result to a new target type, either by executing the given projection
            for a success result, or propagating the exception provider for failure.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.ConvertError``1">
            <summary>
            Converts this result to a new target type by propagating the exception provider.
            This parse result must already be an error result.
            </summary>
        </member>
        <member name="F:NodaTime.Text.ParseResult`1.FormatOnlyPattern">
            <summary>
            This isn't really an issue with the value so much as the pattern... but the result is the same.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.InconsistentValues(System.String,System.Char,System.Char)">
            <summary>
            Two fields (e.g. "hour of day" and "hour of half day") were mutually inconsistent.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.InconsistentMonthValues(System.String)">
            <summary>
            The month of year is inconsistent between the text and numeric specifications.
            We can't use InconsistentValues for this as the pattern character is the same in both cases.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.InconsistentDayOfWeekTextValue(System.String)">
            <summary>
            The day of month is inconsistent with the day of week value.
            We can't use InconsistentValues for this as the pattern character is the same in both cases.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.ExpectedEndOfString(NodaTime.Text.ValueCursor)">
            <summary>
            We'd expected to get to the end of the string now, but we haven't.
            </summary>
        </member>
        <member name="T:NodaTime.Text.UnparsableValueException">
            <summary>
            Exception thrown to indicate that the specified value could not be parsed.
            </summary>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.Text.UnparsableValueException.#ctor">
            <summary>
            Creates a new UnparsableValueException with no message.
            </summary>
        </member>
        <member name="M:NodaTime.Text.UnparsableValueException.#ctor(System.String)">
            <summary>
            Creates a new UnparsableValueException with the given message.
            </summary>
            <param name="message">The failure message</param>
        </member>
        <member name="M:NodaTime.Text.UnparsableValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new UnparsableValueException from the given serialization information.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Text.ValueCursor" /> class.
            </summary>
            <param name="value">The string to parse.</param>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.Match(System.Char)">
            <summary>
              Attempts to match the specified character with the current character of the string. If the
              character matches then the index is moved passed the character.
            </summary>
            <param name="character">The character to match.</param>
            <returns><c>true</c> if the character matches.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.Match(System.String)">
            <summary>
            Attempts to match the specified string with the current point in the string. If the
            character matches then the index is moved past the string.
            </summary>
            <param name="match">The string to match.</param>
            <returns><c>true</c> if the string matches.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.MatchCaseInsensitive(System.String,System.Globalization.CompareInfo,System.Boolean)">
            <summary>
            Attempts to match the specified string with the current point in the string in a case-insensitive
            manner, according to the given comparison info. The cursor is optionally updated to the end of the match.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.CompareOrdinal(System.String)">
            <summary>
            Compares the value from the current cursor position with the given match. If the
            given match string is longer than the remaining length, the comparison still goes
            ahead but the result is never 0: if the result of comparing to the end of the
            value returns 0, the result is -1 to indicate that the value is earlier than the given match.
            Conversely, if the remaining value is longer than the match string, the comparison only
            goes as far as the end of the match. So "xabcd" with the cursor at "a" will return 0 when
            matched with "abc".
            </summary>
            <returns>A negative number if the value (from the current cursor position) is lexicographically
            earlier than the given match string; 0 if they are equal (as far as the end of the match) and
            a positive number if the value is lexicographically later than the given match string.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.ParseInt64``1(System.Int64@)">
            <summary>
            Parses digits at the current point in the string as a signed 64-bit integer value.
            Currently this method only supports cultures whose negative sign is "-" (and
            using ASCII digits).
            </summary>
            <param name="result">The result integer value. The value of this is not guaranteed
            to be anything specific if the return value is non-null.</param>
            <returns>null if the digits were parsed, or the appropriate parse failure</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.ParseDigits(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Parses digits at the current point in the string. If the minimum required
            digits are not present then the index is unchanged. If there are more digits than
            the maximum allowed they are ignored.
            </summary>
            <param name="minimumDigits">The minimum allowed digits.</param>
            <param name="maximumDigits">The maximum allowed digits.</param>
            <param name="result">The result integer value. The value of this is not guaranteed
            to be anything specific if the return value is false.</param>
            <returns><c>true</c> if the digits were parsed.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.ParseFraction(System.Int32,System.Int32,System.Int32@,System.Boolean)">
            <summary>
            Parses digits at the current point in the string as a fractional value.
            At least one digit must be present, if allRequired is false there's no requirement for *all*
            the digits to be present.
            </summary>
            <param name="maximumDigits">The maximum allowed digits.</param>
            <param name="scale">The scale of the fractional value.</param>
            <param name="result">The result value scaled by scale. The value of this is not guaranteed
            to be anything specific if the return value is false.</param>
            <param name="allRequired">If true, <paramref name="maximumDigits"/> digits must be present in the
            input sequence. If false, there must be just at least one digit.</param>
            <returns><c>true</c> if the digits were parsed.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.GetDigit">
            <summary>
            Gets the integer value of the current digit character, or -1 for "not a digit".
            </summary>
            <remarks>
            This currently only handles ASCII digits, which is all we have to parse to stay in line with the BCL.
            </remarks>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePatternParser.ZonedDateTimeParseBucket.TryParseFixedZone(NodaTime.Text.ValueCursor)">
            <summary>
            Attempts to parse a fixed time zone from "UTC" with an optional
            offset, expressed as +HH, +HH:mm, +HH:mm:ss or +HH:mm:ss.fff - i.e. the
            general format. If it manages, it will move the cursor and return the
            zone. Otherwise, it will return null and the cursor will remain where
            it was.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePatternParser.ZonedDateTimeParseBucket.TryParseProviderZone(NodaTime.Text.ValueCursor)">
            <summary>
            Tries to parse a time zone ID from the provider. Returns the zone
            on success (after moving the cursor to the end of the ID) or null on failure
            (leaving the cursor where it was).
            </summary>
        </member>
        <member name="T:NodaTime.IClock">
            <summary>
            Represents a clock which can return the current time as an <see cref="T:NodaTime.Instant" />.
            </summary>
            <remarks>
            <see cref="T:NodaTime.IClock"/> is intended for use anywhere you need to have access to the current time.
            Although it's not strictly incorrect to call <c>SystemClock.Instance.Now</c> directly,
            in the same way as you might call <see cref="P:System.DateTime.UtcNow"/>, it's strongly discouraged
            as a matter of style for production code. We recommend providing an instance of <see cref="T:NodaTime.IClock"/>
            to anything that needs it, which allows you to write tests using the fake clock in the NodaTime.Testing
            assembly (or your own implementation).
            </remarks>
            <seealso cref="T:NodaTime.SystemClock"/>
            <seealso cref="T:NodaTime.Testing.FakeClock"/>
            <threadsafety>All implementations in Noda Time are thread-safe; custom implementations
            should be thread-safe too. See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="P:NodaTime.IClock.Now">
            <summary>
            Gets the current <see cref="T:NodaTime.Instant"/> on the time line according to this clock.
            </summary>
        </member>
        <member name="T:NodaTime.IsoDayOfWeek">
            <summary>
            Equates the days of the week with their numerical value according to
            ISO-8601. This corresponds with System.DayOfWeek except for Sunday, which
            is 7 in the ISO numbering and 0 in System.DayOfWeek.
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.None">
            <summary>
            Value indicating no day of the week; this will never be returned
            by any IsoDayOfWeek property, and is not valid as an argument to
            any method.
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Monday">
            <summary>
            Value representing Monday (1).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Tuesday">
            <summary>
            Value representing Tuesday (2).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Wednesday">
            <summary>
            Value representing Wednesday (3).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Thursday">
            <summary>
            Value representing Thursday (4).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Friday">
            <summary>
            Value representing Friday (5).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Saturday">
            <summary>
            Value representing Saturday (6).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Sunday">
            <summary>
            Value representing Sunday (7).
            </summary>
        </member>
        <member name="T:NodaTime.LocalDate">
            <summary>
            LocalDate is an immutable struct representing a date within the calendar,
            with no reference to a particular time zone or time of day.
            </summary>
            <remarks>
            <para>Comparisons of dates can be handled in a way which is either calendar-sensitive or calendar-insensitive.
            Noda Time implements all the operators (and the <see cref="M:NodaTime.LocalDate.Equals(NodaTime.LocalDate)"/> method) such that all operators other than <see cref="M:NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)"/>
            will return false if asked to compare two values in different calendar systems.
            </para>
            <para>
            However, the <see cref="M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)"/> method (implementing <see cref="T:System.IComparable`1"/>) is calendar-insensitive; it compares the two
            dates historically in terms of when they actually occurred, as if they're both converted to some "neutral" calendar system first.
            </para>
            <para>
            It's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,
            it would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly
            consider which calendar system they're working in anyway.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an instance for the given year, month and day in the ISO calendar.
            </summary>
            <param name="year">The year. This is the "absolute year", so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <returns>The resulting date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Constructs an instance for the given year, month and day in the specified calendar.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="calendar">Calendar system in which to create the date.</param>
            <returns>The resulting date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an instance for the given era, year of era, month and day in the ISO calendar.
            </summary>
            <param name="era">The era within which to create a date. Must be a valid era within the ISO calendar.</param>
            <param name="yearOfEra">The year of era.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <returns>The resulting date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Constructs an instance for the given era, year of era, month and day in the specified calendar.
            </summary>
            <param name="era">The era within which to create a date. Must be a valid era within the specified calendar.</param>
            <param name="yearOfEra">The year of era.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="calendar">Calendar system in which to create the date.</param>
            <returns>The resulting date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
        </member>
        <member name="P:NodaTime.LocalDate.Calendar">
            <summary>Gets the calendar system associated with this local date.</summary>
        </member>
        <member name="P:NodaTime.LocalDate.Year">
            <summary>Gets the year of this local date.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
        </member>
        <member name="P:NodaTime.LocalDate.Month">
            <summary>Gets the month of this local date within the year.</summary>
        </member>
        <member name="P:NodaTime.LocalDate.Day">
            <summary>Gets the day of this local date within the month.</summary>
        </member>
        <member name="P:NodaTime.LocalDate.IsoDayOfWeek">
            <summary>
            Gets the week day of this local date expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value,
            for calendars which use ISO days of the week.
            </summary>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <seealso cref="P:NodaTime.LocalDate.DayOfWeek"/>
        </member>
        <member name="P:NodaTime.LocalDate.DayOfWeek">
            <summary>
            Gets the week day of this local date as a number.
            </summary>
            <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
            <seealso cref="P:NodaTime.LocalDate.IsoDayOfWeek"/>
        </member>
        <member name="P:NodaTime.LocalDate.WeekYear">
            <summary>
            Gets the "week year" of this local date.
            </summary>
            <remarks>
            <para>
            The WeekYear is the year that matches with the <see cref="P:NodaTime.LocalDate.WeekOfWeekYear"/> field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day.
            </para>
            <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.LocalDate.WeekOfWeekYear">
            <summary>Gets the week within the WeekYear. See <see cref="P:NodaTime.LocalDate.WeekYear"/> for more details.</summary>
        </member>
        <member name="P:NodaTime.LocalDate.YearOfCentury">
            <summary>Gets the year of this local date within the century.</summary>
            <remarks>This always returns a value in the range 0 to 99 inclusive.</remarks>
        </member>
        <member name="P:NodaTime.LocalDate.YearOfEra">
            <summary>Gets the year of this local date within the era.</summary>
        </member>
        <member name="P:NodaTime.LocalDate.Era">
            <summary>Gets the era of this local date.</summary>
        </member>
        <member name="P:NodaTime.LocalDate.DayOfYear">
            <summary>Gets the day of this local date within the year.</summary>
        </member>
        <member name="M:NodaTime.LocalDate.AtMidnight">
            <summary>
            Gets a <see cref="T:NodaTime.LocalDateTime" /> at midnight on the date represented by this local date.
            </summary>
            <returns>The <see cref="T:NodaTime.LocalDateTime" /> representing midnight on this local date, in the same calendar
            system.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.FromWeekYearWeekAndDay(System.Int32,System.Int32,NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the local date corresponding to the given "week year", "week of week year", and "day of week"
            in the ISO calendar system.
            </summary>
            <param name="weekYear">ISO-8601 week year of value to return</param>
            <param name="weekOfWeekYear">ISO-8601 week of week year of value to return</param>
            <param name="dayOfWeek">ISO-8601 day of week to return</param>
            <returns>The date corresponding to the given week year / week of week year / day of week.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Adds the specified period to the date.
            </summary>
            <param name="date">The date to add the period to</param>
            <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
            <returns>The sum of the given date and period</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Add(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Adds the specified period to the date. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="date">The date to add the period to</param>
            <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
            <returns>The sum of the given date and period</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Plus(NodaTime.Period)">
            <summary>
            Adds the specified period to this date. Fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
            <returns>The sum of this date and the given period</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.LocalTime)">
            <summary>
            Combines the given <see cref="T:NodaTime.LocalDate"/> and <see cref="T:NodaTime.LocalTime"/> components
            into a single <see cref="T:NodaTime.LocalDateTime"/>.
            </summary>
            <param name="date">The date to add the time to</param>
            <param name="time">The time to add</param>
            <returns>The sum of the given date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Subtraction(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Subtracts the specified period from the date.
            </summary>
            <param name="date">The date to subtract the period from</param>
            <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
            <returns>The result of subtracting the given period from the date</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Subtract(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Subtracts the specified period from the date. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="date">The date to subtract the period from</param>
            <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
            <returns>The result of subtracting the given period from the date.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Minus(NodaTime.Period)">
            <summary>
            Subtracts the specified period from this date. Fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
            <returns>The result of subtracting the given period from this date.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Equality(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two <see cref="T:NodaTime.LocalDate" /> values for equality. This requires
            that the dates be the same, within the same calendar.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>True if the two dates are the same and in the same calendar; false otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two <see cref="T:NodaTime.LocalDate" /> values for inequality.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>False if the two dates are the same and in the same calendar; true otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_LessThan(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two LocalDate values to see if the left one is strictly earlier than the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_LessThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two LocalDate values to see if the left one is earlier than or equal to the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_GreaterThan(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two LocalDate values to see if the left one is strictly later than the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_GreaterThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two LocalDate values to see if the left one is later than or equal to the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)">
            <summary>
            Indicates whether this date is earlier, later or the same as another one.
            </summary>
            <remarks>
            The comparison is performed in terms of a calendar-independent notion of date;
            the calendar systems of both <see cref="T:NodaTime.LocalDate" /> values are ignored. When both values use the same calendar,
            this is absolutely natural. However, when comparing a value in one calendar with a value in another,
            this can lead to surprising results. For example, 1945 in the ISO calendar corresponds to around 1364
            in the Islamic calendar, so an Islamic date in year 1400 is "after" a date in 1945 in the ISO calendar.
            </remarks>
            <param name="other">The other date to compare this one with</param>
            <returns>A value less than zero if this date is earlier than <paramref name="other"/>;
            zero if this date is the same as <paramref name="other"/>; a value greater than zero if this date is
            later than <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two LocalDates.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.LocalDate"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this LocalDate with another one; see <see cref="M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDate.GetHashCode">
            <summary>
            Returns a hash code for this local date.
            </summary>
            <returns>A hash code for this local date.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:NodaTime.LocalDate"/> values for equality. This requires
            that the dates be the same, within the same calendar.
            </summary>
            <param name="obj">The object to compare this date with.</param>
            <returns>True if the given value is another local date equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Equals(NodaTime.LocalDate)">
            <summary>
            Compares two <see cref="T:NodaTime.LocalDate"/> values for equality. This requires
            that the dates be the same, within the same calendar.
            </summary>
            <param name="other">The value to compare this date with.</param>
            <returns>True if the given value is another local date equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a new LocalDate representing the same physical date, but in a different calendar.
            The returned LocalDate is likely to have different field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
            <param name="calendarSystem">The calendar system to convert this local date to.</param>
            <returns>The converted LocalDate</returns>
        </member>
        <member name="M:NodaTime.LocalDate.PlusYears(System.Int32)">
            <summary>
            Returns a new LocalDate representing the current value with the given number of years added.
            </summary>
            <remarks>
            If the resulting date is invalid, lower fields (typically the day of month) are reduced to find a valid value.
            For example, adding one year to February 29th 2012 will return February 28th 2013; subtracting one year from
            February 29th 2012 will return February 28th 2011.
            </remarks>
            <param name="years">The number of years to add</param>
            <returns>The current value plus the given number of years.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.PlusMonths(System.Int32)">
            <summary>
            Returns a new LocalDate representing the current value with the given number of months added.
            </summary>
            <remarks>
            <para>
            This method does not try to maintain the year of the current value, so adding four months to a value in 
            October will result in a value in the following February.
            </para>
            <para>
            If the resulting date is invalid, the day of month is reduced to find a valid value.
            For example, adding one month to January 30th 2011 will return February 28th 2011; subtracting one month from
            March 30th 2011 will return February 28th 2011.
            </para>
            </remarks>
            <param name="months">The number of months to add</param>
            <returns>The current date plus the given number of months</returns>
        </member>
        <member name="M:NodaTime.LocalDate.PlusDays(System.Int32)">
            <summary>
            Returns a new LocalDate representing the current value with the given number of days added.
            </summary>
            <remarks>
            <para>
            This method does not try to maintain the month or year of the current value, so adding 3 days to a value of January 30th
            will result in a value of February 2nd.
            </para>
            </remarks>
            <param name="days">The number of days to add</param>
            <returns>The current value plus the given number of days.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.PlusWeeks(System.Int32)">
            <summary>
            Returns a new LocalDate representing the current value with the given number of weeks added.
            </summary>
            <param name="weeks">The number of weeks to add</param>
            <returns>The current value plus the given number of weeks.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Next(NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the next <see cref="T:NodaTime.LocalDate" /> falling on the specified <see cref="P:NodaTime.LocalDate.IsoDayOfWeek"/>.
            This is a strict "next" - if this date on already falls on the target
            day of the week, the returned value will be a week later.
            </summary>
            <param name="targetDayOfWeek">The ISO day of the week to return the next date of.</param>
            <returns>The next <see cref="T:NodaTime.LocalDate"/> falling on the specified day of the week.</returns>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetDayOfWeek"/> is not a valid day of the
            week (Monday to Sunday).</exception>
        </member>
        <member name="M:NodaTime.LocalDate.Previous(NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the previous <see cref="T:NodaTime.LocalDate" /> falling on the specified <see cref="P:NodaTime.LocalDate.IsoDayOfWeek"/>.
            This is a strict "previous" - if this date on already falls on the target
            day of the week, the returned value will be a week earlier.
            </summary>
            <param name="targetDayOfWeek">The ISO day of the week to return the previous date of.</param>
            <returns>The previous <see cref="T:NodaTime.LocalDate"/> falling on the specified day of the week.</returns>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetDayOfWeek"/> is not a valid day of the
            week (Monday to Sunday).</exception>
        </member>
        <member name="M:NodaTime.LocalDate.At(NodaTime.LocalTime)">
            <summary>
            Combines this <see cref="T:NodaTime.LocalDate"/> with the given <see cref="T:NodaTime.LocalTime"/>
            into a single <see cref="T:NodaTime.LocalDateTime"/>.
            Fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="time">The time to combine with this date.</param>
            <returns>The <see cref="T:NodaTime.LocalDateTime"/> representation of the given time on this date</returns>
        </member>
        <member name="M:NodaTime.LocalDate.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("D"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDate.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("D").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.LocalDate.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.LocalTime">
            <summary>
            LocalTime is an immutable struct representing a time of day, with no reference
            to a particular calendar, time zone or date.
            </summary>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.LocalTime.Midnight">
            <summary>
            Local time at midnight, i.e. 0 hours, 0 minutes, 0 seconds.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.On(NodaTime.LocalDate)">
            <summary>
            Combines this <see cref="T:NodaTime.LocalTime"/> with the given <see cref="T:NodaTime.LocalDate"/>
            into a single <see cref="P:NodaTime.LocalTime.LocalDateTime"/>.
            Fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="date">The date to combine with this time</param>
            <returns>The <see cref="P:NodaTime.LocalTime.LocalDateTime"/> representation of the given time on this date</returns>
        </member>
        <member name="F:NodaTime.LocalTime.Noon">
            <summary>
            Local time at noon, i.e. 12 hours, 0 minutes, 0 seconds.
            </summary>
        </member>
        <member name="F:NodaTime.LocalTime.ticks">
            <summary>
            Ticks since midnight, in the range [0, 864,000,000,000).
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour and minute, with second, millisecond-of-second
            and tick-of-millisecond values of zero.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour, minute and second,
            with millisecond-of-second and tick-of-millisecond values of zero.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour, minute, second and millisecond,
            with a tick-of-millisecond value of zero.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
            <param name="millisecond">The millisecond of the second.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour, minute, second, millisecond and tick within millisecond.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
            <param name="millisecond">The millisecond of the second.</param>
            <param name="tickWithinMillisecond">The tick within the millisecond.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromHourMinuteSecondTick(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Factory method for creating a local time from the hour of day, minute of hour, second of minute, and tick of second.
            </summary>
            <remarks>
            This is not a constructor overload as it would have the same signature as the one taking millisecond of second.
            </remarks>
            <param name="hour">The hour of day in the desired time, in the range [0, 23].</param>
            <param name="minute">The minute of hour in the desired time, in the range [0, 59].</param>
            <param name="second">The second of minute in the desired time, in the range [0, 59].</param>
            <param name="tickWithinSecond">The tick within the second in the desired time, in the range [0, 9999999].</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromTicksSinceMidnight(System.Int64)">
            <summary>
            Factory method for creating a local time from the number of ticks which have elapsed since midnight.
            </summary>
            <param name="ticks">The number of ticks, in the range [0, 863,999,999,999]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromMillisecondsSinceMidnight(System.Int32)">
            <summary>
            Factory method for creating a local time from the number of milliseconds which have elapsed since midnight.
            </summary>
            <param name="milliseconds">The number of milliseconds, in the range [0, 86,399,999]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromSecondsSinceMidnight(System.Int32)">
            <summary>
            Factory method for creating a local time from the number of seconds which have elapsed since midnight.
            </summary>
            <param name="seconds">The number of seconds, in the range [0, 86,399]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int64)">
            <summary>
            Constructor only called from other parts of Noda Time - trusted to be within January 1st 1970 UTC.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.Hour">
            <summary>
            Gets the hour of day of this local time, in the range 0 to 23 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this local time, in the range 1 to 12 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.Minute">
            <summary>
            Gets the minute of this local time, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.Second">
            <summary>
            Gets the second of this local time within the minute, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.Millisecond">
            <summary>
            Gets the millisecond of this local time within the second, in the range 0 to 999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.TickOfSecond">
            <summary>
            Gets the tick of this local time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.TickOfDay">
            <summary>
            Gets the tick of this local time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.LocalDateTime">
            <summary>
            Returns a <see cref="T:NodaTime.LocalDateTime"/> with this local time, on January 1st 1970 in the ISO
            calendar.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.op_Addition(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            Creates a new local time by adding a period to an existing time. The period must not contain
            any date-related units (days etc) with non-zero values.
            </summary>
            <param name="time">The time to add the period to</param>
            <param name="period">The period to add</param>
            <returns>The result of adding the period to the time, wrapping via midnight if necessary</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Add(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            Adds the specified period to the time. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="time">The time to add the period to</param>
            <param name="period">The period to add. Must not contain any (non-zero) date units.</param>
            <returns>The sum of the given time and period</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Plus(NodaTime.Period)">
            <summary>
            Adds the specified period to this time. Fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="period">The period to add. Must not contain any (non-zero) date units.</param>
            <returns>The sum of this time and the given period</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_Subtraction(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            Creates a new local time by subtracting a period from an existing time. The period must not contain
            any date-related units (days etc) with non-zero values.
            </summary>
            <param name="time">The time to subtract the period from</param>
            <param name="period">The period to subtract</param>
            <returns>The result of subtract the period from the time, wrapping via midnight if necessary</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Subtract(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            Subtracts the specified period from the time. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="time">The time to subtract the period from</param>
            <param name="period">The period to subtract. Must not contain any (non-zero) date units.</param>
            <returns>The result of subtracting the given period from the time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Minus(NodaTime.Period)">
            <summary>
            Subtracts the specified period from this time. Fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="period">The period to subtract. Must not contain any (non-zero) date units.</param>
            <returns>The result of subtracting the given period from this time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_Equality(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two local times for equality, by checking whether they represent
            the exact same local time, down to the tick.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>True if the two times are the same; false otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_Inequality(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two local times for inequality.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>False if the two times are the same; true otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_LessThan(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two LocalTime values to see if the left one is strictly earlier than the right
            one.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_LessThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two LocalTime values to see if the left one is earlier than or equal to the right
            one.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_GreaterThan(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two LocalTime values to see if the left one is strictly later than the right
            one.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_GreaterThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two LocalTime values to see if the left one is later than or equal to the right
            one.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)">
            <summary>
            Indicates whether this time is earlier, later or the same as another one.
            </summary>
            <param name="other">The other date/time to compare this one with</param>
            <returns>A value less than zero if this time is earlier than <paramref name="other"/>;
            zero if this time is the same as <paramref name="other"/>; a value greater than zero if this time is
            later than <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two LocalTimes.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.LocalTime"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this LocalTime with another one; see <see cref="M:NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.LocalTime.GetHashCode">
            <summary>
            Returns a hash code for this local time.
            </summary>
            <returns>A hash code for this local time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Equals(NodaTime.LocalTime)">
            <summary>
            Compares this local time with the specified one for equality,
            by checking whether the two values represent the exact same local time, down to the tick.
            </summary>
            <param name="other">The other local time to compare this one with</param>
            <returns>True if the specified time is equal to this one; false otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Equals(System.Object)">
            <summary>
            Compares this local time with the specified reference. A local time is
            only equal to another local time with the same underlying tick value.
            </summary>
            <param name="obj">The object to compare this one with</param>
            <returns>True if the specified value is a local time is equal to this one; false otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusHours(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of hours added.
            </summary>
            <remarks>
            If the value goes past the start or end of the day, it wraps - so 11pm plus two hours is 1am, for example.
            </remarks>
            <param name="hours">The number of hours to add</param>
            <returns>The current value plus the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusMinutes(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of minutes added.
            </summary>
            <remarks>
            If the value goes past the start or end of the day, it wraps - so 11pm plus 120 minutes is 1am, for example.
            </remarks>
            <param name="minutes">The number of minutes to add</param>
            <returns>The current value plus the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusSeconds(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of seconds added.
            </summary>
            <remarks>
            If the value goes past the start or end of the day, it wraps - so 11:59pm plus 120 seconds is 12:01am, for example.
            </remarks>
            <param name="seconds">The number of seconds to add</param>
            <returns>The current value plus the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusMilliseconds(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of milliseconds added.
            </summary>
            <param name="milliseconds">The number of milliseconds to add</param>
            <returns>The current value plus the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusTicks(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of ticks added.
            </summary>
            <param name="ticks">The number of ticks to add</param>
            <returns>The current value plus the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("T"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.LocalTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("T").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.LocalTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.NamespaceDoc">
            <summary>
            <para>
            The NodaTime namespace contains the core types for Noda Time, including the main public classes for time zone and calendar
            support which have implementations (and less frequently used types) in other namespaces. For formatting and parsing functionality, see the
            <see cref="N:NodaTime.Text" /> namespace.
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.Offset">
            <summary>
            An offset from UTC in milliseconds. A positive value means that the local time is
            ahead of UTC (e.g. for Europe); a negative value means that the local time is behind
            UTC (e.g. for America).
            </summary>
            <remarks>
            Offsets are always strictly less than 24 hours (as either a positive or negative offset).
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Offset.Zero">
            <summary>
            An offset of zero ticks - effectively the permanent offset for UTC.
            </summary>
        </member>
        <member name="F:NodaTime.Offset.MinValue">
            <summary>
            The minimum permitted offset; one millisecond less than a standard day before UTC.
            </summary>
        </member>
        <member name="F:NodaTime.Offset.MaxValue">
            <summary>
            The maximum permitted offset; one millisecond less than a standard day after UTC.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Offset" /> struct.
            </summary>
            <remarks>
            Offsets are constrained to the range (-24 hours, 24 hours).
            </remarks>
            <param name="milliseconds">The number of milliseconds in the offset.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="P:NodaTime.Offset.Milliseconds">
            <summary>
            Gets the total number of milliseconds in the offset, which may be negative.
            </summary>
        </member>
        <member name="P:NodaTime.Offset.Ticks">
            <summary>
            Returns the number of ticks represented by this offset, which may be negative.
            </summary>
            <remarks>
            Offsets are only accurate to millisecond precision; the number of milliseconds is simply multiplied
            by 10,000 to give the number of ticks.
            </remarks>
            <value>The number of ticks.</value>
        </member>
        <member name="M:NodaTime.Offset.Max(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the greater offset of the given two, i.e. the one which will give a later local
            time when added to an instant.
            </summary>
            <param name="x">The first offset</param>
            <param name="y">The second offset</param>
            <returns>The greater offset of <paramref name="x"/> and <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Offset.Min(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the lower offset of the given two, i.e. the one which will give an earlier local
            time when added to an instant.
            </summary>
            <param name="x">The first offset</param>
            <param name="y">The second offset</param>
            <returns>The lower offset of <paramref name="x"/> and <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_UnaryNegation(NodaTime.Offset)">
            <summary>
              Implements the unary operator - (negation).
            </summary>
            <param name="offset">The offset to negate.</param>
            <returns>A new <see cref="T:NodaTime.Offset" /> instance with a negated value.</returns>
        </member>
        <member name="M:NodaTime.Offset.Negate(NodaTime.Offset)">
            <summary>
            Returns the negation of the specified offset. This is the method form of the unary minus operator.
            </summary>
            <param name="offset">The offset to negate.</param>
            <returns>The negation of the specified offset.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_UnaryPlus(NodaTime.Offset)">
            <summary>
            Implements the unary operator + .
            </summary>
            <param name="offset">The operand.</param>
            <remarks>There is no method form of this operator; the <see cref="M:NodaTime.Offset.Plus(NodaTime.Offset)"/> method is an instance
            method for addition, and is more useful than a method form of this would be.</remarks>
            <returns>The same <see cref="T:NodaTime.Offset" /> instance</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Addition(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator + (addition).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>A new <see cref="T:NodaTime.Offset" /> representing the sum of the given values.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.Add(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Adds one Offset to another. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>A new <see cref="T:NodaTime.Offset" /> representing the sum of the given values.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.Plus(NodaTime.Offset)">
            <summary>
            Returns the result of adding another Offset to this one, for a fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="other">The offset to add</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>The result of adding the other offset to this one.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Subtraction(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator - (subtraction).
            </summary>
            <param name="minuend">The left hand side of the operator.</param>
            <param name="subtrahend">The right hand side of the operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>A new <see cref="T:NodaTime.Offset" /> representing the difference of the given values.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.Subtract(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Subtracts one Offset from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="minuend">The left hand side of the operator.</param>
            <param name="subtrahend">The right hand side of the operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>A new <see cref="T:NodaTime.Offset" /> representing the difference of the given values.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.Minus(NodaTime.Offset)">
            <summary>
            Returns the result of subtracting another Offset from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="other">The offset to subtract</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>The result of subtracting the other offset from this one.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Equality(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Inequality(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_LessThan(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_LessThanOrEqual(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_GreaterThan(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_GreaterThanOrEqual(NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.CompareTo(NodaTime.Offset)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              A 32-bit signed integer that indicates the relative order of the objects being compared.
              The return value has the following meanings:
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>&lt; 0</term>
                  <description>This object is less than the <paramref name = "other" /> parameter.</description>
                </item>
                <item>
                  <term>0</term>
                  <description>This object is equal to <paramref name = "other" />.</description>
                </item>
                <item>
                  <term>&gt; 0</term>
                  <description>This object is greater than <paramref name = "other" />.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="M:NodaTime.Offset.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two offsets.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.Offset"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this instant with another one; see <see cref="M:NodaTime.Offset.CompareTo(NodaTime.Offset)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.Equals(NodaTime.Offset)">
            <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              true if the current object is equal to the <paramref name = "other" /> parameter;
              otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
              otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            <returns>
              A hash code for this instance, suitable for use in hashing algorithms and data
              structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Offset.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("g"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("g").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Offset.FromMilliseconds(System.Int32)">
            <summary>
            Returns the offset for the given milliseconds value, which may be negative.
            </summary>
            <param name="milliseconds">The int milliseconds value.</param>
            <returns>The <see cref="T:NodaTime.Offset" /> for the given milliseconds value</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.FromTicks(System.Int64)">
            <summary>
            Creates a new offset from the given number of ticks, which may be negative.
            </summary>
            <remarks>
            Offsets are only accurate to millisecond precision; the given number of ticks is simply divided
            by 10,000 to give the number of milliseconds - any remainder is truncated.
            </remarks>
            <param name="ticks">The number of ticks specifying the length of the new offset.</param>
            <returns>An offset representing the given number of ticks, to the (truncated) millisecond.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.FromHours(System.Int32)">
            <summary>
            Creates an offset with the specified number of hours, which may be negative.
            </summary>
            <param name="hours">The number of hours to represent in the new offset.</param>
            <returns>
            A new <see cref="T:NodaTime.Offset" /> representing the given value.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.FromHoursAndMinutes(System.Int32,System.Int32)">
            <summary>
            Creates an offset with the specified number of hours and minutes.
            </summary>
            <remarks>
            The result simply takes the hours and minutes and converts each component into milliseconds
            separately. As a result, a negative offset should usually be obtained by making both arguments
            negative. For example, to obtain "three hours and ten minutes behind UTC" you might call
            <c>Offset.FromHoursAndMinutes(-3, -10)</c>.
            </remarks>
            <param name="hours">The number of hours to represent in the new offset.</param>
            <param name="minutes">The number of minutes to represent in the new offset.</param>
            <returns>
            A new <see cref="T:NodaTime.Offset" /> representing the given value.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.ToTimeSpan">
            <summary>
            Converts this offset to a .NET standard <see cref="T:System.TimeSpan" /> value.
            </summary>
            <returns>An equivalent <see cref="T:System.TimeSpan"/> to this value.</returns>
        </member>
        <member name="M:NodaTime.Offset.FromTimeSpan(System.TimeSpan)">
            <summary>
            Converts the given <see cref="T:System.TimeSpan"/> to an offset, with fractional milliseconds truncated.
            </summary>
            <param name="timeSpan">The timespan to convert</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given time span falls outside the range of +/- 24 hours.</exception>
            <returns>A new offset for the same time as the given time span.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Offset.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.Offset.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.LocalInstant">
            <summary>
            Represents a local date and time without reference to a calendar system,
            as the number of ticks since the Unix epoch which would represent that time
            of the same date in UTC. This needs a better description, and possibly a better name
            at some point...
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalInstant"/> struct.
            </summary>
            <param name="ticks">The number of ticks from the Unix Epoch.</param>
        </member>
        <member name="M:NodaTime.LocalInstant.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Convenience constructor for test purposes.
            </summary>
        </member>
        <member name="P:NodaTime.LocalInstant.Ticks">
            <summary>
            Ticks since the Unix epoch.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this LocalInstant which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Unspecified"/> and represents the same local date and time as this value.
            </summary>
            <remarks>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </remarks>
        </member>
        <member name="M:NodaTime.LocalInstant.FromDateTime(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime" /> of any kind to a LocalDateTime in the ISO calendar. This does not perform
            any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/>
            will still have the same day/hour/minute etc - it won't be converted into the local system time.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Addition(NodaTime.LocalInstant,NodaTime.Duration)">
            <summary>
            Returns an instant after adding the given duration
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.Add(NodaTime.LocalInstant,NodaTime.Duration)">
            <summary>
            Adds a duration to a local instant. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.LocalInstant"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Subtraction(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Returns the difference between two instants as a duration.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.Minus(NodaTime.Offset)">
            <summary>
            Subtracts the given time zone offset from this local instant, to give an <see cref="T:NodaTime.Instant" />.
            </summary>
            <remarks>
            This would normally be implemented as an operator, but as the corresponding "plus" operation
            on Instant cannot be written (as Instant is a public class and LocalInstant is an internal class)
            it makes sense to keep them both as methods for consistency.
            </remarks>
            <param name="offset">The offset between UTC and a time zone for this local instant</param>
            <returns>A new <see cref="T:NodaTime.Instant"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Subtraction(NodaTime.LocalInstant,NodaTime.Duration)">
            <summary>
            Returns an instant after subtracting the given duration
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.Subtract(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Subtracts one local instant from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.Subtract(NodaTime.LocalInstant,NodaTime.Duration)">
            <summary>
            Subtracts a duration from a local instant. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.LocalInstant"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Equality(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Inequality(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_LessThan(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_LessThanOrEqual(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_GreaterThan(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_GreaterThanOrEqual(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.PlusTicks(System.Int64)">
            <summary>
            Convenience method to add the given number of ticks. Useful
            for assembling date and time parts.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.CompareTo(NodaTime.LocalInstant)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term>&lt; 0</term>
            <description>This object is less than the <paramref name="other"/> parameter.</description>
            </item>
            <item>
            <term>0</term>
            <description>This object is equal to <paramref name="other"/>.</description>
            </item>
            <item>
            <term>&gt; 0</term>
            <description>This object is greater than <paramref name="other"/>.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two local instants.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.LocalInstant"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this instant with another one; see <see cref="M:NodaTime.LocalInstant.CompareTo(NodaTime.LocalInstant)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.Equals(NodaTime.LocalInstant)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="T:NodaTime.Period">
            <summary>
            Represents a period of time expressed in human chronological terms: hours, days,
            weeks, months and so on.
            </summary>
            <remarks>
            <para>
            A <see cref="T:NodaTime.Period"/> contains a set of properties such as <see cref="P:NodaTime.Period.Years"/>, <see cref="P:NodaTime.Period.Months"/>, and so on
            that return the number of each unit contained within this period. Note that these properties are not normalized in
            any way by default, and so a <see cref="T:NodaTime.Period"/> may contain values such as "2 hours and 90 minutes". The
            <see cref="M:NodaTime.Period.Normalize"/> method will convert equivalent periods into a standard representation.
            </para>
            <para>
            Periods can contain negative units as well as positive units ("+2 hours, -43 minutes, +10 seconds"), but do not
            differentiate between properties that are zero and those that are absent (i.e. a period created as "10 years"
            and one created as "10 years, zero months" are equal periods; the <see cref="P:NodaTime.Period.Months"/> property returns zero in
            both cases).
            </para>
            <para>
            <see cref="T:NodaTime.Period"/> equality is implemented by comparing each property's values individually.
            </para>
            <para>
            Periods operate on calendar-related types such as
            <see cref="T:NodaTime.LocalDateTime" /> whereas <see cref="T:NodaTime.Duration"/> operates on instants
            on the time line. (Note that although <see cref="T:NodaTime.ZonedDateTime" /> includes both concepts, it only supports
            duration-based arithmetic.)
            </para>
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Period.ValuesArraySize">
            <summary>
            In some cases, periods are represented as <c>long[]</c> arrays containing all possible units (years to
            ticks). This is the size of those arrays.
            </summary>
        </member>
        <member name="F:NodaTime.Period.Zero">
            <summary>
            A period containing only zero-valued properties.
            </summary>
        </member>
        <member name="P:NodaTime.Period.NormalizingEqualityComparer">
            <summary>
            Returns an equality comparer which compares periods by first normalizing them - so 24 hours is deemed equal to 1 day, and so on.
            Note that as per the <see cref="M:NodaTime.Period.Normalize"/> method, years and months are unchanged by normalization - so 12 months does not
            equal 1 year.
            </summary>
        </member>
        <member name="M:NodaTime.Period.#ctor(System.Int64[])">
            <summary>
            Creates a new period from the given array.
            </summary>
            <param name="values">Values for each field</param>
        </member>
        <member name="M:NodaTime.Period.#ctor(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new period from the given values.
            </summary>
        </member>
        <member name="M:NodaTime.Period.#ctor(NodaTime.PeriodUnits,System.Int64)">
            <summary>
            Creates a new period with the given single value.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromYears(System.Int64)">
            <summary>
            Creates a period representing the specified number of years.
            </summary>
            <param name="years">The number of years in the new period</param>
            <returns>A period consisting of the given number of years.</returns>
        </member>
        <member name="M:NodaTime.Period.FromWeeks(System.Int64)">
            <summary>
            Creates a period representing the specified number of weeks.
            </summary>
            <param name="weeks">The number of weeks in the new period</param>
            <returns>A period consisting of the given number of weeks.</returns>
        </member>
        <member name="M:NodaTime.Period.FromMonths(System.Int64)">
            <summary>
            Creates a period representing the specified number of months.
            </summary>
            <param name="months">The number of months in the new period</param>
            <returns>A period consisting of the given number of months.</returns>
        </member>
        <member name="M:NodaTime.Period.FromDays(System.Int64)">
            <summary>
            Creates a period representing the specified number of days.
            </summary>
            <param name="days">The number of days in the new period</param>
            <returns>A period consisting of the given number of days.</returns>
        </member>
        <member name="M:NodaTime.Period.FromHours(System.Int64)">
            <summary>
            Creates a period representing the specified number of hours.
            </summary>
            <param name="hours">The number of hours in the new period</param>
            <returns>A period consisting of the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.Period.FromMinutes(System.Int64)">
            <summary>
            Creates a period representing the specified number of minutes.
            </summary>
            <param name="minutes">The number of minutes in the new period</param>
            <returns>A period consisting of the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.Period.FromSeconds(System.Int64)">
            <summary>
            Creates a period representing the specified number of seconds.
            </summary>
            <param name="seconds">The number of seconds in the new period</param>
            <returns>A period consisting of the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.Period.FromMillseconds(System.Int64)">
            <summary>
            Creates a period representing the specified number of milliseconds.
            </summary>
            <remarks>This method is not available in the PCL version, as it was made obsolete in Noda Time 1.1.</remarks>
            <param name="milliseconds">The number of milliseconds in the new period</param>
            <returns>A period consisting of the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.Period.FromMilliseconds(System.Int64)">
            <summary>
            Creates a period representing the specified number of milliseconds.
            </summary>
            <param name="milliseconds">The number of milliseconds in the new period</param>
            <returns>A period consisting of the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.Period.FromTicks(System.Int64)">
            <summary>
            Creates a period representing the specified number of ticks.
            </summary>
            <param name="ticks">The number of ticks in the new period</param>
            <returns>A period consisting of the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.Period.op_Addition(NodaTime.Period,NodaTime.Period)">
            <summary>
            Adds two periods together, by simply adding the values for each property.
            </summary>
            <param name="left">The first period to add</param>
            <param name="right">The second period to add</param>
            <returns>The sum of the two periods. The units of the result will be the union of those in both
            periods.</returns>
        </member>
        <member name="M:NodaTime.Period.CreateComparer(NodaTime.LocalDateTime)">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IComparer`1"/> for periods, using the given "base" local date/time.
            </summary>
            <remarks>
            Certain periods can't naturally be compared without more context - how "one month" compares to
            "30 days" depends on where you start. In order to compare two periods, the returned comparer
            effectively adds both periods to the "base" specified by <paramref name="baseDateTime"/> and compares
            the results. In some cases this arithmetic isn't actually required - when two periods can be
            converted to durations, the comparer uses that conversion for efficiency.
            </remarks>
            <param name="baseDateTime">The base local date/time to use for comparisons.</param>
            <returns>The new comparer.</returns>
        </member>
        <member name="M:NodaTime.Period.ToArray">
            <summary>
            Returns the property values in this period as an array.
            </summary>
        </member>
        <member name="M:NodaTime.Period.AddValuesTo(System.Int64[])">
            <summary>
            Adds all the values in this period to the given array of values (which is assumed to be of the right
            length).
            </summary>
        </member>
        <member name="M:NodaTime.Period.SubtractValuesFrom(System.Int64[])">
            <summary>
            Subtracts all the values in this period from the given array of values (which is assumed to be of the right
            length).
            </summary>
        </member>
        <member name="M:NodaTime.Period.op_Subtraction(NodaTime.Period,NodaTime.Period)">
            <summary>
            Subtracts one period from another, by simply subtracting each property value.
            </summary>
            <param name="minuend">The period to subtract the second operand from</param>
            <param name="subtrahend">The period to subtract the first operand from</param>
            <returns>The result of subtracting all the values in the second operand from the values in the first. The
            units of the result will be the union of both periods, even if the subtraction caused some properties to
            become zero (so "2 weeks, 1 days" minus "2 weeks" is "zero weeks, 1 days", not "1 days").</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime,NodaTime.PeriodUnits)">
            <summary>
            Returns the period between a start and an end date/time, using only the given units.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 1am and 3:15am in hours) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start date/time</param>
            <param name="end">End date/time</param>
            <param name="units">Units to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="units"/> is empty or contained unknown values.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars.</exception>
            <returns>The period between the given date/times, using the given units.</returns>
        </member>
        <member name="M:NodaTime.Period.AddTo(NodaTime.LocalInstant,NodaTime.CalendarSystem,System.Int32)">
            <summary>
            Adds the contents of this period to the given local instant in the given calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Returns the exact difference between two date/times.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative.
            </remarks>
            <param name="start">Start date/time</param>
            <param name="end">End date/time</param>
            <returns>The period between the two date and time values, using all units.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate,NodaTime.PeriodUnits)">
            <summary>
            Returns the period between a start and an end date, using only the given units.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 12th February and 15th March in months) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start date</param>
            <param name="end">End date</param>
            <param name="units">Units to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="units"/> contains time units, is empty or contains unknown values.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars.</exception>
            <returns>The period between the given dates, using the given units.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Returns the exact difference between two dates.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative.
            </remarks>
            <param name="start">Start date</param>
            <param name="end">End date</param>
            <returns>The period between the two dates, using year, month and day units.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime,NodaTime.PeriodUnits)">
            <summary>
            Returns the period between a start and an end time, using only the given units.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 3am and 4.30am in hours) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start time</param>
            <param name="end">End time</param>
            <param name="units">Units to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="units"/> contains date units, is empty or contains unknown values.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars.</exception>
            <returns>The period between the given times, using the given units.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Returns the exact difference between two times.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative.
            </remarks>
            <param name="start">Start time</param>
            <param name="end">End time</param>
            <returns>The period between the two times, using the time period units.</returns>
        </member>
        <member name="P:NodaTime.Period.HasTimeComponent">
            <summary>
            Returns whether or not this period contains any non-zero-valued time-based properties (hours or lower).
            </summary>
        </member>
        <member name="P:NodaTime.Period.HasDateComponent">
            <summary>
            Returns whether or not this period contains any non-zero date-based properties (days or higher).
            </summary>
        </member>
        <member name="M:NodaTime.Period.ToDuration">
            <summary>
            For periods that do not contain a non-zero number of years or months, returns a duration for this period
            assuming a standard 7-day week, 24-hour day, 60-minute hour etc.
            </summary>
            <exception cref="T:System.InvalidOperationException">The month or year property in the period is non-zero.</exception>
            <exception cref="T:System.OverflowException">The period doesn't have years or months, but the calculation
            overflows the bounds of <see cref="T:NodaTime.Duration"/>. In some cases this may occur even though the theoretical
            result would be valid due to balancing positive and negative values, but for simplicity there is
            no attempt to work around this - in realistic periods, it shouldn't be a problem.</exception>
            <returns>The duration of the period.</returns>
        </member>
        <member name="P:NodaTime.Period.TotalStandardTicks">
            <summary>
            Gets the total number of ticks duration for the 'standard' properties (all bar years and months).
            </summary>
        </member>
        <member name="M:NodaTime.Period.ToBuilder">
            <summary>
            Creates a <see cref="T:NodaTime.PeriodBuilder"/> from this instance. The new builder
            is populated with the values from this period, but is then detached from it:
            changes made to the builder are not reflected in this period.
            </summary>
            <returns>A builder with the same values and units as this period.</returns>
        </member>
        <member name="M:NodaTime.Period.Normalize">
            <summary>
            Returns a normalized version of this period, such that equivalent (but potentially non-equal) periods are
            changed to the same representation.
            </summary>
            <remarks>
            Months and years are unchanged
            (as they can vary in length), but weeks are multiplied by 7 and added to the
            Days property, and all time properties are normalized to their natural range
            (where ticks are "within a millisecond"), adding to the larger property where
            necessary. So for example, a period of 25 hours becomes a period of 1 day
            and 1 hour. Aside from months and years, either all the properties
            end up positive, or they all end up negative.
            </remarks>
            <exception cref="T:System.OverflowException">The period doesn't have years or months, but it contains more than
            <see cref="F:System.Int64.MaxValue"/> ticks when the combined weeks/days/time portions are considered. Such a period
            could never be useful anyway, however.
            In some cases this may occur even though the theoretical result would be valid due to balancing positive and
            negative values, but for simplicity there is no attempt to work around this - in realistic periods, it
            shouldn't be a problem.</exception>
            <returns>The normalized period.</returns>
            <seealso cref="P:NodaTime.Period.NormalizingEqualityComparer"/>
        </member>
        <member name="M:NodaTime.Period.GetSingleField(NodaTime.Fields.PeriodFieldSet,NodaTime.PeriodUnits)">
            <summary>
            Returns the PeriodField for the given unit value, or null if the values does
            not represent a single unit.
            </summary>
        </member>
        <member name="M:NodaTime.Period.GetFieldForIndex(NodaTime.Fields.PeriodFieldSet,System.Int32)">
            <summary>
            Returns the PeriodField for the given index, in the range 0-8 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.Period.Years">
            <summary>
            Gets the number of years within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="P:NodaTime.Period.Months">
            <summary>
            Gets the number of months within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="P:NodaTime.Period.Weeks">
            <summary>
            Gets the number of weeks within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="P:NodaTime.Period.Days">
            <summary>
            Gets the number of days within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="P:NodaTime.Period.Hours">
            <summary>
            Gets the number of hours within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="P:NodaTime.Period.Minutes">
            <summary>
            Gets the number of minutes within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="P:NodaTime.Period.Seconds">
            <summary>
            Gets the number of seconds within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="P:NodaTime.Period.Milliseconds">
            <summary>
            Gets the number of milliseconds within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="P:NodaTime.Period.Ticks">
            <summary>
            Gets the number of ticks within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
        </member>
        <member name="M:NodaTime.Period.ToString">
            <summary>
            Returns this string formatted according to the <see cref="F:NodaTime.Text.PeriodPattern.RoundtripPattern"/>.
            </summary>
            <returns>A formatted representation of this period.</returns>
        </member>
        <member name="M:NodaTime.Period.Equals(System.Object)">
            <summary>
            Compares the given object for equality with this one, as per <see cref="M:NodaTime.Period.Equals(NodaTime.Period)"/>.
            </summary>
            <param name="other">The value to compare this one with.</param>
            <returns>true if the other object is a period equal to this one, consistent with <see cref="M:NodaTime.Period.Equals(NodaTime.Period)"/></returns>
        </member>
        <member name="M:NodaTime.Period.GetHashCode">
            <summary>
            Returns the hash code for this period, consistent with <see cref="M:NodaTime.Period.Equals(NodaTime.Period)"/>.
            </summary>
            <returns>The hash code for this period.</returns>
        </member>
        <member name="M:NodaTime.Period.Equals(NodaTime.Period)">
            <summary>
            Compares the given period for equality with this one.
            </summary>
            <remarks>
            Periods are equal if they contain the same values for the same properties.
            However, no normalization takes place, so "one hour" is not equal to "sixty minutes".
            </remarks>
            <param name="other">The period to compare this one with.</param>
            <returns>True if this period has the same values for the same properties as the one specified.</returns>
        </member>
        <member name="M:NodaTime.Period.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.Period.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.Period.NormalizingPeriodEqualityComparer">
            <summary>
            Equality comparer which simply normalizes periods before comparing them.
            </summary>
        </member>
        <member name="T:NodaTime.SkippedTimeException">
            <summary>
            Exception thrown to indicate that the specified local time doesn't
            exist in a particular time zone due to daylight saving time changes.    
            </summary>
            <remarks>
            <para>
            This normally occurs for spring transitions, where the clock goes forward
            (usually by an hour). For example, suppose the time zone goes forward
            at 2am, so the second after 01:59:59 becomes 03:00:00. In that case,
            local times such as 02:30:00 never occur.
            </para>
            <para>
            This exception is used to indicate such problems, as they're usually
            not the same as other <see cref="T:System.ArgumentOutOfRangeException" /> causes,
            such as entering "15" for a month number.
            </para>
            <para>
            Note that it is possible (though extremely rare) for a whole day to be skipped due to a time zone transition,
            so this exception may also be thrown in cases where no local time is valid for a particular local date. (For
            example, Samoa skipped December 30th 2011 entirely, transitioning from UTC-10 to UTC+14 at midnight.)
            </para>
            </remarks>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="P:NodaTime.SkippedTimeException.LocalDateTime">
            <summary>
            The local date/time which is invalid in the time zone
            </summary>
        </member>
        <member name="P:NodaTime.SkippedTimeException.Zone">
            <summary>
            The time zone in which the local date/time is invalid
            </summary>
        </member>
        <member name="M:NodaTime.SkippedTimeException.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone)">
            <summary>
            Creates a new instance for the given local date/time and time zone.
            </summary>
            <remarks>
            User code is unlikely to need to deliberately call this constructor except
            possibly for testing.
            </remarks>
            <param name="localDateTime">The local date/time which is skipped in the specified time zone.</param>
            <param name="zone">The time zone in which the local date/time does not exist.</param>
        </member>
        <member name="T:NodaTime.SystemClock">
            <summary>
            Singleton implementation of <see cref="T:NodaTime.IClock"/> which reads the current system time.
            It is recommended that for anything other than throwaway code, this is only referenced
            in a single place in your code: where you provide a value to inject into the rest of
            your application, which should only depend on the interface.
            </summary>
            <threadsafety>This type has no state, and is thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.SystemClock.Instance">
            <summary>
            The singleton instance of <see cref="T:NodaTime.SystemClock"/>.
            </summary>
            <value>The singleton instance of <see cref="T:NodaTime.SystemClock"/>.</value>
        </member>
        <member name="M:NodaTime.SystemClock.#ctor">
            <summary>
            Constructor present to prevent external construction.
            </summary>
        </member>
        <member name="P:NodaTime.SystemClock.Now">
            <summary>
            Gets the current time as an <see cref="T:NodaTime.Instant"/>.
            </summary>
            <value>The current time in ticks as an <see cref="T:NodaTime.Instant"/>.</value>
        </member>
        <member name="T:NodaTime.TimeZones.BclDateTimeZone">
            <summary>
            Representation of a time zone converted from a <see cref="T:System.TimeZoneInfo"/> from the Base Class Library.
            </summary>
            <remarks>
            <para>
            Two instances of this class are deemed equal if and only if they refer to the exact same
            <see cref="T:System.TimeZoneInfo"/> object.
            </para>
            <para>
            This implementation does not always give the same results as <c>TimeZoneInfo</c>, in that it doesn't replicate
            the bugs in the BCL interpretation of the data. These bugs are described in
            <a href="http://codeblog.jonskeet.uk/2014/09/30/the-mysteries-of-bcl-time-zone-data/">a blog post</a>, but we're
            not expecting them to be fixed any time soon. Being bug-for-bug compatible would not only be tricky, but would be painful
            if the BCL were ever to be fixed. As far as we are aware, there are only discrepancies around new year where the zone
            changes from observing one rule to observing another.
            </para>
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.TimeZones.BclDateTimeZone.systemDefault">
            <summary>
            This is used to cache the last result of a call to <see cref="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault"/>, but it doesn't
            matter if it's out of date - we'll just create another wrapper if necessary. It's not *that* expensive to make
            a few more wrappers than we need.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.OriginalZone">
            <summary>
            Gets the original <see cref="T:System.TimeZoneInfo"/> from which this was created.
            </summary>
            <value>The original <see cref="T:System.TimeZoneInfo"/> from which this was created.</value>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.DisplayName">
            <summary>
            Gets the display name associated with the time zone, as provided by the Base Class Library.
            </summary>
            <value>The display name associated with the time zone, as provided by the Base Class Library.</value>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo(System.TimeZoneInfo)">
            <summary>
            Creates a new <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> from a <see cref="T:System.TimeZoneInfo"/> from the Base Class Library.
            </summary>
            <param name="bclZone">The original time zone to take information from.</param>
            <returns>A <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> wrapping the given <c>TimeZoneInfo</c>.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule">
            <summary>
            Just a mapping of a TimeZoneInfo.AdjustmentRule into Noda Time types. Very little cleverness here.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.Start">
            <summary>
            Instant on which this rule starts.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.End">
            <summary>
            Instant on which this rule ends.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.Savings">
            <summary>
            Daylight savings, when applicable within this rule.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.StandardOffset">
            <summary>
            The standard offset for the duration of this rule.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.IsStandardOffsetOnlyRule(System.TimeZoneInfo.AdjustmentRule)">
            <summary>
            The BCL represents "standard-only" rules using two fixed date January 1st transitions.
            Currently the time-of-day used for the DST end transition is at one millisecond past midnight... we'll
            be slightly more lenient, accepting anything up to 12:01...
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault">
            <summary>
            Returns a time zone converted from the BCL representation of the system local time zone.
            </summary>
            <remarks>
            <para>
            This method is approximately equivalent to calling <see cref="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault"/> with
            an implementation that wraps <see cref="T:NodaTime.TimeZones.BclDateTimeZoneSource"/> (e.g.
            <see cref="P:NodaTime.DateTimeZoneProviders.Bcl"/>), with the exception that it will succeed even if the current local
            time zone was not one of the set of system time zones captured when the source was created (which, while
            highly unlikely, might occur either because the local time zone is not a system time zone, or because the
            system time zones have themselves changed).
            </para>
            <para>
            This method will retain a reference to the returned <c>BclDateTimeZone</c>, and will attempt to return it if
            called repeatedly (assuming that the local time zone has not changed) rather than creating a new instance,
            though this behaviour is not guaranteed.
            </para>
            </remarks>
            <returns>A <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> wrapping the "local" (system) time zone as returned by
            <see cref="P:System.TimeZoneInfo.Local"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.EqualsImpl(NodaTime.DateTimeZone)">
            <inheritdoc />
            <remarks>
            This implementation simply compares the underlying `TimeZoneInfo` values for
            reference equality.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.BclDateTimeZoneSource">
            <summary>
            Provides an implementation of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> that loads data from the BCL
            <see cref="T:System.TimeZoneInfo"/> class.
            </summary>
            <remarks>
            <para>
            All calls to <see cref="M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)"/> return instances of <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/>, including for fixed-offset IDs
            (i.e. "UTC" and "UTC+/-Offset").
            </para>
            <para>
            This class is not available in the PCL version.
            </para>
            </remarks>
            <threadsafety>This type maintains no state, and all members are thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.GetIds">
            <summary>
            Returns the IDs of all system time zones.
            </summary>
            <returns>The IDs available from this source.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.GetTimeZoneInfoLocalIdOrEmpty">
            <summary>
            Returns an enumerable containing a singleton element of the Id of the local time zone
            (<c>TimeZoneInfo.Local.Id</c>), unless the local time zone is not available, or not a system time zone, in
            which case returns an empty enumerable.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZoneSource.VersionId">
            <inheritdoc />
            <remarks>
            This source returns a string such as "TimeZoneInfo: 3.5.0.0" corresponding to the version of the assembly
            containing <see cref="T:System.TimeZoneInfo"/>.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId(System.String)">
            <summary>
            Creates a new instance of <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> from the <see cref="T:System.TimeZoneInfo"/> with the given
            ID. The ID must be a known system time zone ID.
            </summary>
            <remarks>
            This method explicitly implements <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)"/> by delegating to the
            <see cref="M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)"/> method which has a return type of <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/>, ensuring that all
            zones returned by this implementation are instances of <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> (rather than the built-in
            fixed offset zones).
            </remarks>        
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)">
            <summary>
            Creates a new instance of <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> from the <see cref="T:System.TimeZoneInfo"/> with the given
            ID. The ID must be a known system time zone ID.
            </summary>
            <param name="id">The ID of the system time zone to convert</param>
            <exception cref="T:System.ArgumentException">The given zone doesn't exist.</exception>
            <returns>The Noda Time representation of the given BCL time zone</returns>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)">
            <summary>
            Maps the BCL ID to "our" ID as an identity projection.
            </summary>
            <param name="timeZone">The BCL time zone, which must be a known system time zone.</param>
            <returns>
            The ID for the given BCL time zone for this source; that is, the value of the <c>Id</c> property of the
            passed-in <see cref="T:System.TimeZoneInfo"/>.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.CachedDateTimeZone">
            <summary>
             Provides a <see cref="T:NodaTime.DateTimeZone"/> wrapper class that implements a simple cache to
             speed up the lookup of transitions.
            </summary>
            <remarks>
            <para>
            The cache supports multiple caching strategies which are implemented in nested subclasses of
            this one. Until we have a better sense of what the usage behavior is, we cannot tune the
            cache. It is possible that we may support multiple strategies selectable at runtime so the
            user can tune the performance based on their knowledge of how they are using the system.
            </para>
            <para>
            In fact, only one cache type is currently implemented: an MRU cache existed before
            the GetZoneIntervalPair call was created in DateTimeZone, but as it wasn't being used, it
            was more effort than it was worth to update. The mechanism is still available for future
            expansion though.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.#ctor(NodaTime.DateTimeZone,NodaTime.TimeZones.IZoneIntervalMap)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachedDateTimeZone"/> class.
            </summary>
            <param name="timeZone">The time zone to cache.</param>
            <param name="map">The caching map</param>
        </member>
        <member name="P:NodaTime.TimeZones.CachedDateTimeZone.TimeZone">
            <summary>
            Gets the cached time zone.
            </summary>
            <value>The time zone.</value>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.ForZone(NodaTime.DateTimeZone)">
            <summary>
            Returns a cached time zone for the given time zone.
            </summary>
            <remarks>
            If the time zone is already cached or it is fixed then it is returned unchanged.
            </remarks>
            <param name="timeZone">The time zone to cache.</param>
            <returns>The cached time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Delegates fetching a zone interval to the caching map.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.WriteLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.ReadLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneReader,System.String)">
            <summary>
            Reads the zone from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns></returns>
        </member>
        <member name="T:NodaTime.TimeZones.CachingZoneIntervalMap">
            <summary>
            Helper methods for creating IZoneIntervalMaps which cache results.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.CachingZoneIntervalMap.CacheType">
            <summary>
            The type of cache to build.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.CacheMap(NodaTime.TimeZones.IZoneIntervalMap,NodaTime.TimeZones.CachingZoneIntervalMap.CacheType)">
            <summary>
            Returns a caching map for the given input map.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache">
            <summary>
            This provides a simple cache based on two hash tables (one for local instants, another
            for instants).
            </summary>
            <remarks>
            Each hash table entry is either entry or contains a node with enough
            information for a particular "period" of about 40 days - so multiple calls for time
            zone information within the same few years are likely to hit the cache. Note that
            a single "period" may include a daylight saving change (or conceivably more than one);
            a node therefore has to contain enough intervals to completely represent that period.
            
            If another call is made which maps to the same cache entry number but is for a different
            period, the existing hash entry is simply overridden.
            </remarks>
        </member>
        <member name="F:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.PeriodShift">
            <summary>
            Defines the number of bits to shift an instant value to get the period. This
            converts a number of ticks to a number of 40.6 days periods.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone offset period for the given instant. Null is returned if no period is
            defined by the time zone for the given instant.
            </summary>
            <param name="instant">The Instant to test.</param>
            <returns>The defined ZoneOffsetPeriod or null.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode.CreateNode(System.Int32,NodaTime.TimeZones.IZoneIntervalMap)">
            <summary>
            Creates a hash table node with all the information for this period.
            We start off by finding the interval for the start of the period, and
            then repeatedly check whether that interval ends after the end of the
            period - at which point we're done. If not, find the next interval, create
            a new node referring to that interval and the previous interval, and keep going.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode.#ctor(NodaTime.TimeZones.ZoneInterval,System.Int32,NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode"/> class.
            </summary>
            <param name="interval">The zone interval.</param>
            <param name="period"></param>
            <param name="previous">The previous <see cref="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode"/> node.</param>
        </member>
        <member name="T:NodaTime.TimeZones.Cldr.MapZone">
            <summary>
            Represents a single <c>&lt;mapZone&gt;</c> element in the CLDR Windows zone mapping file. 
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory">
            <summary>
            Identifier used for the primary territory of each Windows time zone. A zone mapping with
            this territory will always have a single entry. The value of this constant is "001".
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.Cldr.MapZone.FixedOffsetTerritory">
            <summary>
            Identifier used for the "fixed offset" territory. A zone mapping with
            this territory will always have a single entry. The value of this constant is "ZZ".
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.MapZone.WindowsId">
            <summary>
            Gets the Windows system time zone identifier for this mapping, such as "Central Standard Time".
            </summary>
            <remarks>
            <para>
            Most Windows system time zone identifiers use the name for the "standard" part of the zone as
            the overall identifier. Don't be fooled: just because a time zone includes "standard" in its identifier
            doesn't mean that it doesn't observe daylight saving time.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.MapZone.Territory">
            <summary>
            Gets the territory code for this mapping.
            </summary>
            <remarks>
            This is typically either "001" to indicate that it's the primary territory for this ID, or
            "ZZ" to indicate a fixed-offset ID, or a different two-character capitalized code
            which indicates the geographical territory.
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.MapZone.TzdbIds">
            <summary>
            Gets a read-only non-empty collection of TZDB zone identifiers for this mapping, such as
            "America/Chicago" and "America/Matamoros" (both of which are TZDB zones associated with the "Central Standard Time"
            Windows system time zone).
            </summary>
            <remarks>
            For the primary and fixed-offset territory IDs ("001" and "ZZ") this always
            contains exactly one time zone ID.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.#ctor(System.String,System.String,System.Collections.Generic.IList{System.String})">
            <summary>
            Creates a new mapping entry.
            </summary>
            <remarks>
            This constructor is only public for the sake of testability.
            </remarks>
            <param name="windowsId">Windows system time zone identifier. Must not be null.</param>
            <param name="territory">Territory code. Must not be null.</param>
            <param name="tzdbIds">List of territory codes. Must not be null, and must not
            contains null values.</param>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.#ctor(System.String,System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
            <summary>
            Private constructor to avoid unnecessary list copying (and validation) when deserializing.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader)">
            <summary>
            Reads a mapping from a reader.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes this mapping to a writer.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:NodaTime.TimeZones.Cldr.NamespaceDoc">
            <summary>
            <para>
            The NodaTime.TimeZones.Cldr namespace contains types related to time zone information provided
            by the Unicode CLDR (Common Locale Data Repository) project.
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.Cldr.WindowsZones">
            <summary>
            Representation of the <c>&lt;windowsZones&gt;</c> element of CLDR supplemental data.
            </summary>
            <remarks>
            See <a href="http://cldr.unicode.org/development/development-process/design-proposals/extended-windows-olson-zid-mapping">the CLDR design proposal</a>
            for more details of the structure of the file from which data is taken.
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.Version">
            <summary>
            Gets the version of the Windows zones mapping data read from the original file.
            </summary>
            <remarks>
            <para>
            As with other IDs, this should largely be treated as an opaque string, but the current method for
            generating this from the mapping file extracts a number from an element such as <c>&lt;version number="$Revision: 7825 $"/&gt;</c>.
            This is a Subversion revision number, but that association should only be used for diagnostic curiosity, and never
            assumed in code.
            </para>
            <para>
            This property will never return a null value.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion">
            <summary>
            Gets the TZDB version this Windows zone mapping data was created from.
            </summary>
            <remarks>
            <para>
            The CLDR mapping file usually lags behind the TZDB file somewhat - partly because the
            mappings themselves don't always change when the time zone data does. For example, it's entirely
            reasonable for a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/> with a <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion">TzdbVersion</see> of
            "2013b" to be supply a <c>WindowsZones</c> object with a <c>TzdbVersion</c> of "2012f".
            </para>
            <para>
            This property will never return a null value, but will be "Unknown" if the data
            is loaded from the legacy resource format.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion">
            <summary>
            Gets the Windows time zone database version this Windows zone mapping data was created from.
            </summary>
            <remarks>
            <para>
            At the time of this writing, this is populated (by CLDR) from the registry key
            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones\TzVersion,
            so "7dc0101" for example.
            </para>
            <para>
            This property will never return a null value, but will be "Unknown" if the data
            is loaded from the legacy resource format.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.MapZones">
            <summary>
            Gets an immutable collection of mappings from Windows system time zones to
            TZDB time zones.
            </summary>
            <remarks>
            <para>
            Each mapping consists of a single Windows time zone ID and a single
            territory to potentially multiple TZDB IDs that are broadly equivalent to that Windows zone/territory
            pair.
            </para>
            <para>
            Mappings for a single Windows system time zone can appear multiple times
            in this list, in different territories. For example, "Central Standard Time"
            maps to different TZDB zones in different countries (the US, Canada, Mexico) and
            even within a single territory there can be multiple zones. Every Windows system time zone covered within
            this collection has a "primary" entry with a territory code of "001" (which is the value of
            <see cref="F:NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory"/>) and a single corresponding TZDB zone. 
            </para>
            <para>This collection is not guaranteed to cover every Windows time zone. Some zones may be unmappable
            (such as "Mid-Atlantic Standard Time") and there can be a delay between a new Windows time zone being introduced
            and it appearing in CLDR, ready to be used by Noda Time. (There's also bound to be a delay between it appearing
            in CLDR and being used in your production system.) In practice however, you're unlikely to wish to use a time zone
            which isn't covered here.</para>
            <para>
            If the data is loaded from the legacy resource format, this will only include the primary mappings.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping">
            <summary>
            Gets an immutable dictionary of primary mappings, from Windows system time zone ID
            to TZDB zone ID. This corresponds to the "001" territory which is present for every zone
            within the mapping file.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneCache">
            <summary>
            Provides an implementation of <see cref="T:NodaTime.IDateTimeZoneProvider"/> that caches results from an
            <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/>.
            </summary>
            <remarks>
            The process of loading or creating time zones may be an expensive operation. This class implements an
            unlimited-size non-expiring cache over a time zone source, and adapts an implementation of the
            <c>IDateTimeZoneSource</c> interface to an <c>IDateTimeZoneProvider</c>.
            </remarks>
            <seealso cref="T:NodaTime.DateTimeZoneProviders"/>
            <threadsafety>All members of this type are thread-safe as long as the underlying <c>IDateTimeZoneSource</c>
            implementation is thread-safe.</threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCache.#ctor(NodaTime.TimeZones.IDateTimeZoneSource)">
            <summary>
            Creates a provider backed by the given <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/>.
            </summary>
            <remarks>
            Note that the source will never be consulted for requests for the fixed-offset timezones "UTC" and
            "UTC+/-Offset" (a standard implementation will be returned instead). This is true even if these IDs are
            advertised by the source.
            </remarks>
            <param name="source">The <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/> for this provider.</param>
            <exception cref="T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException"><paramref name="source"/> violates its contract.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.DateTimeZoneCache.VersionId">
            <summary>
            The version ID of this provider. This is simply the <see cref="P:NodaTime.TimeZones.IDateTimeZoneSource.VersionId"/> returned by
            the underlying source.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.DateTimeZoneCache.Ids">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.DateTimeZoneCache.Item(System.String)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">
            <summary>
            Exception thrown when time zone is requested from an <see cref="T:NodaTime.IDateTimeZoneProvider"/>,
            but the specified ID is invalid for that provider.
            </summary>
            <remarks>
            This type only exists as <c>TimeZoneNotFoundException</c> doesn't exist in the Portable Class Library.
            By creating an exception which derives from <c>TimeZoneNotFoundException</c> on the desktop version
            and <c>Exception</c> on the PCL version, we achieve reasonable consistency while remaining
            backwardly compatible with Noda Time v1 (which was desktop-only, and threw <c>TimeZoneNotFoundException</c>).
            </remarks>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor(System.String)">
            <summary>
            Creates an instance with the given message.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="T:NodaTime.TimeZones.AmbiguousTimeResolver">
            <summary>
            Chooses between two <see cref="T:NodaTime.ZonedDateTime"/> values that resolve to the same <see cref="T:NodaTime.LocalDateTime"/>.
            </summary>
            <remarks>
            <para>
            This delegate is used by <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)"/> when handling an ambiguous local time,
            due to clocks moving backward in a time zone transition (usually due to an autumnal daylight saving transition).
            </para>
            <para>
            The returned value should be one of the two parameter values, based on the policy of the specific
            implementation. Alternatively, it can throw an <see cref="T:NodaTime.AmbiguousTimeException" /> to implement a policy of
            "reject ambiguous times."
            </para>
            <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations.</para>
            <para>
            Implementations of this delegate can reasonably
            assume that the target local date and time really is ambiguous; the behaviour when the local date and time
            can be unambiguously mapped into the target time zone (or when it's skipped) is undefined.
            </para>
            </remarks>
            <param name="earlier">The earlier of the ambiguous matches for the original local date and time</param>
            <param name="later">The later of the ambiguous matches for the original local date and time</param>
            <exception cref="T:NodaTime.AmbiguousTimeException">The implementation rejects requests to map ambiguous times.</exception>
            <returns>
            A <see cref="T:NodaTime.ZonedDateTime"/> in the target time zone; typically, one of the two input parameters.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.SkippedTimeResolver">
            <summary>
            Resolves a <see cref="T:NodaTime.LocalDateTime"/> to a <see cref="T:NodaTime.ZonedDateTime" /> in the situation
            where the requested local time does not exist in the target time zone.
            </summary>
            <remarks>
            <para>
            This delegate is used by <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)"/> when handling the situation where the
            requested local time does not exist, due to clocks moving forward in a time zone transition (usually due to a
            spring daylight saving transition).
            </para>
            <para>
            The returned value will necessarily represent a different local date and time to the target one, but
            the exact form of mapping is up to the delegate implementation. For example, it could return a value
            as close to the target local date and time as possible, or the time immediately after the transition.
            Alternatively, it can throw a <see cref="T:NodaTime.SkippedTimeException" /> to implement a policy of "reject
            skipped times."
            </para>
            <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations.</para>
            <para>
            Implementations of this delegate can reasonably
            assume that the target local date and time really is skipped; the behaviour when the local date and time
            can be directly mapped into the target time zone is undefined.
            </para>
            </remarks>
            <param name="localDateTime">The local date and time to map to the given time zone</param>
            <param name="zone">The target time zone</param>
            <param name="intervalBefore">The zone interval directly before the target local date and time would have occurred</param>
            <param name="intervalAfter">The zone interval directly after the target local date and time would have occurred</param>
            <exception cref="T:NodaTime.SkippedTimeException">The implementation rejects requests to map skipped times.</exception>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> in the target time zone.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneLocalMappingResolver">
            <summary>
            Resolves the result of attempting to map a local date and time to a target time zone.
            </summary>
            <remarks>
            <para>
            This delegate is consumed by <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/>,
            among others. It provides the strategy for converting a <see cref="T:NodaTime.TimeZones.ZoneLocalMapping"/> (the result of attempting
            to map a local date and time to a target time zone) to a <see cref="T:NodaTime.ZonedDateTime"/>.
            </para>
            <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations and a way of combining
            separate <see cref="T:NodaTime.TimeZones.SkippedTimeResolver" /> and <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver" /> values.</para>
            </remarks>
            <param name="mapping">The intermediate result of mapping a local time to a target time zone.</param>
            <exception cref="T:NodaTime.AmbiguousTimeException">The implementation rejects requests to map ambiguous times.</exception>
            <exception cref="T:NodaTime.SkippedTimeException">The implementation rejects requests to map skipped times.</exception>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> in the target time zone.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.PartialZoneIntervalMap">
            <summary>
            Like ZoneIntervalMap, representing just part of the time line. The intervals returned by this map
            are clamped to the portion of the time line being represented, to make it easier to work with.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.PartialZoneIntervalMap.Start">
            <summary>
            Start of the interval during which this map is valid.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.PartialZoneIntervalMap.End">
            <summary>
            End (exclusive) of the interval during which this map is valid.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.ForZoneInterval(System.String,NodaTime.Instant,NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Builds a PartialZoneIntervalMap for a single zone interval with the given name, start, end, wall offset and daylight savings.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.ForZoneInterval(NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Builds a PartialZoneIntervalMap wrapping the given zone interval, taking its start and end as the start and end of
            the portion of the time line handled by the partial map.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.PartialZoneIntervalMap.IsSingleInterval">
            <summary>
            Returns true if this map only contains a single interval; that is, if the first interval includes the end of the map.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.WithStart(NodaTime.Instant)">
            <summary>
            Returns a partial zone interval map equivalent to this one, but with the given start point.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.WithEnd(NodaTime.Instant)">
            <summary>
            Returns a partial zone interval map equivalent to this one, but with the given end point.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.ConvertToFullMap(System.Collections.Generic.IEnumerable{NodaTime.TimeZones.PartialZoneIntervalMap})">
            <summary>
            Converts a sequence of PartialZoneIntervalMaps covering the whole time line into an IZoneIntervalMap.
            The partial maps are expected to be in order, with the start of the first map being Instant.BeforeMinValue,
            the end of the last map being Instant.AfterMaxValue, and each adjacent pair of maps abutting (i.e. current.End == next.Start).
            Zone intervals belonging to abutting maps but which are equivalent in terms of offset and name
            are coalesced in the resulting map.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.PartialZoneIntervalMap.CombinedPartialZoneIntervalMap">
            <summary>
            Implementation of IZoneIntervalMap used by ConvertToFullMap
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.SingleZoneIntervalMap">
            <summary>
            Implementation of IZoneIntervalMap which just returns a single interval (provided on construction) regardless of
            the instant requested.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.TzdbZoneLocation">
            <summary>
            A location entry generated from the "zone.tab" file in a TZDB release. This can be used to provide
            users with a choice of time zone, although it is not internationalized.
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Latitude">
            <summary>
            Latitude in degrees; positive for North, negative for South.
            </summary>
            <remarks>The value will be in the range [-90, 90].</remarks>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Longitude">
            <summary>
            Longitude in degrees; positive for East, negative for West.
            </summary>
            <remarks>The value will be in the range [-180, 180].</remarks>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.CountryName">
            <summary>
            The English name of the country containing the location.
            </summary>
            <remarks>This will never be null.</remarks>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.CountryCode">
            <summary>
            The ISO-3166 2-letter country code for the country containing the location.
            </summary>
            <remarks>This will never be null.</remarks>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.ZoneId">
            <summary>
            The ID of the time zone for this location.
            </summary>
            <remarks>This will never be null, and if this mapping was fetched
            from a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>, it will always be a valid ID within that source.
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Comment">
            <summary>
            The comment (in English) for the mapping, if any.
            </summary>
            <remarks>
            This is usually used to differentiate between locations in the same country.
            This will return an empty string if no comment was provided in the original data.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbZoneLocation.#ctor(System.Int32,System.Int32,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new location.
            </summary>
            <remarks>This constructor is only public for the sake of testability. Non-test code should
            usually obtain locations from a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>.
            </remarks>
            <param name="latitudeSeconds">Latitude of the location, in seconds.</param>
            <param name="longitudeSeconds">Longitude of the location, in seconds.</param>
            <param name="countryName">English country name of the location, in degrees. Must not be null.</param>
            <param name="countryCode">ISO-3166 country code of the location. Must not be null.</param>
            <param name="zoneId">Time zone identifier of the location. Must not be null.</param>
            <param name="comment">Optional comment. Must not be null, but may be empty.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The latitude or longitude is invalid.</exception>
        </member>
        <member name="T:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader">
            <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneReader"/> which maintains the legacy "resource" format.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadCount">
            <summary>
            Reads a non-negative integer value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteCount(System.Int32)" />.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadSignedCount">
            <summary>
            Always throws NotSupportedException
            </summary>
            <returns>The integer read from the stream</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadOffset">
            <summary>
            Reads an offset value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteOffset(NodaTime.Offset)" />.
            </remarks>
            <returns>The offset value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadTicks">
            <summary>
            Reads a long ticks value from the stream.
            </summary>
            <remarks>
            The value must have been written by LegacyDateTimeZoneWriter.WriteTicks.
            </remarks>
            <returns>The long ticks value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadBoolean">
            <summary>
            Reads a boolean value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteBoolean(System.Boolean)" />.
            </remarks>
            <returns>The boolean value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadDictionary">
            <summary>
            Reads a string to string dictionary value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})" />.
            </remarks>
            <returns>The <see cref="T:System.Collections.Generic.IDictionary`2" /> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadZoneIntervalTransition(System.Nullable{NodaTime.Instant})">
            <summary>
            Reads an <see cref="T:NodaTime.Instant" /> value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)" />.
            The <paramref name="previous"/> parameter is ignored by this implementation.
            </remarks>
            <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
            <returns>The <see cref="T:NodaTime.Instant" /> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadString">
            <summary>
            Reads a string value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteString(System.String)" />.
            </remarks>
            <returns>The string value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadTimeZone(System.String)">
            <summary>
            Reads an <see cref="T:NodaTime.DateTimeZone" /> value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteTimeZone(NodaTime.DateTimeZone)" />.
            </remarks>
            <returns>The <see cref="T:NodaTime.DateTimeZone" /> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadInt16">
            <summary>
              Reads a signed 16 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 16 bit int value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadInt32">
            <summary>
            Reads a signed 32 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 32 bit int value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadInt64">
            <summary>
            Reads a signed 64 bit integer value from the stream and returns it as an long.
            </summary>
            <returns>The 64 bit long value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadByte">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter">
            <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter"/> which maintains the legacy "resource" format.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.#ctor(System.IO.Stream,System.Collections.Generic.IList{System.String})">
            <summary>
            Constructs a LegacyDateTimeZoneWriter.
            </summary>
            <param name="output">Where to send the serialized output.</param>
            <param name="stringPool">String pool to add strings to, or null for no pool</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteCount(System.Int32)">
            <summary>
            Writes the given non-negative integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteSignedCount(System.Int32)">
            <summary>
            Always throws NotSupportedException
            </summary>
            <param name="count">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
            <summary>
            Writes the offset value to the stream.
            </summary>
            <param name="offset">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteTicks(System.Int64)">
            <summary>
            Writes the long ticks value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteBoolean(System.Boolean)">
            <summary>
            Writes a boolean value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Writes the given dictionary of string to string to the stream.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2" /> to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)">
            <summary>
            Writes the <see cref="T:NodaTime.Instant" /> value to the stream.
            </summary>
            <remarks>
            The <paramref name="previous"/> parameter is ignored by this implementation.
            </remarks>
            <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteString(System.String)">
            <summary>
            Writes the string value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteTimeZone(NodaTime.DateTimeZone)">
            <summary>
            Writes the <see cref="T:NodaTime.DateTimeZone" /> value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteInt16(System.Int16)">
            <summary>
            Writes the given 16 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteInt32(System.Int32)">
            <summary>
            Writes the given 32 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteInt64(System.Int64)">
            <summary>
            Writes the given 64 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.IO.DateTimeZoneReader">
            <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneReader"/> for the most recent version
            of the "blob" format of time zone data. If the format changes, this class will be
            renamed (e.g. to DateTimeZoneReaderV0) and the new implementation will replace it.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadCount">
            <summary>
            Reads a non-negative integer value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)" />.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadSignedCount">
            <summary>
            Reads a (possibly-negative) integer value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteSignedCount(System.Int32)" />.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadVarint">
            <summary>
            Reads a base-128 varint value from the stream.
            </summary>
            <remarks>
            The value must have been written by DateTimeZoneWriter.WriteVarint, which
            documents the format.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadOffset">
            <summary>
            Reads an offset value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteOffset(NodaTime.Offset)" />.
            </remarks>
            <returns>The offset value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadDictionary">
            <summary>
            Reads a string to string dictionary value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})" />.
            </remarks>
            <returns>The <see cref="T:System.Collections.Generic.IDictionary`2" /> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadZoneIntervalTransition(System.Nullable{NodaTime.Instant})">
            <summary>
            Reads an instant representing a zone interval transition from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)" />.
            </remarks>
            <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
            <returns>The instant read from the stream</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadString">
            <summary>
            Reads a string value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteString(System.String)" />.
            </remarks>
            <returns>The string value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt16">
            <summary>
            Reads a signed 16 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 16 bit int value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt32">
            <summary>
            Reads a signed 32 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 32 bit int value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt64">
            <summary>
            Reads a signed 64 bit integer value from the stream and returns it as an long.
            </summary>
            <returns>The 64 bit long value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadByte">
            <summary>
            Reads a signed 8 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 8 bit int value.</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data in the stream has been exhausted.</exception>
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.IO.DateTimeZoneWriter">
            <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter"/> for the most recent version
            of the "blob" format of time zone data. If the format changes, this class will be
            renamed (e.g. to DateTimeZoneWriterV0) and the new implementation will replace it.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.EpochForMinutesSinceEpoch">
            <summary>The instant to use as an 'epoch' when writing out a number of minutes-since-epoch.</summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MarkerMinValue">
            <summary>The marker value representing the beginning of time.</summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MarkerMaxValue">
            <summary>The marker value representing the end of time.</summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MarkerRaw">
            <summary>The marker value representing an instant as a fixed 64-bit number of ticks.</summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MinValueForHoursSincePrevious">
            <summary>The minimum varint value that represents an number of hours-since-previous.</summary>
            <remarks>Values below value are reserved for markers.</remarks>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MinValueForMinutesSinceEpoch">
            <summary>The minimum varint value that represents an number of minutes since an epoch.</summary>
            <remarks>Values below this are interpreted as hours-since-previous (for a range of about 240 years),
            rather than minutes-since-epoch (for a range of about 4000 years)
            This choice is somewhat arbitrary, though it results in hour values always taking 2 (or
            occasionally 3) bytes when encoded as a varint, while minute values take 4 (or conceivably 5).</remarks>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.#ctor(System.IO.Stream,System.Collections.Generic.IList{System.String})">
            <summary>
            Constructs a DateTimeZoneWriter.
            </summary>
            <param name="output">Where to send the serialized output.</param>
            <param name="stringPool">String pool to add strings to, or null for no pool</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)">
            <summary>
            Writes the given non-negative integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteSignedCount(System.Int32)">
            <summary>
            Writes the given (possibly-negative) integer value to the stream.
            </summary>
            <remarks>
            Unlike <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)"/>, this can encode negative numbers. It does, however, use a slightly less
            efficient encoding for positive numbers.
            </remarks>
            <param name="count">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteVarint(System.UInt32)">
            <summary>
            Writes the given integer value to the stream as a base-128 varint.
            </summary>
            <remarks>
            The format is a simple 7-bit encoding: while the value is greater than 127 (i.e.
            has more than 7 significant bits) we repeatedly write the least-significant 7 bits
            with the top bit of the byte set as a continuation bit, then shift the value right
            7 bits.
            </remarks>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
            <summary>
            Writes the offset value to the stream.
            </summary>
            <param name="offset">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Writes the given dictionary of string to string to the stream.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2" /> to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteString(System.String)">
            <summary>
            Writes the string value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt16(System.Int16)">
            <summary>
            Writes the given 16 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt32(System.Int32)">
            <summary>
            Writes the given 32 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt64(System.Int64)">
            <summary>
            Writes the given 64 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.IO.IDateTimeZoneReader">
            <summary>
            Interface for reading time-related data from a binary stream.
            This is similar to <see cref="T:System.IO.BinaryReader" />, but heavily
            oriented towards our use cases. 
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadCount">
            <summary>
            Reads a non-negative integer from the stream, which must have been written
            by a call to <see cref="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteCount(System.Int32)"/>.
            </summary>
            <returns>The integer read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadSignedCount">
            <summary>
            Reads a non-negative integer from the stream, which must have been written
            by a call to <see cref="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteSignedCount(System.Int32)"/>.
            </summary>
            <returns>The integer read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadString">
            <summary>
            Reads a string from the stream.
            </summary>
            <returns>The string read from the stream; will not be null</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadByte">
            <summary>
            Reads a signed 8 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 8 bit int value.</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data in the stream has been exhausted.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadOffset">
            <summary>
            Reads an offset from the stream.
            </summary>
            <returns>The offset read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadZoneIntervalTransition(System.Nullable{NodaTime.Instant})">
            <summary>
            Reads an instant representing a zone interval transition from the stream.
            </summary>
            <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
            <returns>The instant read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadDictionary">
            <summary>
            Reads a string-to-string dictionary from the stream.
            </summary>
            <returns>The dictionary read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter">
            <summary>
            Interface for writing time-related data to a binary stream.
            This is similar to <see cref="T:System.IO.BinaryWriter" />, but heavily
            oriented towards our use cases.
            </summary>
            <remarks>
            <para>It is expected that the code reading data written by an implementation
            will be able to identify which implementation to use. Initially we have two
            implementations: one for reading the data from the legacy resource format,
            and one for reading the data from the first version of the newer blob format.
            When the legacy resource format is retired, it's possible that we will only
            have one implementation moving forward - but the interface will allow us to
            evolve the details of the binary structure independently of the code in the
            time zone implementations which knows how to write/read in terms of this interface
            and <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneReader"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteCount(System.Int32)">
            <summary>
            Writes a non-negative integer to the stream. This is optimized towards
            cases where most values will be small.
            </summary>
            <param name="count">The integer to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteSignedCount(System.Int32)">
            <summary>
            Writes a possibly-negative integer to the stream. This is optimized for
            values of small magnitudes.
            </summary>
            <param name="count">The integer to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteString(System.String)">
            <summary>
            Writes a string to the stream.
            </summary>
            <remarks>Other than the legacy resource writer, callers can reasonably expect that
            these values will be pooled in some fashion, so should not apply their own pooling.</remarks>
            <param name="value">The string to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
            <summary>
            Writes an offset to the stream.
            </summary>
            <param name="offset">The offset to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)">
            <summary>
            Writes an instant representing a zone interval transition to the stream.
            </summary>
            <remarks>
            This method takes a previously-written transition. Depending on the implementation, this value may be
            required by the reader in order to reconstruct the next transition, so it should be deterministic for any
            given value.
            </remarks>
            <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
            <param name="value">The transition to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Writes a string-to-string dictionary to the stream.
            </summary>
            <param name="dictionary"></param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteByte(System.Byte)">
            <summary>
            Writes the given 8 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="T:NodaTime.TimeZones.IO.ITzdbDataSource">
            <summary>
            Provides the raw data exposed by <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>. It would
            be simpler to use inheritance in this case with static factory methods, but
            there are already public constructors exposed - so to delegate to different
            implementations, we need a separate hierarchy :(
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.TzdbVersion">
            <summary>
            Returns the TZDB version string.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.TzdbIdMap">
            <summary>
            Returns the TZDB ID dictionary (alias to canonical ID). This needn't be read-only; it won't be
            exposed directly.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.WindowsMapping">
            <summary>
            Returns the Windows mapping dictionary. (As the type is immutable, it can be exposed directly
            to callers.)
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.ZoneLocations">
            <summary>
            Returns the zone locations for the source, or null if no location data is available.
            This needn't be read-only; it won't be exposed directly.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.ITzdbDataSource.CreateZone(System.String,System.String)">
            <summary>
            Creates the <see cref="T:NodaTime.DateTimeZone"/> for the given canonical ID, which will definitely
            be one of the values of the TzdbAliases dictionary.
            </summary>
            <param name="id">ID for the returned zone, which may be an alias.</param>
            <param name="canonicalId">Canonical ID for zone data</param>
        </member>
        <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.WindowsAdditionalStandardNameToIdMapping">
            <summary>
            Additional mappings from Windows standard name to TZDB ID. Primarily used in
            the PCL build, where we can't get at the system ID. Returns null when no data
            is available (legacy resource format).
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.IO.TzdbResourceData">
            <summary>
            Matching class for TzdbResourceWriter in the NodaTime.TzdbCompiler project. This
            knows how to read TZDB information from a .NET resource file.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbResourceData.WindowsToPosixMapKey">
            <summary>
            The resource key for the Windows to TZDB ID mapping dictionary.
            This resource key contains hyphens, so cannot conflict with a time zone name.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbResourceData.WindowsToPosixMapVersionKey">
            <summary>
            The resource key for the Windows to TZDB ID mapping version string.
            This resource key contains hyphens, so cannot conflict with a time zone name.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbResourceData.IdMapKey">
            <summary>
            The resource key for the timezone ID alias dictionary.
            This resource key contains hyphens, so cannot conflict with a time zone name.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbResourceData.VersionKey">
            <summary>
            The resource key for the TZDB version ID.
            This resource key contains hyphens, so cannot conflict with a time zone name.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.TzdbVersion">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.TzdbIdMap">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.WindowsMapping">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.IO.TzdbResourceData.CreateZone(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.IO.TzdbResourceData.LoadDictionary(System.Resources.ResourceSet,System.String)">
            <summary>
            Loads a dictionary of string to string with the given name from the given resource manager.
            </summary>
            <param name="source">The <see cref="T:System.Resources.ResourceSet"/> to load from.</param>
            <param name="name">The resource name.</param>
            <returns>The <see cref="T:System.Collections.Generic.IDictionary`2"/> or null if there is no such resource.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.TzdbResourceData.NormalizeAsResourceName(System.String)">
            <summary>
            Normalizes the given name into a valid resource name by replacing invalid
            characters with alternatives. This is used to ensure a valid resource name is
            used for each time zone resource.
            </summary>
            <param name="name">The name to normalize.</param>
            <returns>The normalized name.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.ZoneLocations">
            <summary>
            Always returns null - the resource data does not include zone locations.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.NodaTime#TimeZones#IO#ITzdbDataSource#WindowsAdditionalStandardNameToIdMapping">
            <summary>
            Always returns null - the resource data does not include any additional mappings.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.TzdbVersion">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.TzdbIdMap">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.WindowsMapping">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.ZoneLocations">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.IO.TzdbStreamData.CreateZone(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.WindowsAdditionalStandardNameToIdMapping">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.IO.TzdbStreamData.Builder">
            <summary>
            Mutable builder class used during parsing.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.IO.TzdbStreamField">
            <summary>
            An unparsed field within a stream.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.TzdbStreamField.CreateStream">
            <summary>
            Creates a new read-only stream over the data for this field.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.IO.TzdbStreamFieldId">
            <summary>
            Enumeration of the fields which can occur in a TZDB stream file.
            This enables the file to be self-describing to a reasonable extent.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.StringPool">
            <summary>
            String pool. Format is: number of strings (WriteCount) followed by that many string values.
            The indexes into the resultant list are used for other strings in the file, in some fields.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TimeZone">
            <summary>
            Repeated field of time zones. Format is: zone ID, then zone as written by DateTimeZoneWriter.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TzdbVersion">
            <summary>
            Single field giving the version of the TZDB source data. A string value which does *not* use the string pool.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TzdbIdMap">
            <summary>
            Single field giving the mapping of ID to canonical ID, as written by DateTimeZoneWriter.WriteDictionary.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.CldrSupplementalWindowsZones">
            <summary>
            Single field containing mapping data as written by WindowsZones.Write.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.WindowsAdditionalStandardNameToIdMapping">
            <summary>
            Single field giving the mapping of Windows StandardName to TZDB canonical ID,
            for time zones where TimeZoneInfo.Id != TimeZoneInfo.StandardName,
            as written by DateTimeZoneWriter.WriteDictionary.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.ZoneLocations">
            <summary>
            Single field providing all zone locations. The format is simply a count, and then that many copies of
            TzdbZoneLocation data.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.IZoneIntervalMap">
            <summary>
            The core part of a DateTimeZone: mapping an Instant to an Interval.
            Separating this out into an interface allows for flexible caching.
            </summary>
            <remarks>
            Benchmarking shows that a delegate may be slightly faster here, but the difference
            isn't very significant even for very fast calls (cache hits). The interface ends up
            feeling slightly cleaner elsewhere in the code.
            </remarks>
        </member>
        <member name="T:NodaTime.TimeZones.NamespaceDoc">
            <summary>
            <para>
            The NodaTime.TimeZones namespace contains types related to time zones beyond the core
            <see cref="T:NodaTime.DateTimeZone"/> class in the NodaTime namespace. Most users will have no need
            to refer to the types in this namespace.
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.Resolvers">
            <summary>
            Commonly-used implementations of the delegates used in resolving a <see cref="T:NodaTime.LocalDateTime"/> to a
            <see cref="T:NodaTime.ZonedDateTime"/>, and a method to combine two "partial" resolvers into a full one.
            </summary>
            <remarks>
            <para>
            This class contains predefined implementations of <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/>,
            <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/>, and <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/>, along with
            <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)"/>, which produces a <c>ZoneLocalMappingResolver</c> from instances of the
            other two.
            </para>
            </remarks>
            <threadsafety>All members of this class are thread-safe, as are the values returned by them.</threadsafety>
        </member>
        <member name="F:NodaTime.TimeZones.Resolvers.ReturnEarlier">
            <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which returns the earlier of the two matching times.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.Resolvers.ReturnLater">
            <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which returns the later of the two matching times.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous">
            <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which simply throws an <see cref="T:NodaTime.AmbiguousTimeException"/>.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.Resolvers.ReturnEndOfIntervalBefore">
            <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which returns the final tick of the time zone interval
            before the "gap".
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter">
            <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which returns the first tick of the time zone interval
            after the "gap".
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.Resolvers.ThrowWhenSkipped">
            <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which simply throws a <see cref="T:NodaTime.SkippedTimeException"/>.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.Resolvers.StrictResolver">
            <summary>
            A <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> which only ever succeeds in the (usual) case where the result
            of the mapping is unambiguous.
            </summary>
            <remarks>
            If the mapping is ambiguous or skipped, this throws <see cref="T:NodaTime.SkippedTimeException"/> or
            <see cref="T:NodaTime.AmbiguousTimeException"/>, as appropriate. This resolver combines
            <see cref="F:NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous"/> and <see cref="F:NodaTime.TimeZones.Resolvers.ThrowWhenSkipped"/>.
            </remarks>
            <seealso cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)"/>
        </member>
        <member name="F:NodaTime.TimeZones.Resolvers.LenientResolver">
            <summary>
            A <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> which never throws an exception due to ambiguity or skipped time.
            </summary>
            <remarks>
            Ambiguity is handled by returning the later occurrence, and skipped times are mapped to the start of the zone interval
            after the gap. This resolver combines <see cref="F:NodaTime.TimeZones.Resolvers.ReturnLater"/> and <see cref="F:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter"/>.
            </remarks>
            <seealso cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)"/>
        </member>
        <member name="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)">
            <summary>
            Combines an <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> and a <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> to create a
            <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/>.
            </summary>
            <remarks>
            The <c>ZoneLocalMappingResolver</c> created by this method operates in the obvious way: unambiguous mappings
            are returned directly, ambiguous mappings are delegated to the given <c>AmbiguousTimeResolver</c>, and
            "skipped" mappings are delegated to the given <c>SkippedTimeResolver</c>.
            </remarks>
            <param name="ambiguousTimeResolver">Resolver to use for ambiguous mappings.</param>
            <param name="skippedTimeResolver">Resolver to use for "skipped" mappings.</param>
            <returns>The logical combination of the two resolvers.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException">
            <summary>
            Exception thrown to indicate that a time zone source has violated the contract of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/>.
            This exception is primarily intended to be thrown from <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>, and only in the face of a buggy
            source; user code should not usually need to be aware of this or catch it.
            </summary>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor(System.String)">
            <summary>
            Creates a new instance with the given message.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="T:NodaTime.TimeZones.Transition">
            <summary>
            A transition between two offsets, usually for daylight saving reasons. This type only knows about
            the old offset, the new offset, and the transition point.
            </summary>
            
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.Transition.NewOffset">
            <summary>
            The offset from the time when this transition occurs until the next transition.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.op_Equality(NodaTime.TimeZones.Transition,NodaTime.TimeZones.Transition)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.op_Inequality(NodaTime.TimeZones.Transition,NodaTime.TimeZones.Transition)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.DaylightSavingsDateTimeZone">
            <summary>
            Provides a basic daylight savings time zone. A DST time zone has a simple recurrence
            where an extra offset is applied between two dates of a year.
            </summary>
            <remarks>
            IMPORTANT: This class *accepts* recurrences which start from a particular year
            rather than being infinite back to the start of time, but *treats* them as if
            they were infinite. This makes various calculations easier, but this zone should
            only be used as part of a PrecalculatedDateTimeZone which will only ask it for
            values within the right portion of the timeline.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.#ctor(System.String,NodaTime.Offset,NodaTime.TimeZones.ZoneRecurrence,NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DaylightSavingsDateTimeZone"/> class.
            </summary>
            <remarks>
            At least one of the recurrences (it doesn't matter which) must be a "standard", i.e. not have any savings
            applied. The other may still not have any savings (e.g. for America/Resolute) or (for BCL compatibility) may
            even have negative daylight savings.
            </remarks>
            <param name="id">The id.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="startRecurrence">The start recurrence.</param>
            <param name="endRecurrence">The end recurrence.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone interval for the given instant.
            </summary>
            <param name="instant">The Instant to test.</param>
            <returns>The ZoneInterval in effect at the given instant.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The instant falls outside the bounds
            of the recurrence rules of the zone.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.FindMatchingRecurrence(NodaTime.Instant)">
            <summary>
            Finds the recurrence containing the given instant, if any.
            </summary>
            <returns>The recurrence containing the given instant, or null if
            the instant occurs before the start of the earlier recurrence.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.NextTransition(NodaTime.Instant)">
            <summary>
            Returns the transition occurring strictly after the specified instant
            </summary>
            <param name="instant">The instant after which to consider transitions.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.PreviousTransition(NodaTime.Instant)">
            <summary>
            Returns the transition occurring strictly before the specified instant.
            </summary>
            <param name="instant">The instant before which to consider transitions.</param>
            <returns>
            The instant of the previous transition, or null if there are no further transitions.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.GetUtcOffset(NodaTime.Instant)">
            <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is later
            than UTC. In other words, local time = UTC + offset.
            </summary>
            <param name="instant">The instant for which to calculate the offset.</param>
            <returns>
            The offset from UTC at the specified instant.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.WriteLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified legacy writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="T:NodaTime.TimeZones.FixedDateTimeZone">
            <summary>
            Basic <see cref="T:NodaTime.DateTimeZone" /> implementation that has a fixed name key and offset i.e.
            no daylight savings.
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(NodaTime.Offset)">
            <summary>
            Creates a new fixed time zone.
            </summary>
            <param name="offset">The <see cref="P:NodaTime.TimeZones.FixedDateTimeZone.Offset"/> from UTC.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(System.String,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.FixedDateTimeZone"/> class.
            </summary>
            <param name="id">The id.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.MakeId(NodaTime.Offset)">
            <summary>
            Makes the id for this time zone. The format is "UTC+/-Offset".
            </summary>
            <param name="offset">The offset.</param>
            <returns>The generated id string.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetFixedZoneOrNull(System.String)">
            <summary>
            Returns a fixed time zone for the given ID, which must be "UTC" or "UTC[offset]" where "[offset]" can be parsed
            using the "general" offset pattern.
            </summary>
            <param name="id">ID </param>
            <returns>The parsed time zone, or null if the ID doesn't match.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.FixedDateTimeZone.Offset">
            <summary>
            Returns the fixed offset for this time zone.
            </summary>
            <returns>The fixed offset for this time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone interval for the given instant. This implementation always returns the same interval.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetZoneIntervalPair(NodaTime.LocalInstant)">
            <summary>
            Gets the zone interval pair for the given instant. This implementation always returns the same unambiguous interval pair.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetUtcOffset(NodaTime.Instant)">
            <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is later
            than UTC. In other words, local time = UTC + offset.
            </summary>
            <param name="instant">The instant for which to calculate the offset.</param>
            <returns>
            The offset from UTC at the specified instant.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader,System.String)">
            <summary>
            Reads a fixed time zone from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns>The fixed time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.IDateTimeZoneSource">
            <summary>
            Provides the interface for objects that can retrieve time zone definitions given an ID.
            </summary>
            <remarks>
            <para>
            The interface presumes that the available time zones are static; there is no mechanism for 
            updating the list of available time zones. Any time zone ID that is returned in <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds"/> 
            must be resolved by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)"/> for the life of the source.
            </para>
            <para>
            Implementations need not cache time zones or the available time zone IDs. 
            Caching is typically provided by <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>, which most consumers should use instead of
            consuming <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/> directly in order to get better performance.
            </para>
            <para>
            It is expected that any exceptions thrown are implementation-specific; nothing is explicitly
            specified in the interface. Typically this would be unusual to the point that callers would not
            try to catch them; any implementation which may break in ways that are sensible to catch should advertise
            this clearly, so that clients will know to handle the exceptions appropriately. No wrapper exception
            type is provided by Noda Time to handle this situation, and code in Noda Time does not try to catch
            such exceptions.
            </para>
            </remarks>
            <threadsafety>Implementations are not required to be thread-safe.</threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds">
            <summary>
            Returns an unordered enumeration of the IDs available from this source.
            </summary>
            <remarks>
            <para>
            Every value in this enumeration must return a valid time zone from <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)"/> for the life of the source.
            The enumeration may be empty, but must not be null, and must not contain any elements which are null.  It
            should not contain duplicates: this is not enforced, and while it may not have a significant impact on
            clients in some cases, it is generally unfriendly.  The built-in implementations never return duplicates.
            </para>
            <para>
            The source is not required to provide the IDs in any particular order, although they should be distinct.
            </para>
            <para>
            Note that this list may optionally contain any of the fixed-offset timezones (with IDs "UTC" and
            "UTC+/-Offset"), but there is no requirement they be included.
            </para>
            </remarks>
            <returns>The IDs available from this source.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.IDateTimeZoneSource.VersionId">
            <summary>
            Returns an appropriate version ID for diagnostic purposes, which must not be null.
            This doesn't have any specific format; it's solely for diagnostic purposes.
            The included sources return strings of the format "source identifier: source version" indicating where the
            information comes from and which version of the source information has been loaded.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)">
            <summary>
            Returns the time zone definition associated with the given ID.
            </summary>
            <remarks>
            <para>
            Note that this is permitted to return a <see cref="T:NodaTime.DateTimeZone"/> that has a different ID to that
            requested, if the ID provided is an alias.
            </para>
            <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone"/> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare as equal.
            </para>
            <para>
            It is advised that sources should document their behaviour regarding any fixed-offset timezones
            (i.e. "UTC" and "UTC+/-Offset") that are included in the list returned by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds"/>.
            (These IDs will not be requested by <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>, but any users calling
            into the source directly may care.)
            </para>
            <para>
            The source need not attempt to cache time zones; caching is typically provided by
            <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>.
            </para>
            </remarks>
            <param name="id">The ID of the time zone to return. This must be one of the IDs
            returned by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds"/>.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone"/> for the given ID.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="id"/> is not supported by this source.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)">
            <summary>
            Returns this source's corresponding ID for the given BCL time zone.
            </summary>
            <param name="timeZone">The BCL time zone, which must be a known system time zone.</param>
            <returns>
            The ID for the given system time zone for this source, or null if the system time
            zone has no mapping in this source.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneEqualityComparer">
            <summary>
            Equality comparer for time zones, comparing specific aspects of the zone intervals within
            a time zone for a specific interval of the time line.
            </summary>
            <remarks>
            The default behaviour of this comparator is to consider two time zones to be equal if they share the same wall
            offsets at all points within a given time interval, regardless of other aspects of each
            <see cref="T:NodaTime.TimeZones.ZoneInterval"/> within the two time zones. This behaviour can be changed using the
            <see cref="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)"/> method.
            </remarks>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneEqualityComparer.Options">
            <summary>
            Options to use when comparing time zones for equality. Each option makes the comparison more restrictive.
            </summary>
            <remarks>
            <para>
            By default, the comparer only compares the wall offset (total of standard offset and any daylight saving offset)
            at every instant within the interval over which the comparer operates. In practice, this is done by comparing each
            <see cref="T:NodaTime.TimeZones.ZoneInterval"/> which includes an instant within the interval (using <see cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)"/>).
            For most purposes, this is all that's required: from the simple perspective of a time zone being just a function from instants to local time,
            the default option of <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset"/> effectively checks that the function gives the same result across the two time
            zones being compared, for any given instant within the interval.
            </para>
            <para>
            It's possible for a time zone to have a transition from one <c>ZoneInterval</c> to another which doesn't adjust the offset: it
            might just change the name, or the balance between standard offset to daylight saving offset. (As an example, at midnight local
            time on October 27th 1968, the Europe/London time zone went from a standard offset of 0 and a daylight saving offset of 1 hour
            to a standard offset of 1 and a daylight saving offset of 0... which left the clocks unchanged.) This transition is irrelevant
            to the default options, so the two zone intervals involved are effectively coalesced.
            </para>
            <para>
            The options available change what sort of comparison is performed - which can also change which zone intervals can be coalesced. For
            example, by specifying just the <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions"/> option, you would indicate that even though you don't care about the name within a zone
            interval or how the wall offset is calculated, you do care about the fact that there was a transition at all, and when it occurred.
            With that option enabled, zone intervals are never coalesced and the transition points within the operating interval are checked.
            </para>
            <para>Similarly, the <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions"/> option is the only one where instants outside the operating interval are
            relevant. For example, consider a comparer which operates over the interval [2000-01-01T00:00:00Z, 2011-01-01T00:00:00Z). Normally,
            anything that happens before the year 2000 (UTC) would be irrelevant - but with this option enabled, the transitions of the first and last zone
            intervals are part of the comparison... so if one time zone has a zone interval 1999-09-01T00:00:00Z to 2000-03-01T00:00:00Z and the other has
            a zone interval 1999-10-15T00:00:00Z to 2000-03-01T00:00:Z, the two zones would be considered unequal, despite the fact that the only instants observing
            the difference occur outside the operating interval.
            </para>
            </remarks>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset">
            <summary>
            The default comparison, which only cares about the wall offset at any particular
            instant, within the interval of the comparer. In other words, if <see cref="M:NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)"/>
            returns the same value for all instants in the interval, the comparer will consider the zones to be equal.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchOffsetComponents">
            <summary>
            Instead of only comparing wall offsets, the standard/savings split is also considered. So when this
            option is used, two zones which both have a wall offset of +2 at one instant would be considered
            unequal if one of those offsets was +1 standard, +1 savings and the other was +2 standard with no daylight
            saving.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchNames">
            <summary>
            Compare the names of zone intervals as well as offsets.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions">
            <summary>
            This option prevents adjacent zone intervals from being coalesced, even if they are otherwise considered
            equivalent according to other options.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions">
            <summary>
            Includes the transitions into the first zone interval and out of the
            last zone interval as part of the comparison, even if they do not affect
            the offset or name for any instant within the operating interval.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.StrictestMatch">
            <summary>
            The combination of all available match options.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.CheckOption(NodaTime.TimeZones.ZoneEqualityComparer.Options,NodaTime.TimeZones.ZoneEqualityComparer.Options)">
            <summary>
            Checks whether the given set of options includes the candidate one. This would be an extension method, but
            that causes problems on Mono at the moment.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneEqualityComparer.IntervalForTest">
            <summary>
            Returns the interval over which this comparer operates.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneEqualityComparer.OptionsForTest">
            <summary>
            Returns the options used by this comparer.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.#ctor(NodaTime.Interval,NodaTime.TimeZones.ZoneEqualityComparer.Options)">
            <summary>
            Creates a new comparer for the given interval, with the given comparison options.
            </summary>
            <param name="interval">The interval within the time line to use for comparisons.</param>
            <param name="options">The options to use when comparing time zones.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified options are invalid.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.ForInterval(NodaTime.Interval)">
            <summary>
            Returns a <see cref="T:NodaTime.TimeZones.ZoneEqualityComparer"/> for the given interval with the default options.
            </summary>
            <remarks>
            The default behaviour of this comparator is to consider two time zones to be equal if they share the same wall
            offsets at all points within a given interval.
            To specify non-default options, call the <see cref="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)"/> method on the result
            of this method.</remarks>
            <param name="interval">The interval over which to compare time zones.</param>
            <returns>A ZoneEqualityComparer for the given interval with the default options.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)">
            <summary>
            Returns a comparer operating over the same interval as this one, but with the given
            set of options.
            </summary>
            <remarks>
            This method does not modify the comparer on which it's called.
            </remarks>
            <param name="options">New set of options, which must consist of flags defined within the <see cref="T:NodaTime.TimeZones.ZoneEqualityComparer.Options"/> enum.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified options are invalid.</exception>
            <returns>A comparer operating over the same interval as this one, but with the given set of options.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.Equals(NodaTime.DateTimeZone,NodaTime.DateTimeZone)">
            <summary>
            Compares two time zones for equality according to the options and interval provided to this comparer.
            </summary>
            <param name="x">The first <see cref="T:NodaTime.DateTimeZone"/> to compare.</param>
            <param name="y">The second <see cref="T:NodaTime.DateTimeZone"/> to compare.</param>
            <returns><c>true</c> if the specified time zones are equal under the options and interval of this comparer; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode(NodaTime.DateTimeZone)">
            <summary>
            Returns a hash code for the specified time zone.
            </summary>
            <remarks>
            The hash code generated by any instance of <c>ZoneEqualityComparer</c> will be equal to the hash code
            generated by any other instance constructed with the same options and interval, for the same time zone (or equal ones).
            Two instances of <c>ZoneEqualityComparer</c> with different options or intervals may (but may not) produce
            different hash codes for the same zone.
            </remarks>
            <param name="obj">The time zone to compute a hash code for.</param>
            <returns>A hash code for the specified object.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.ZoneIntervalEqualityComparer.EqualExceptStartAndEnd(NodaTime.TimeZones.ZoneInterval,NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Compares the parts of two zone intervals which are deemed "interesting" by the options.
            The wall offset is always compared, regardless of options, but the start/end points are
            never compared.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneInterval">
            <summary>
            Represents a range of time for which a particular Offset applies.
            </summary>
            <threadsafety>This type is an immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.#ctor(System.String,NodaTime.Instant,NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneInterval" /> class.
            </summary>
            <param name="name">The name of this offset period (e.g. PST or PDT).</param>
            <param name="start">The first <see cref="T:NodaTime.Instant" /> that the <paramref name = "wallOffset" /> applies.</param>
            <param name="end">The last <see cref="T:NodaTime.Instant" /> (exclusive) that the <paramref name = "wallOffset" /> applies.</param>
            <param name="wallOffset">The <see cref="P:NodaTime.TimeZones.ZoneInterval.WallOffset" /> from UTC for this period including any daylight savings.</param>
            <param name="savings">The <see cref="P:NodaTime.TimeZones.ZoneInterval.WallOffset" /> daylight savings contribution to the offset.</param>
            <exception cref="T:System.ArgumentException">If <c><paramref name = "start" /> &gt;= <paramref name = "end" /></c>.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.WithStart(NodaTime.Instant)">
            <summary>
            Returns a copy of this zone interval, but with the given start instant.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.WithEnd(NodaTime.Instant)">
            <summary>
            Returns a copy of this zone interval, but with the given end instant.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.StandardOffset">
            <summary>
              Gets the standard offset for this period. This is the offset without any daylight savings
              contributions.
            </summary>
            <remarks>
              This is effectively <c>Offset - Savings</c>.
            </remarks>
            <value>The base Offset.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Duration">
            <summary>
              Gets the duration of this period.
            </summary>
            <remarks>
              This is effectively <c>End - Start</c>.
            </remarks>
            <value>The Duration of this period.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.End">
            <summary>
              Gets the last Instant (exclusive) that the Offset applies.
            </summary>
            <value>The last Instant (exclusive) that the Offset applies.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.LocalEnd">
            <summary>
              Gets the end time as a LocalInstant.
            </summary>
            <remarks>
              This is effectively <c>End + Offset</c>.
            </remarks>
            <value>The ending LocalInstant.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.LocalStart">
            <summary>
              Gets the start time as a LocalInstant.
            </summary>
            <remarks>
              This is effectively <c>Start + Offset</c>.
            </remarks>
            <value>The starting LocalInstant.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.IsoLocalStart">
            <summary>
            Returns the local start time of the interval, as LocalDateTime
            in the ISO calendar.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.IsoLocalEnd">
            <summary>
            Returns the local start time of the interval, as LocalDateTime
            in the ISO calendar. This does not include any daylight saving 
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Name">
            <summary>
              Gets the name of this offset period (e.g. PST or PDT).
            </summary>
            <value>The name of this offset period (e.g. PST or PDT).</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.WallOffset">
            <summary>
              Gets the offset from UTC for this period. This includes any daylight savings value.
            </summary>
            <value>The offset from UTC for this period.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Savings">
            <summary>
              Gets the daylight savings value for this period.
            </summary>
            <value>The savings value.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Start">
            <summary>
              Gets the first Instant that the Offset applies.
            </summary>
            <value>The first Instant that the Offset applies.</value>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.Instant)">
            <summary>
              Determines whether this period contains the given Instant in its range.
            </summary>
            <remarks>
            Usually this is half-open, i.e. the end is exclusive, but an interval with an end point of "the end of time" 
            is deemed to be inclusive at the end.
            </remarks>
            <param name="instant">The instant to test.</param>
            <returns>
              <c>true</c> if this period contains the given Instant in its range; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.LocalInstant)">
            <summary>
              Determines whether this period contains the given LocalInstant in its range.
            </summary>
            <param name="localInstant">The local instant to test.</param>
            <returns>
              <c>true</c> if this period contains the given LocalInstant in its range; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Equals(NodaTime.TimeZones.ZoneInterval)">
            <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
              true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.
            </param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, <c>false</c>.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.GetHashCode">
            <summary>
              Serves as a hash function for a particular type.
            </summary>
            <returns>
              A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.ToString">
            <summary>
              Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneIntervalPair">
            <summary>
            A pair of possibly null ZoneInterval values. This is the result of fetching a time zone
            interval by LocalInstant, as the result could be 0, 1 or 2 matching ZoneIntervals.
            This is a sort of light-weight version of ZoneLocalMapping, used when we won't need to
            know the details of the gaps and it's handy to use a struct instead of creating a new object.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneIntervalPair.EarlyInterval">
            <summary>
            The earlier of the two zone intervals matching the original local instant, or null
            if there were no matches. If there is a single match (the most common case) this
            value will be non-null, and LateInterval will be null.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneIntervalPair.LateInterval">
            <summary>
            The later of the two zone intervals matching the original local instant, or null
            if there were no matches. If there is a single match (the most common case) this
            value will be null, and EarlyInterval will be non-null.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneIntervalPair.MatchingIntervals">
            <summary>
            Returns the number of intervals contained within this pair - 0 for a "gap",
            1 for an unambiguous match, 2 for an ambiguous match.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneIntervalPair.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, <c>false</c>.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneIntervalPair.Equals(NodaTime.TimeZones.ZoneIntervalPair)">
            <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
              true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.
            </param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneIntervalPair.GetHashCode">
            <summary>
              Serves as a hash function for a particular type.
            </summary>
            <returns>
              A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneLocalMapping">
            <summary>
            The result of mapping a <see cref="T:NodaTime.LocalDateTime" /> within a time zone, i.e. finding out
            at what "global" time the "local" time occurred.
            </summary>
            <remarks>
            <para>
            This class is used as the return type of <see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)" />. It allows for
            finely-grained handling of the three possible results:
            </para>
            <list type="bullet">
              <item>
                <term>Unambiguous mapping</term>
                <description>The local time occurs exactly once in the target time zone.</description>
              </item>
              <item>
                <term>Ambiguous mapping</term>
                <description>
                  The local time occurs twice in the target time zone, due to the offset from UTC
                  changing. This usually occurs for an autumnal daylight saving transition, where the clocks
                  are put back by an hour. If the clocks change from 2am to 1am for example, then 1:30am occurs
                  twice - once before the transition and once afterwards.
                </description>
              </item>
              <item>
                <term>Impossible mapping</term>
                <description>
                  The local time does not occur at all in the target time zone, due to the offset from UTC
                  changing. This usually occurs for a vernal (spring-time) daylight saving transition, where the clocks
                  are put forward by an hour. If the clocks change from 1am to 2am for example, then 1:30am is
                  skipped entirely.
                </description>
              </item>
            </list>
            </remarks>
            <threadsafety>This type is an immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.Count">
            <summary>
            Returns the number of results within this mapping: the number of distinct
            <see cref="T:NodaTime.ZonedDateTime" /> values which map to the original <see cref="T:NodaTime.LocalDateTime" />.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.Zone">
            <summary>
            Returns the <see cref="T:NodaTime.DateTimeZone" /> in which this mapping was performed.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime">
            <summary>
            Returns the <see cref="T:NodaTime.LocalDateTime" /> which was mapped with in the time zone.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval">
            <summary>
            Returns the earlier <see cref="T:NodaTime.TimeZones.ZoneInterval" /> within this mapping. For unambiguous
            mappings, this is the same as <see cref="P:NodaTime.TimeZones.ZoneLocalMapping.LateInterval" />; for ambiguous mappings,
            this is the interval during which the mapped local time first occurs; for impossible
            mappings, this is the interval before which the mapped local time occurs.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.LateInterval">
            <summary>
            Returns the later <see cref="T:NodaTime.TimeZones.ZoneInterval" /> within this mapping. For unambiguous
            mappings, this is the same as <see cref="P:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval" />; for ambiguous mappings,
            this is the interval during which the mapped local time last occurs; for impossible
            mappings, this is the interval after which the mapped local time occurs.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneLocalMapping.Single">
            <summary>
            Returns the single <see cref="T:NodaTime.ZonedDateTime"/> which maps to the original
            <see cref="T:NodaTime.LocalDateTime" /> in the mapped <see cref="T:NodaTime.DateTimeZone" />.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">The local date/time was ambiguous in the time zone.</exception>
            <returns>The unambiguous result of mapping the local date/time in the time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneLocalMapping.First">
            <summary>
            Returns a <see cref="T:NodaTime.ZonedDateTime"/> which maps to the original <see cref="T:NodaTime.LocalDateTime" />
            in the mapped <see cref="T:NodaTime.DateTimeZone" />: either the single result if the mapping is unambiguous,
            or the earlier result if the local date/time occurs twice in the time zone due to a time zone
            offset change such as an autumnal daylight saving transition.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
            <returns>The unambiguous result of mapping a local date/time in a time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneLocalMapping.Last">
            <summary>
            Returns a <see cref="T:NodaTime.ZonedDateTime"/> which maps to the original <see cref="T:NodaTime.LocalDateTime" />
            in the mapped <see cref="T:NodaTime.DateTimeZone" />: either the single result if the mapping is unambiguous,
            or the later result if the local date/time occurs twice in the time zone due to a time zone
            offset change such as an autumnal daylight saving transition.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
            <returns>The unambiguous result of mapping a local date/time in a time zone.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneYearOffset">
            <summary>
            Defines an offset within a year as an expression that can be used to reference multiple
            years.
            </summary>
            <remarks>
            <para>
            A year offset defines a way of determining an offset into a year based on certain criteria.
            The most basic is the month of the year and the day of the month. If only these two are
            supplied then the offset is always the same day of each year. The only exception is if the
            day is February 29th, then it only refers to those years that have a February 29th.
            </para>
            <para>
            If the day of the week is specified then the offset determined by the month and day are
            adjusted to the nearest day that falls on the given day of the week. If the month and day
            fall on that day of the week then nothing changes. Otherwise the offset is moved forward or
            backward up to 6 days to make the day fall on the correct day of the week. The direction the
            offset is moved is determined by the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.AdvanceDayOfWeek"/> property.
            </para>
            <para>
            Finally the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.Mode"/> property deterines whether the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.TimeOfDay"/> value
            is added to the calculated offset to generate an offset within the day.
            </para>
            <para>
            Immutable, thread safe
            </para>
            </remarks>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneYearOffset.StartOfYear">
            <summary>
            An offset that specifies the beginning of the year.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.#ctor(NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.LocalTime)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneYearOffset"/> class.
            </summary>
            <param name="mode">The transition mode.</param>
            <param name="monthOfYear">The month year offset.</param>
            <param name="dayOfMonth">The day of month. Negatives count from end of month.</param>
            <param name="dayOfWeek">The day of week. 0 means not set.</param>
            <param name="advance">if set to <c>true</c> [advance].</param>
            <param name="timeOfDay">The tick within the day.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.#ctor(NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.LocalTime,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneYearOffset"/> class.
            </summary>
            <param name="mode">The transition mode.</param>
            <param name="monthOfYear">The month year offset.</param>
            <param name="dayOfMonth">The day of month. Negatives count from end of month.</param>
            <param name="dayOfWeek">The day of week. 0 means not set.</param>
            <param name="advance">if set to <c>true</c> [advance].</param>
            <param name="timeOfDay">The time of day at which the transition occurs.</param>
            <param name="addDay">Whether to add an extra day (for 24:00 handling).</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.VerifyFieldValue(System.Int64,System.Int64,System.String,System.Int64,System.Boolean)">
            <summary>
            Verifies the input value against the valid range of the calendar field.
            </summary>
            <remarks>
            If this becomes more widely required, move to Preconditions.
            </remarks>
            <param name="minimum">The minimum valid value.</param>
            <param name="maximum">The maximum valid value (inclusive).</param>
            <param name="name">The name of the field for the error message.</param>
            <param name="value">The value to check.</param>
            <param name="allowNegated">if set to <c>true</c> all the range of value to be the negative as well.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the given value is not in the valid range of the given calendar field.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.Mode">
            <summary>
            Gets the method by which offsets are added to Instants to get LocalInstants.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.AdvanceDayOfWeek">
            <summary>
            Gets a value indicating whether [advance day of week].
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.TimeOfDay">
            <summary>
            Gets the time of day when the rule takes effect.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.AddDay">
            <summary>
            Returns whether or not a day is added to the result, due to
            the time being 24:00.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Equals(NodaTime.TimeZones.ZoneYearOffset)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.NormalizeModeCharacter(System.Char)">
            <summary>
            Normalizes the transition mode characater.
            </summary>
            <param name="modeCharacter">The character to normalize.</param>
            <returns>The <see cref="T:NodaTime.TimeZones.TransitionMode"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.MakeInstant(System.Int32,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns an <see cref="T:NodaTime.Instant"/> that represents the point in the given year that this
            object defines. If the exact point is not valid then the nearest point that matches the
            definition is returned.
            </summary>
            <param name="year">The year to calculate for.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The <see cref="T:NodaTime.Instant"/> of the point in the given year.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Next(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the given instant adjusted one year forward taking into account leap years and other
            adjustments like day of week.
            </summary>
            <param name="instant">The instant to adjust.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The adjusted <see cref="T:NodaTime.LocalInstant"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Previous(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the given instant adjusted one year backward taking into account leap years and other
            adjustments like day of week.
            </summary>
            <param name="instant">The instant to adjust.</param>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The adjusted <see cref="T:NodaTime.LocalInstant"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter"/>.
            </summary>
            <param name="writer">Where to send the output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.WriteLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter)">
            <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter"/>.
            </summary>
            <param name="writer">Where to send the output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetOffset(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the offset to use for this object's <see cref="T:NodaTime.TimeZones.TransitionMode"/>.
            </summary>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The base time offset as a <see cref="T:NodaTime.Duration"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.PrecalculatedDateTimeZone">
            <summary>
            Most time zones have a relatively small set of transitions at their start until they finally 
            settle down to either a fixed time zone or a daylight savings time zone. This provides the
            container for the initial zone intervals and a pointer to the time zone that handles all of
            the rest until the end of time.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.PrecalculatedDateTimeZone.tailZoneStart">
            <summary>
            The first instant covered by the tail zone, or Instant.MaxValue if there's no tail zone.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.#ctor(System.String,NodaTime.TimeZones.ZoneInterval[],NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.PrecalculatedDateTimeZone"/> class.
            </summary>
            <param name="id">The id.</param>
            <param name="periods">The periods.</param>
            <param name="tailZone">The tail zone.</param>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.ValidatePeriods(NodaTime.TimeZones.ZoneInterval[],NodaTime.DateTimeZone)">
            <summary>
            Validates that all the periods before the tail zone make sense. We have to start at the beginning of time,
            and then have adjoining periods. This is only called in the constructors.
            </summary>
            <remarks>This is only called from the constructors, but is internal to make it easier to test.</remarks>
            <exception cref="T:System.ArgumentException">The periods specified are invalid.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone offset period for the given instant.
            </summary>
            <param name="instant">The Instant to find.</param>
            <returns>The ZoneInterval including the given instant.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.IsCachable">
            <summary>
            Returns true if this time zone is worth caching. Small time zones or time zones with
            lots of quick changes do not work well with <see cref="T:NodaTime.TimeZones.CachedDateTimeZone"/>.
            </summary>
            <returns><c>true</c> if this instance is cachable; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader,System.String)">
            <summary>
            Reads a time zone from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns>The time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.WriteLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.ReadLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneReader,System.String)">
            <summary>
            Reads a time zone from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns>The time zone.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneRecurrence">
            <summary>
            Extends <see cref="T:NodaTime.TimeZones.ZoneYearOffset"/> with a name and savings.
            </summary>
            <remarks>
            <para>
            This represents a recurring transition from or to a daylight savings time. The name is the
            name of the time zone during this period (e.g. PST or PDT). The savings is usually 0 or the
            daylight offset. This is also used to support some of the tricky transitions that occurred
            before that calendars were "standardized."
            </para>
            <para>
            Immutable, thread safe.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.#ctor(System.String,NodaTime.Offset,NodaTime.TimeZones.ZoneYearOffset,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneRecurrence"/> class.
            </summary>
            <param name="name">The name of the time zone period e.g. PST.</param>
            <param name="savings">The savings for this period.</param>
            <param name="yearOffset">The year offset of when this period starts in a year.</param>
            <param name="fromYear">The first year in which this recurrence is valid</param>
            <param name="toYear">The last year in which this recurrence is valid</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.WithName(System.String)">
            <summary>
            Returns a new recurrence which has the same values as this, but a different name.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Equals(NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Next(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the given instant adjusted one year forward taking into account leap years and other
            adjustments like day of week.
            </summary>
            <remarks>
            If the given instant is before the starting year, the year of the given instant is
            adjusted to the beginning of the starting year. The first transition after the
            adjusted instant is determined. If the next adjustment is after the ending year, this
            method returns null; otherwise the next transition is returned.
            </remarks>
            <param name="instant">The <see cref="T:NodaTime.Instant"/> lower bound for the next transition.</param>
            <param name="standardOffset">The <see cref="T:NodaTime.Offset"/> standard offset.</param>
            <param name="previousSavings">The <see cref="T:NodaTime.Offset"/> savings adjustment at the given Instant.</param>
            <returns>The next transition, or null if there is no next transition.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Previous(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the given instant adjusted one year backward taking into account leap years and other
            adjustments like day of week.
            </summary>
            <param name="instant">The <see cref="T:NodaTime.Instant"/> lower bound for the next trasnition.</param>
            <param name="standardOffset">The <see cref="T:NodaTime.Offset"/> standard offset.</param>
            <param name="previousSavings">The <see cref="T:NodaTime.Offset"/> savings adjustment at the given Instant.</param>
            <returns>The previous transition, or null if there is no previous transition.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.NextOrFail(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Piggy-backs onto Next, but fails with an InvalidOperationException if there's no such transition.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.PreviousOrFail(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Piggy-backs onto Previous, but fails with a descriptive InvalidOperationException if there's no such transition.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.IO.DateTimeZoneWriter"/>.
            </summary>
            <param name="writer">Where to send the output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader)">
            <summary>
            Reads a recurrence from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <returns>The recurrence read from the reader.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToStartOfTime">
            <summary>
            Returns either "this" (if this zone recurrence already has a from year of int.MinValue)
            or a new zone recurrence which is identical but with a from year of int.MinValue.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToInfinity">
            <summary>
            Returns either "this" (if this zone recurrence is already infinite)
            or a new zone recurrence which is identical but with a from year of int.MinValue
            and an end year of int.MaxValue.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.TransitionMode">
            <summary>
            Specifies how transitions are calculated. Whether relative to UTC, the time zones standard
            offset, or the wall (or daylight savings) offset.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Utc">
            <summary>
            Calculate transitions against UTC.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Wall">
            <summary>
            Calculate transitions against wall offset.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Standard">
            <summary>
            Calculate transitions against standard offset.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.TzdbDateTimeZoneSource">
            <summary>
            Provides an implementation of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> that loads data originating from the
            <a href="http://www.iana.org/time-zones">tz database</a> (also known as the IANA Time Zone database, or zoneinfo
            or Olson database).
            </summary>
            <remarks>
            All calls to <see cref="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)"/> for fixed-offset IDs advertised by the source (i.e. "UTC" and "UTC+/-Offset")
            will return zones equal to those returned by <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)"/>.
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default">
            <summary>
            The <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/> initialised from resources within the NodaTime assembly.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.source">
            <summary>
            Original source data - we delegate to this to create actual DateTimeZone instances,
            and for windows mappings.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.timeZoneIdMap">
            <summary>
            Map from ID (possibly an alias) to canonical ID. This is a read-only wrapper,
            and can be returned directly to clients.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.aliases">
            <summary>
            Lookup from canonical ID to aliases.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.version">
            <summary>
            Composite version ID including TZDB and Windows mapping version strings.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.zoneLocations">
            <summary>
            List of zone locations, if any. This is a read-only wrapper, and can be
            returned directly to clients. It may be null, if the underlying data source
            has no location data.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> class from a resource within
            the NodaTime assembly.
            </summary>
            <remarks>For backwards compatibility, this will use the blob time zone data when given the same
            base name which would previously have loaded the now-obsolete resource data.</remarks>
            <param name="baseName">The root name of the resource file.</param>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data within the resource is invalid.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">The resource set cannot be found.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> class.
            </summary>
            <remarks>For backwards compatibility, this will use the blob time zone data when given the same
            base name which would previously have loaded the now-obsolete resource data from the Noda Time assembly
            itself.</remarks>
            <param name="baseName">The root name of the resource file.</param>
            <param name="assembly">The assembly to search for the time zone resources.</param>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data within the resource is invalid.</exception>
            <exception cref="T:System.Resources.MissingManifestResourceException">The resource set cannot be found.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.Resources.ResourceSet)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> class.
            </summary>
            <param name="source">The <see cref="T:System.Resources.ResourceSet"/> to search for the time zone resources.</param>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data within the resource set is invalid.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.Resources.ResourceManager)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> class.
            </summary>
            <param name="manager">The <see cref="T:System.Resources.ResourceManager"/> to search for the time zone resources.</param>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data within the resource manager is invalid.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream(System.IO.Stream)">
            <summary>
            Creates an instance from a stream in the custom Noda Time format. The stream must be readable.
            </summary>
            <remarks>
            <para>
            The stream is not closed by this method, but will be read from
            without rewinding. A successful call will read the stream to the end.
            </para>
            <para>
            See the user guide for instructions on how to generate an updated time zone database file from a copy of the
            (textual) tz database.
            </para>
            </remarks>
            <param name="stream">The stream containing time zone data</param>
            <returns>A <c>TzdbDateTimeZoneSource</c> providing information from the given stream.</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The stream contains invalid time zone data, or data which cannot
            be read by this version of Noda Time.</exception>
            <exception cref="T:System.IO.IOException">Reading from the stream failed.</exception>
            <exception cref="T:System.InvalidOperationException">The supplied stream doesn't support reading.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId">
            <inheritdoc />
            <remarks>
            <para>
            This source returns a string such as "TZDB: 2013b (mapping: 8274)" corresponding to the versions of the tz
            database and the CLDR Windows zones mapping file.
            </para>
            <para>
            Note that there is no need to parse this string to extract any of the above information, as it is available
            directly from the <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion"/> and <see cref="P:NodaTime.TimeZones.Cldr.WindowsZones.Version"/> properties.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)">
            <inheritdoc />
            <param name="zone">The BCL time zone, which must be a known system time zone.</param>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GuessZoneIdByTransitionsUncached(System.TimeZoneInfo)">
            <summary>
            In cases where we can't get a zone mapping, either because we haven't kept
            up to date with the standard names or because the system language isn't English,
            try to work out the TZDB mapping by the transitions within the next few years.
            We only do this for the PCL, where we can't ask a TimeZoneInfo for its ID. Unfortunately
            this means we may sometimes return a mapping for zones which shouldn't be mapped at all, but that's
            probably okay and we return null if we don't get a 70% hit rate anyway. We look at all
            transitions in all primary mappings for the next year.
            Heuristically, this seems to be good enough to get the right results in most cases.
            </summary>
            <remarks>This method is not PCL-only as we would like to test it frequently. It will
            never actually be called in the non-PCL release though.</remarks>
            <param name="zone">Zone to resolve in a best-effort fashion.</param>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases">
            <summary>
            Returns a lookup from canonical time zone ID (e.g. "Europe/London") to a group of aliases for that time zone
            (e.g. {"Europe/Belfast", "Europe/Guernsey", "Europe/Jersey", "Europe/Isle_of_Man", "GB", "GB-Eire"}).
            </summary>
            <remarks>
            The group of values for a key never contains the canonical ID, only aliases. Any time zone
            ID which is itself an alias or has no aliases linking to it will not be present in the lookup.
            The aliases within a group are returned in alphabetical (ordinal) order.
            </remarks>
            <returns>A lookup from canonical ID to the aliases of that ID.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap">
            <summary>
            Returns a read-only map from time zone ID to the canonical ID. For example, the key "Europe/Jersey"
            would be associated with the value "Europe/London".
            </summary>
            <remarks>
            <para>This map contains an entry for every ID returned by <see cref="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds"/>, where
            canonical IDs map to themselves.</para>
            <para>The returned map is read-only; any attempts to call a mutating method will throw
            <see cref="T:System.NotSupportedException" />.</para>
            </remarks>
            <returns>A map from time zone ID to the canonical ID.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations">
            <summary>
            Returns a read-only list of zone locations known to this source.
            </summary>
            <remarks>
            <para>
            Every zone location's time zone ID is guaranteed to be valid within this source (assuming the source
            has been validated).
            </para>
            <para>
            The legacy resource format does not include location information,
            and this property will throw an exception if the information is requested. It is expected
            that callers who wish to use newer features will not be attempting to use legacy formats
            for time zone data.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">This is a legacy resource-based data source which does
            not include location information.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion">
            <summary>
            Returns just the TZDB version (e.g. "2013a") of the source data.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping">
            <summary>
            Gets the Windows time zone mapping information provided in the CLDR
            supplemental "windowsZones.xml" file.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate">
            <summary>
            Validates that the data within this source is consistent with itself.
            </summary>
            <remarks>
            Source data is not validated automatically when it's loaded, but any source
            loaded from data produced by <c>NodaTime.TzdbCompiler</c> (including the data shipped with Noda Time)
            will already have been validated via this method when it was originally produced. This method should
            only normally be called explicitly if you have data from a source you're unsure of.
            </remarks>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The source data is invalid. The source may not function
            correctly.</exception>
        </member>
        <member name="T:NodaTime.LocalDateTime">
            <summary>
            A date and time in a particular calendar system. A LocalDateTime value does not represent an
            instant on the time line, because it has no associated time zone: "November 12th 2009 7pm, ISO calendar"
            occurred at different instants for different people around the world.
            </summary>
            <remarks>
            <para>
            This type defaults to using the IsoCalendarSystem unless a different calendar system is
            specified.
            </para>
            <para>Comparisons of values can be handled in a way which is either calendar-sensitive or calendar-insensitive.
            Noda Time implements all the operators (and the <see cref="M:NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)"/> method) such that all operators other than <see cref="M:NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)"/>
            will return false if asked to compare two values in different calendar systems.
            </para>
            <para>
            However, the <see cref="M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)"/> method (implementing <see cref="T:System.IComparable`1"/>) is calendar-insensitive; it compares the two
            values historically in terms of when they actually occurred, as if they're both converted to some "neutral" calendar system first.
            </para>
            <para>
            It's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,
            it would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly
            consider which calendar system they're working in anyway.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(NodaTime.LocalInstant)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO
            calendar system.
            </summary>
            <param name="localInstant">The local instant.</param>
            <returns>The resulting date/time.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(NodaTime.LocalInstant,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="localInstant">The local instant.</param>
            <param name="calendar">The calendar system.</param>
            <returns>The resulting date/time.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="calendar">The calendar.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="calendar">The calendar.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <param name="calendar">The calendar.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <param name="tickWithinMillisecond">The tick within millisecond.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <param name="tickWithinMillisecond">The tick within millisecond.</param>
            <param name="calendar">The calendar.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="P:NodaTime.LocalDateTime.Calendar">
            <summary>Gets the calendar system associated with this local date and time.</summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.CenturyOfEra">
            <summary>Gets the century within the era of this local date and time.</summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Year">
            <summary>Gets the year of this local date and time.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
        </member>
        <member name="P:NodaTime.LocalDateTime.YearOfCentury">
            <summary>Gets the year of this local date and time within its century.</summary>
            <remarks>This always returns a value in the range 0 to 99 inclusive.</remarks>
        </member>
        <member name="P:NodaTime.LocalDateTime.YearOfEra">
            <summary>Gets the year of this local date and time within its era.</summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Era">
            <summary>Gets the era of this local date and time.</summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.WeekYear">
            <summary>
            Gets the "week year" of this local date and time.
            </summary>
            <remarks>
            <para>
            The WeekYear is the year that matches with the <see cref="P:NodaTime.LocalDateTime.WeekOfWeekYear"/> field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day.
            </para>
            <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.LocalDateTime.Month">
            <summary>
            Gets the month of this local date and time within the year.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.WeekOfWeekYear">
            <summary>
            Gets the week within the WeekYear. See <see cref="P:NodaTime.LocalDateTime.WeekYear"/> for more details.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.DayOfYear">
            <summary>
            Gets the day of this local date and time within the year.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Day">
            <summary>
            Gets the day of this local date and time within the month.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.IsoDayOfWeek">
            <summary>
            Gets the week day of this local date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value,
            for calendars which use ISO days of the week.
            </summary>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <seealso cref="P:NodaTime.LocalDateTime.DayOfWeek"/>
        </member>
        <member name="P:NodaTime.LocalDateTime.DayOfWeek">
            <summary>
            Gets the week day of this local date and time as a number.
            </summary>
            <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
            <seealso cref="P:NodaTime.LocalDateTime.IsoDayOfWeek"/>
        </member>
        <member name="P:NodaTime.LocalDateTime.Hour">
            <summary>
            Gets the hour of day of this local date and time, in the range 0 to 23 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this local date and time, in the range 1 to 12 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Minute">
            <summary>
            Gets the minute of this local date and time, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Second">
            <summary>
            Gets the second of this local date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Millisecond">
            <summary>
            Gets the millisecond of this local date and time within the second, in the range 0 to 999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.TickOfSecond">
            <summary>
            Gets the tick of this local time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.TickOfDay">
            <summary>
            Gets the tick of this local date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.TimeOfDay">
            <summary>
            Gets the time portion of this local date and time as a <see cref="T:NodaTime.LocalTime"/>.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.Date">
            <summary>
            Gets the date portion of this local date and time as a <see cref="T:NodaTime.LocalDate"/> in the same calendar system as this value.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDateTime.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this value which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Unspecified"/>.
            </summary>
            <remarks>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </remarks>
            <returns>A <see cref="T:System.DateTime"/> value for the same date and time as this value.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime" /> of any kind to a LocalDateTime in the ISO calendar. This does not perform
            any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/>
            will still have the same day/hour/minute etc - it won't be converted into the local system time.
            </summary>
            <param name="dateTime">Value to convert into a Noda Time local date and time</param>
            <returns>A new <see cref="T:NodaTime.LocalDateTime"/> with the same values as the specified <c>DateTime</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Equality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_LessThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Compares two LocalDateTime values to see if the left one is strictly earlier than the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_LessThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Compares two LocalDateTime values to see if the left one is earlier than or equal to the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_GreaterThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Compares two LocalDateTime values to see if the left one is strictly later than the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_GreaterThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Compares two LocalDateTime values to see if the left one is later than or equal to the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)">
            <summary>
            Indicates whether this date/time is earlier, later or the same as another one.
            </summary>
            <remarks>
            The comparison is performed in terms of a calendar-independent notion of dates and times;
            the calendar systems of both <see cref="T:NodaTime.LocalDateTime" /> values are ignored. When both values use the same calendar,
            this is absolutely natural. However, when comparing a value in one calendar with a value in another,
            this can lead to surprising results. For example, 1945 in the ISO calendar corresponds to around 1364
            in the Islamic calendar, so an Islamic date in year 1400 is "after" a date in 1945 in the ISO calendar.
            </remarks>
            <param name="other">The other local date/time to compare with this value.</param>
            <returns>A value less than zero if this date/time is earlier than <paramref name="other"/>;
            zero if this date/time is the same as <paramref name="other"/>; a value greater than zero if this date/time is
            later than <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two LocalDateTimes.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.LocalDateTime"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this LocalDateTime with another one; see <see cref="M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Addition(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Adds a period to a local date/time. Fields are added in the order provided by the period.
            This is a convenience operator over the <see cref="M:NodaTime.LocalDateTime.Plus(NodaTime.Period)"/> method.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to add</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Add(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Add the specified period to the date and time. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to add</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Plus(NodaTime.Period)">
            <summary>
            Adds a period to this local date/time. Fields are added in the order provided by the period.
            </summary>
            <param name="period">Period to add</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Subtraction(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Subtracts a period from a local date/time. Fields are subtracted in the order provided by the period.
            This is a convenience operator over the <see cref="M:NodaTime.LocalDateTime.Minus(NodaTime.Period)"/> method.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to subtract</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Subtract(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Subtracts the specified period from the date and time. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to subtract</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Minus(NodaTime.Period)">
            <summary>
            Subtracts a period from a local date/time. Fields are subtracted in the order provided by the period.
            This is a convenience operator over the <see cref="M:NodaTime.LocalDateTime.Minus(NodaTime.Period)"/> method.
            </summary>
            <param name="period">Period to subtract</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a new LocalDateTime representing the same physical date and time, but in a different calendar.
            The returned LocalDateTime is likely to have different date field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
            <param name="calendarSystem">The calendar system to convert this local date to.</param>
            <returns>The converted LocalDateTime.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusYears(System.Int32)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of years added.
            </summary>
            <remarks>
            If the resulting date is invalid, lower fields (typically the day of month) are reduced to find a valid value.
            For example, adding one year to February 29th 2012 will return February 28th 2013; subtracting one year from
            February 29th 2012 will return February 28th 2011.
            </remarks>
            <param name="years">The number of years to add</param>
            <returns>The current value plus the given number of years.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusMonths(System.Int32)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of months added.
            </summary>
            <remarks>
            <para>
            This method does not try to maintain the year of the current value, so adding four months to a value in 
            October will result in a value in the following February.
            </para>
            <para>
            If the resulting date is invalid, the day of month is reduced to find a valid value.
            For example, adding one month to January 30th 2011 will return February 28th 2011; subtracting one month from
            March 30th 2011 will return February 28th 2011.
            </para>
            </remarks>
            <param name="months">The number of months to add</param>
            <returns>The current value plus the given number of months.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusDays(System.Int32)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of days added.
            </summary>
            <remarks>
            <para>
            This method does not try to maintain the month or year of the current value, so adding 3 days to a value on January 30th
            will result in a value on February 2nd.
            </para>
            </remarks>
            <param name="days">The number of days to add</param>
            <returns>The current value plus the given number of days.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusWeeks(System.Int32)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of weeks added.
            </summary>
            <param name="weeks">The number of weeks to add</param>
            <returns>The current value plus the given number of weeks.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusHours(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of hours added.
            </summary>
            <param name="hours">The number of hours to add</param>
            <returns>The current value plus the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusMinutes(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of minutes added.
            </summary>
            <param name="minutes">The number of minutes to add</param>
            <returns>The current value plus the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusSeconds(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of seconds added.
            </summary>
            <param name="seconds">The number of seconds to add</param>
            <returns>The current value plus the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusMilliseconds(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of milliseconds added.
            </summary>
            <param name="milliseconds">The number of milliseconds to add</param>
            <returns>The current value plus the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusTicks(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of ticks added.
            </summary>
            <param name="ticks">The number of ticks to add</param>
            <returns>The current value plus the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Next(NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the next <see cref="T:NodaTime.LocalDateTime" /> falling on the specified <see cref="P:NodaTime.LocalDateTime.IsoDayOfWeek"/>,
            at the same time of day as this value.
            This is a strict "next" - if this value on already falls on the target
            day of the week, the returned value will be a week later.
            </summary>
            <param name="targetDayOfWeek">The ISO day of the week to return the next date of.</param>
            <returns>The next <see cref="T:NodaTime.LocalDateTime"/> falling on the specified day of the week.</returns>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetDayOfWeek"/> is not a valid day of the
            week (Monday to Sunday).</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.Previous(NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the previous <see cref="T:NodaTime.LocalDateTime" /> falling on the specified <see cref="P:NodaTime.LocalDateTime.IsoDayOfWeek"/>,
            at the same time of day as this value.
            This is a strict "previous" - if this value on already falls on the target
            day of the week, the returned value will be a week earlier.
            </summary>
            <param name="targetDayOfWeek">The ISO day of the week to return the previous date of.</param>
            <returns>The previous <see cref="T:NodaTime.LocalDateTime"/> falling on the specified day of the week.</returns>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetDayOfWeek"/> is not a valid day of the
            week (Monday to Sunday).</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.WithOffset(NodaTime.Offset)">
            <summary>
            Returns an <see cref="T:NodaTime.OffsetDateTime"/> for this local date/time with the given offset.
            </summary>
            <remarks>This method is purely a convenient alternative to calling the <see cref="T:NodaTime.OffsetDateTime"/> constructor directly.</remarks>
            <param name="offset">The offset to apply.</param>
            <returns>The result of this local date/time offset by the given amount.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.InUtc">
            <summary>
            Returns the mapping of this local date/time within <see cref="P:NodaTime.DateTimeZone.Utc"/>.
            </summary>
            <remarks>As UTC is a fixed time zone, there is no chance that this local date/time is ambiguous or skipped.</remarks>
            <returns>The result of mapping this local date/time in UTC.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)">
            <summary>
            Returns the mapping of this local date/time within the given <see cref="T:NodaTime.DateTimeZone" />,
            with "strict" rules applied such that an exception is thrown if either the mapping is
            ambiguous or the time is skipped.
            </summary>
            <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)"/> and <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> for alternative ways to map a local time to a
            specific instant.
            This is solely a convenience method for calling <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)" />.
            </remarks>
            <param name="zone">The time zone in which to map this local date/time.</param>
            <exception cref="T:NodaTime.SkippedTimeException">This local date/time is skipped in the given time zone.</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">This local date/time is ambiguous in the given time zone.</exception>
            <returns>The result of mapping this local date/time in the given time zone.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)">
            <summary>
            Returns the mapping of this local date/time within the given <see cref="T:NodaTime.DateTimeZone" />,
            with "lenient" rules applied such that ambiguous values map to the
            later of the alternatives, and "skipped" values map to the start of the zone interval
            after the "gap".
            </summary>
            <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)"/> and <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> for alternative ways to map a local time to a
            specific instant.
            This is solely a convenience method for calling <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)" />.
            </remarks>
            <param name="zone">The time zone in which to map this local date/time.</param>
            <returns>The result of mapping this local date/time in the given time zone.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)">
            <summary>
            Resolves this local date and time into a <see cref="T:NodaTime.ZonedDateTime"/> in the given time zone, following
            the given <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> to handle ambiguity and skipped times.
            </summary>
            <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)"/> and <see cref="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)"/> for alternative ways to map a local time
            to a specific instant.
            This is a convenience method for calling <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/>.
            </remarks>
            <param name="zone">The time zone to map this local date and time into</param>
            <param name="resolver">The resolver to apply to the mapping.</param>
            <returns>The result of resolving the mapping.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.LocalDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.DateTimeZone">
            <summary>
            Represents a time zone - a mapping between UTC and local time. A time zone maps UTC instants to local times
             - or, equivalently, to the offset from UTC at any particular instant.
            </summary>
            <remarks>
            <para>
            The mapping is unambiguous in the "UTC to local" direction, but
            the reverse is not true: when the offset changes, usually due to a Daylight Saving transition,
            the change either creates a gap (a period of local time which never occurs in the time zone)
            or an ambiguity (a period of local time which occurs twice in the time zone). Mapping back from
            local time to an instant requires consideration of how these problematic times will be handled.
            </para>
            <para>
            Noda Time provides various options when mapping local time to a specific instant:
            <list type="bullet">
              <item>
                <description><see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)"/> will throw an exception if the mapping from local time is either ambiguous
                or impossible, i.e. if there is anything other than one instant which maps to the given local time.</description>
              </item>
              <item>
                <description><see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)"/> will never throw an exception due to ambiguous or skipped times,
                resolving to the later option of ambiguous matches or the start of the zone interval after the gap for
                skipped times.</description>
              </item>
              <item>
                <description><see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> will apply a <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> to the result of
                a mapping.</description>
              </item>
              <item>
                <description><see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)"/> will return a <see cref="T:NodaTime.TimeZones.ZoneLocalMapping"/>
                with complete information about whether the given local time occurs zero times, once or twice. This is the most
                fine-grained approach, which is the fiddliest to use but puts the caller in the most control.</description>
              </item>
            </list>
            </para>
            <para>
            Noda Time has two built-in sources of time zone data available: a copy of the
            <a href="http://www.iana.org/time-zones">tz database</a> (also known as the IANA Time Zone database, or zoneinfo
            or Olson database), and the ability to convert .NET's own <see cref="T:System.TimeZoneInfo"/> format into a "native" Noda
            Time zone. Which of these is most appropriate for you to use will very much depend on your exact needs. The
            zoneinfo database is widely used outside Windows, and has more historical data than the Windows-provided
            information, but if you need to interoperate with other Windows systems by specifying time zone IDs, you may
            wish to stick to the Windows time zones.
            </para>
            <para>
            To obtain a <see cref="T:NodaTime.DateTimeZone"/> for a given timezone ID, use one of the methods on
            <see cref="T:NodaTime.IDateTimeZoneProvider"/> (and see <see cref="T:NodaTime.DateTimeZoneProviders"/> for access to the built-in
            providers). The UTC timezone is also available via the <see cref="P:NodaTime.DateTimeZone.Utc"/> property on this class.
            </para>
            <para>
            To obtain a <see cref="T:NodaTime.DateTimeZone"/> representing the system default time zone, you can either call
            <see cref="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault"/> on a provider to obtain the <see cref="T:NodaTime.DateTimeZone"/> that
            the provider considers matches the system default time zone, or you can construct a
            <c>BclDateTimeZone</c> via <c>BclDateTimeZone.ForSystemDefault</c>, which returns a
            <see cref="T:NodaTime.DateTimeZone"/> that wraps the system local <see cref="T:System.TimeZoneInfo"/>. The latter will always
            succeed, but has access only to that information available via the .NET time zone; the former may contain more
            complete data, but may (in uncommon cases) fail to find a matching <see cref="T:NodaTime.DateTimeZone"/>.
            Note that <c>BclDateTimeZone</c> is not available on the PCL build of Noda Time, so this fallback strategy can
            only be used with the desktop version.
            </para>
            <para>Note that Noda Time does not require that <see cref="T:NodaTime.DateTimeZone"/> instances be singletons.
            As far as reasonably possible, implementations should implement <see cref="T:System.IEquatable`1"/> in such a way
            that equivalent time zones compare as equal.</para>
            </remarks>
            <threadsafety>
            All time zone implementations within Noda Time are immutable and thread-safe.
            See the thread safety section of the user guide for more information.
            It is expected that third party implementations will be immutable and thread-safe as well:
            code within Noda Time assumes that it can hand out time zones to any thread without any concerns. If you
            implement a non-thread-safe time zone, you will need to use it extremely carefully. We'd recommend that you
            avoid this if possible.
            </threadsafety>
        </member>
        <member name="F:NodaTime.DateTimeZone.UtcId">
            <summary>
            The ID of the UTC (Coordinated Universal Time) time zone. This ID is always valid, whatever provider is
            used. If the provider has its own mapping for UTC, that will be returned by <see cref="M:NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)" />, but otherwise
            the value of the <see cref="P:NodaTime.DateTimeZone.Utc"/> property will be returned.
            </summary>
        </member>
        <member name="P:NodaTime.DateTimeZone.Utc">
            <summary>
            Gets the UTC (Coordinated Universal Time) time zone. This is a single instance which is not
            provider-specific; it is guaranteed to have the ID "UTC", but may or may not be the instance returned by
            e.g. <c>DateTimeZoneProviders.Tzdb["UTC"]</c>.
            </summary>
            <value>A UTC <see cref="T:NodaTime.DateTimeZone" />.</value>
        </member>
        <member name="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)">
            <summary>
            Returns a fixed time zone with the given offset.
            </summary>
            <remarks>
            <para>
            The returned time zone will have an ID of "UTC" if the offset is zero, or "UTC+/-Offset"
            otherwise. In the former case, the returned instance will be equal to <see cref="P:NodaTime.DateTimeZone.Utc"/>.
            </para>
            <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone"/> instance for
            successive requests for the same offset; however, all instances returned for a given offset will compare
            as equal.
            </para>
            </remarks>
            <param name="offset">The offset for the returned time zone</param>
            <returns>A fixed time zone with the given offset.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.#ctor(System.String,System.Boolean,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.DateTimeZone" /> class.
            </summary>
            <param name="id">The unique id of this time zone.</param>
            <param name="isFixed">Set to <c>true</c> if this time zone has no transitions.</param>
            <param name="minOffset">Minimum offset applied within this zone</param>
            <param name="maxOffset">Maximum offset applied within this zone</param>
        </member>
        <member name="P:NodaTime.DateTimeZone.Id">
            <summary>
            The provider's ID for the time zone.
            </summary>
            <remarks>
            <para>
            This identifies the time zone within the current time zone provider; a different provider may
            provide a different time zone with the same ID, or may not provide a time zone with that ID at all.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.DateTimeZone.IsFixed">
            <summary>
            Indicates whether the time zone is fixed, i.e. contains no transitions.
            </summary>
            <remarks>
            This is used as an optimization. If the time zone has no transitions but returns <c>false</c>
            for this then the behavior will be correct but the system will have to do extra work. However
            if the time zone has transitions and this returns <c>true</c> then the transitions will never
            be examined.
            </remarks>
        </member>
        <member name="P:NodaTime.DateTimeZone.MinOffset">
            <summary>
            Returns the least (most negative) offset within this time zone, over all time.
            </summary>
        </member>
        <member name="P:NodaTime.DateTimeZone.MaxOffset">
            <summary>
            Returns the greatest (most positive) offset within this time zone, over all time.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)">
            <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is
            later than UTC. In other words, local time = UTC + offset.
            </summary>
            <remarks>
            This is mostly a convenience method for calling <c>GetZoneInterval(instant).WallOffset</c>,
            although it can also be overridden for more efficiency.
            </remarks>
            <param name="instant">The instant for which to calculate the offset.</param>
            <returns>
            The offset from UTC at the specified instant.
            </returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone interval for the given instant; the range of time around the instant in which the same Offset
            applies (with the same split between standard time and daylight saving time, and with the same offset).
            </summary>
            <remarks>
            This will always return a valid zone interval, as time zones cover the whole of time.
            </remarks>
            <param name="instant">The <see cref="T:NodaTime.Instant" /> to query.</param>
            <returns>The defined <see cref="T:NodaTime.TimeZones.ZoneInterval" />.</returns>
            <seealso cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)"/>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneIntervalPair(NodaTime.LocalInstant)">
            <summary>
            Finds all zone intervals for the given local instant. Usually there's one (i.e. only a single
            instant is mapped to the given local instant within the time zone) but during DST transitions
            there can be either 0 (the given local instant doesn't exist, e.g. local time skipped from 1am to
            2am, but you gave us 1.30am) or 2 (the given local instant is ambiguous, e.g. local time skipped
            from 2am to 1am, but you gave us 1.30am).
            </summary>
            <remarks>
            This method is implemented in terms of GetZoneInterval(Instant) within DateTimeZone,
            and should work for any zone. However, internal derived classes may override this method
            for optimization purposes, e.g. if the zone interval is always ambiguous with
            a fixed value.
            </remarks>
            <param name="localInstant">The local instant to find matching zone intervals for</param>
            <returns>The struct containing up to two ZoneInterval references.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)">
            <summary>
            Returns the earliest valid <see cref="T:NodaTime.ZonedDateTime"/> with the given local date.
            </summary>
            <remarks>
            If midnight exists unambiguously on the given date, it is returned.
            If the given date has an ambiguous start time (e.g. the clocks go back from 1am to midnight)
            then the earlier ZonedDateTime is returned. If the given date has no midnight (e.g. the clocks
            go forward from midnight to 1am) then the earliest valid value is returned; this will be the instant
            of the transition.
            </remarks>
            <param name="date">The local date to map in this time zone.</param>
            <exception cref="T:NodaTime.SkippedTimeException">The entire day was skipped due to a very large time zone transition.
            (This is extremely rare.)</exception>
            <returns>The <see cref="T:NodaTime.ZonedDateTime"/> representing the earliest time in the given date, in this time zone.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)">
            <summary>
            Returns complete information about how the given <see cref="T:NodaTime.LocalDateTime" /> is mapped in this time zone.
            </summary>
            <remarks>
            <para>
            Mapping a local date/time to a time zone can give an unambiguous, ambiguous or impossible result, depending on
            time zone transitions. Use the return value of this method to handle these cases in an appropriate way for
            your use case.
            </para>
            <para>
            As an alternative, consider <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/>, which uses a caller-provided strategy to
            convert the <see cref="T:NodaTime.TimeZones.ZoneLocalMapping"/> returned here to a <see cref="T:NodaTime.ZonedDateTime"/>.
            </para>
            </remarks>
            <param name="localDateTime">The local date and time to map in this time zone.</param>
            <returns>A mapping of the given local date and time to zero, one or two zoned date/time values.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)">
            <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime"/> to the corresponding <see cref="T:NodaTime.ZonedDateTime"/>, following
            the given <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> to handle ambiguity and skipped times.
            </summary>
            <remarks>
            <para>
            This is a convenience method for calling <see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)"/> and passing the result to the resolver.
            Common options for resolvers are provided in the static <see cref="T:NodaTime.TimeZones.Resolvers"/> class.
            </para>
            <para>
            See <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)"/> and <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)"/> for alternative ways to map a local time to a
            specific instant.
            </para>
            </remarks>
            <param name="localDateTime">The local date and time to map in this time zone.</param>
            <param name="resolver">The resolver to apply to the mapping.</param>
            <returns>The result of resolving the mapping.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)">
            <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime"/> to the corresponding <see cref="T:NodaTime.ZonedDateTime"/>, if and only if
            that mapping is unambiguous in this time zone.  Otherwise, <see cref="T:NodaTime.SkippedTimeException"/> or
            <see cref="T:NodaTime.AmbiguousTimeException"/> is thrown, depending on whether the mapping is ambiguous or the local
            date/time is skipped entirely.
            </summary>
            <remarks>
            See <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)"/> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> for alternative ways to map a local time to a
            specific instant.
            </remarks>
            <param name="localDateTime">The local date and time to map into this time zone.</param>
            <exception cref="T:NodaTime.SkippedTimeException">The given local date/time is skipped in this time zone.</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">The given local date/time is ambiguous in this time zone.</exception>
            <returns>The unambiguous matching <see cref="T:NodaTime.ZonedDateTime"/> if it exists.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)">
            <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime"/> to the corresponding <see cref="T:NodaTime.ZonedDateTime"/> in a lenient
            manner: ambiguous values map to the later of the alternatives, and "skipped" values map to the start of the
            zone interval after the "gap".
            </summary>
            <remarks>
            See <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)"/> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> for alternative ways to map a local time to a
            specific instant.
            </remarks>
            <param name="localDateTime">The local date/time to map.</param>
            <returns>The unambiguous mapping if there is one, the later result if the mapping is ambiguous,
            or the start of the later zone interval if the given local date/time is skipped.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetEarlierMatchingInterval(NodaTime.TimeZones.ZoneInterval,NodaTime.LocalInstant)">
            <summary>
            Returns the interval before this one, if it contains the given local instant, or null otherwise.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetLaterMatchingInterval(NodaTime.TimeZones.ZoneInterval,NodaTime.LocalInstant)">
            <summary>
            Returns the next interval after this one, if it contains the given local instant, or null otherwise.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.ToString">
            <summary>
            Returns the ID of this time zone.
            </summary>
            <returns>
            The ID of this time zone.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.DateTimeZone.BuildFixedZoneCache">
            <summary>
            Creates a fixed time zone for offsets -23.5 to +23.5 at every half hour,
            fixing the 0 offset as DateTimeZone.Utc.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)">
            <summary>
            Determines whether the specified <see cref="T:NodaTime.DateTimeZone"/> is equal to this instance.
            </summary>
            <remarks>
            This implementation performs initial checks which would be common to all child implementations,
            and then delegates to <see cref="M:NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)"/>.
            </remarks>
            <param name="obj">The <see cref="T:NodaTime.DateTimeZone"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:NodaTime.DateTimeZone"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)">
            <summary>
            Implements equality in derived classes.
            </summary>
            <param name="zone">The zone to compare with this one. This is guaranteed (when called by <see cref="M:NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)"/>) to
            be a non-null reference of the same type as this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:NodaTime.DateTimeZone"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Returns all the zone intervals which occur for any instant in the interval [<paramref name="start"/>, <paramref name="end"/>).
            </summary>
            <remarks>
            <para>This method is simply a convenience method for calling <see cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)"/> without
            explicitly constructing the interval beforehand.
            </para>
            </remarks>
            <param name="start">Inclusive start point of the interval for which to retrieve zone intervals.</param>
            <param name="end">Exclusive end point of the interval for which to retrieve zone intervals.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="end"/> is earlier than <paramref name="start"/>.</exception>
            <returns>A sequence of zone intervals covering the given interval.</returns>
            <seealso cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)"/>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)">
            <summary>
            Returns all the zone intervals which occur for any instant in the given interval.
            </summary>
            <remarks>
            <para>The zone intervals are returned in chronological order. This method is equivalent to calling <see cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)"/> for every
            instant in the interval and then collapsing to a set of distinct zone intervals.
            The first and last zone intervals are likely to also cover instants outside the given interval;
            the zone intervals returned are not truncated to match the start and end points.
            </para>
            </remarks>
            <param name="interval">Interval to find zone intervals for.</param>
            <returns>A sequence of zone intervals covering the given interval.</returns>
            <seealso cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)"/>
        </member>
        <member name="T:NodaTime.Duration">
            <summary>
            Represents a fixed (and calendar-independent) length of time.
            </summary>
            <remarks>
            <para>
            A duration is a length of time defined by an integral number of 'ticks', where a tick is equal to 100
            nanoseconds. There are 10,000 ticks in a millisecond.
            Although durations are usually used with a positive number of ticks, negative durations are valid, and may occur
            naturally when e.g. subtracting an earlier <see cref="T:NodaTime.Instant"/> from a later one.
            </para>
            <para>
            A duration represents a fixed length of elapsed time along the time line that occupies the same amount of
            time regardless of when it is applied.  In contrast, <see cref="T:NodaTime.Period"/> represents a period of time in
            calendrical terms (hours, days, and so on) that may vary in elapsed time when applied.
            </para>
            <para>
            In general, use <see cref="T:NodaTime.Duration"/> to represent durations applied to global types like <see cref="T:NodaTime.Instant"/>
            and <see cref="T:NodaTime.ZonedDateTime"/>; use <c>Period</c> to represent a period applied to local types like
            <see cref="T:NodaTime.LocalDateTime"/>.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Duration.Zero">
            <summary>
            Represents the zero <see cref="T:NodaTime.Duration"/> value. 
            This field is read-only.
            </summary>
        </member>
        <member name="F:NodaTime.Duration.Epsilon">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to 1 tick; the smallest amount by which an instant can vary.
            This field is read-only.
            </summary>
        </member>
        <member name="F:NodaTime.Duration.OneStandardWeek">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 standard week (7 days).
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 6,048,000,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneStandardDay">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 day.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 864 billion ticks; that is, 864,000,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneHour">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 hour.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 36 billion ticks; that is, 36,000,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneMinute">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 minute.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 600 million ticks; that is, 600,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneSecond">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 second.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 10 million ticks; that is, 10,000,000 ticks.
            </remarks>
        </member>
        <member name="F:NodaTime.Duration.OneMillisecond">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equals to number of ticks in 1 millisecond.
            This field is constant.
            </summary>
            <remarks>
            The value of this constant is 10 thousand ticks; that is, 10,000 ticks.
            </remarks>
        </member>
        <member name="M:NodaTime.Duration.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Duration"/> struct.
            </summary>
            <param name="ticks">The number of ticks.</param>
        </member>
        <member name="P:NodaTime.Duration.Ticks">
            <summary>
            The total number of ticks in the duration.
            </summary>
            <remarks>
            This property effectively represents all of the information within a Duration value; a duration
            is simply a number of ticks.
            </remarks>
        </member>
        <member name="M:NodaTime.Duration.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Duration.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("o"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("o").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Duration.op_Addition(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator + (addition).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Add(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Adds one duration to another. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Plus(NodaTime.Duration)">
            <summary>
            Returns the result of adding another duration to this one, for a fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="other">The duration to add</param>
            <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Subtraction(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator - (subtraction).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Subtract(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Subtracts one duration from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Minus(NodaTime.Duration)">
            <summary>
            Returns the result of subtracting another duration from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="other">The duration to subtract</param>
            <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Division(NodaTime.Duration,System.Int64)">
            <summary>
            Implements the operator / (division).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of dividing <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.Divide(NodaTime.Duration,System.Int64)">
            <summary>
            Divides a duration by a number. Friendly alternative to <c>operator/()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of dividing <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Multiply(NodaTime.Duration,System.Int64)">
            <summary>
            Implements the operator * (multiplication).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of multiplying <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Multiply(System.Int64,NodaTime.Duration)">
            <summary>
            Implements the operator * (multiplication).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of multiplying <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.Multiply(NodaTime.Duration,System.Int64)">
            <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the product of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Multiply(System.Int64,NodaTime.Duration)">
            <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the product of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Equality(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Inequality(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_LessThan(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_LessThanOrEqual(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_GreaterThan(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_GreaterThanOrEqual(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_UnaryNegation(NodaTime.Duration)">
            <summary>
            Implements the unary negation operator.
            </summary>
            <param name="duration">Duration to negate</param>
            <returns>The negative value of this duration</returns>
        </member>
        <member name="M:NodaTime.Duration.Negate(NodaTime.Duration)">
            <summary>
            Implements a friendly alternative to the unary negation operator.
            </summary>
            <param name="duration">Duration to negate</param>
            <returns>The negative value of this duration</returns>
        </member>
        <member name="M:NodaTime.Duration.CompareTo(NodaTime.Duration)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term>&lt; 0</term>
            <description>This object is less than the <paramref name="other"/> parameter.</description>
            </item>
            <item>
            <term>0</term>
            <description>This object is equal to <paramref name="other"/>.</description>
            </item>
            <item>
            <term>&gt; 0</term>
            <description>This object is greater than <paramref name="other"/>.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:NodaTime.Duration.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two offsets.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.Duration"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this instant with another one; see <see cref="M:NodaTime.Duration.CompareTo(NodaTime.Duration)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.Equals(NodaTime.Duration)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.FromStandardWeeks(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of weeks, assuming a 'standard' week
            consisting of seven 24-hour days.
            </summary>
            <param name="weeks">The number of weeks.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of weeks.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromStandardDays(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of days, assuming a 'standard' 24-hour
            day.
            </summary>
            <param name="days">The number of days.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of days.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromHours(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of hours.
            </summary>
            <param name="hours">The number of hours.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromMinutes(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of minutes.
            </summary>
            <param name="minutes">The number of minutes.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromSeconds(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of seconds.
            </summary>
            <param name="seconds">The number of seconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromMilliseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of milliseconds.
            </summary>
            <param name="milliseconds">The number of milliseconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromTicks(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of ticks.
            </summary>
            <param name="ticks">The number of ticks.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromTimeSpan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the same number of ticks as the
            given <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="timeSpan">The TimeSpan value to convert</param>
            <returns>A new Duration with the same number of ticks as the given TimeSpan.</returns>
        </member>
        <member name="M:NodaTime.Duration.ToTimeSpan">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> that represents the same number of ticks as this
            <see cref="T:NodaTime.Duration"/>.
            </summary>
            <returns>A new TimeSpan with the same number of ticks as this Duration.</returns>
        </member>
        <member name="M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Duration.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.Duration.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.Instant">
            <summary>
            Represents an instant on the global timeline.
            </summary>
            <remarks>
            <para>
            An instant is defined by an integral number of 'ticks' since the Unix epoch (typically described as January 1st
            1970, midnight, UTC, ISO calendar), where a tick is equal to 100 nanoseconds. There are 10,000 ticks in a
            millisecond.
            </para>
            <para>
            An <see cref="T:NodaTime.Instant"/> has no concept of a particular time zone or calendar: it simply represents a point in
            time that can be globally agreed-upon.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Instant.MinValue">
            <summary>
            Represents the smallest possible <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>
            Within Noda Time, this is also used to represent 'the beginning of time'.
            </remarks>
        </member>
        <member name="F:NodaTime.Instant.MaxValue">
            <summary>
            Represents the largest possible <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>
            Within Noda Time, this is also used to represent 'the end of time'.
            </remarks>
        </member>
        <member name="M:NodaTime.Instant.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct.
            </summary>
            <remarks>
            Note that while the Noda Time <see cref="T:NodaTime.Instant"/> type and BCL <see cref="T:System.DateTime"/> and
            <see cref="T:System.DateTimeOffset"/> types are all defined in terms of a number of ticks, they use different
            origins: the Noda Time types count ticks from the Unix epoch (the start of 1970 AD), while the BCL types
            count from the start of 1 AD. This constructor requires the former; to convert from a number-of-ticks since
            the BCL epoch, construct a <see cref="T:System.DateTime"/> first, then use <see cref="M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)"/>.
            </remarks>
            <param name="ticks">The number of ticks since the Unix epoch. Negative values represent instants before the
            Unix epoch.</param>
        </member>
        <member name="P:NodaTime.Instant.Ticks">
            <summary>
            The number of ticks since the Unix epoch. Negative values represent instants before the Unix epoch.
            </summary>
            <remarks>
            A tick is equal to 100 nanoseconds. There are 10,000 ticks in a millisecond.
            </remarks>
        </member>
        <member name="M:NodaTime.Instant.CompareTo(NodaTime.Instant)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              A 32-bit signed integer that indicates the relative order of the objects being compared.
              The return value has the following meanings:
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>&lt; 0</term>
                  <description>This object is less than the <paramref name = "other" /> parameter.</description>
                </item>
                <item>
                  <term>0</term>
                  <description>This object is equal to <paramref name = "other" />.</description>
                </item>
                <item>
                  <term>&gt; 0</term>
                  <description>This object is greater than <paramref name = "other" />.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="M:NodaTime.Instant.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two instants.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.Instant"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this instant with another one; see <see cref="M:NodaTime.Instant.CompareTo(NodaTime.Instant)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            <returns>
              A hash code for this instance, suitable for use in hashing algorithms and data
              structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Instant.PlusTicks(System.Int64)">
            <summary>
            Returns a new value of this instant with the given number of ticks added to it.
            </summary>
            <param name="ticksToAdd">The ticks to add to this instant to create the return value.</param>
            <returns>The result of adding the given number of ticks to this instant.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Addition(NodaTime.Instant,NodaTime.Duration)">
            <summary>
            Implements the operator + (addition) for <see cref="T:NodaTime.Instant" /> + <see cref="T:NodaTime.Duration" />.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Plus(NodaTime.Offset)">
            <summary>
            Adds the given offset to this instant, to return a <see cref="T:NodaTime.LocalInstant" />.
            </summary>
            <remarks>
            This was previously an operator+ implementation, but operators can't be internal.
            </remarks>
            <param name="offset">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.LocalInstant" /> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Add(NodaTime.Instant,NodaTime.Duration)">
            <summary>
            Adds a duration to an instant. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Plus(NodaTime.Duration)">
            <summary>
            Returns the result of adding a duration to this instant, for a fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="duration">The duration to add</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator - (subtraction) for <see cref="T:NodaTime.Instant" /> - <see cref="T:NodaTime.Instant" />.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Duration)">
            <summary>
            Implements the operator - (subtraction) for <see cref="T:NodaTime.Instant" /> - <see cref="T:NodaTime.Duration" />.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Subtracts one instant from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration" /> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Minus(NodaTime.Instant)">
            <summary>
            Returns the result of subtracting another instant from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="other">The other instant to subtract</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Duration)">
            <summary>
            Subtracts a duration from an instant. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Minus(NodaTime.Duration)">
            <summary>
            Returns the result of subtracting a duration from this instant, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="duration">The duration to subtract</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Equality(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Inequality(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_LessThan(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_LessThanOrEqual(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_GreaterThan(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_GreaterThanOrEqual(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new instant corresponding to the given UTC date and time in the ISO calendar.
            In most cases applications should use <see cref="T:NodaTime.ZonedDateTime" /> to represent a date
            and time, but this method is useful in some situations where an <see cref="T:NodaTime.Instant" /> is
            required, such as time zone testing.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="monthOfYear">The month of year.</param>
            <param name="dayOfMonth">The day of month.</param>
            <param name="hourOfDay">The hour.</param>
            <param name="minuteOfHour">The minute.</param>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the given date and time in UTC and the ISO calendar.</returns>
        </member>
        <member name="M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new instant corresponding to the given UTC date and
            time in the ISO calendar. In most cases applications should 
            use <see cref="T:NodaTime.ZonedDateTime" />
            to represent a date and time, but this method is useful in some 
            situations where an Instant is required, such as time zone testing.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="monthOfYear">The month of year.</param>
            <param name="dayOfMonth">The day of month.</param>
            <param name="hourOfDay">The hour.</param>
            <param name="minuteOfHour">The minute.</param>
            <param name="secondOfMinute">The second.</param>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the given date and time in UTC and the ISO calendar.</returns>
        </member>
        <member name="M:NodaTime.Instant.Max(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Returns the later instant of the given two.
            </summary>
            <param name="x">The first instant to compare.</param>
            <param name="y">The second instant to compare.</param>
            <returns>The later instant of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Instant.Min(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Returns the earlier instant of the given two.
            </summary>
            <param name="x">The first instant to compare.</param>
            <param name="y">The second instant to compare.</param>
            <returns>The earlier instant of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Instant.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("g"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("g").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Instant.Equals(NodaTime.Instant)">
            <summary>
            Indicates whether the value of this instant is equal to the value of the specified instant.
            </summary>
            <param name="other">The value to compare with this instance.</param>
            <returns>
            true if the value of this instant is equal to the value of the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.ToDateTimeUtc">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this Instant which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Utc"/> and represents the same instant of time as this value.
            </summary>
            <returns>A <see cref="T:System.DateTime"/> representing the same instant in time as this value, with a kind of "universal".</returns>
        </member>
        <member name="M:NodaTime.Instant.ToDateTimeOffset">
            <summary>
            Constructs a <see cref="T:System.DateTimeOffset"/> from this Instant which has an offset of zero.
            </summary>
            <returns>A <see cref="T:System.DateTimeOffset"/> representing the same instant in time as this value.</returns>
        </member>
        <member name="M:NodaTime.Instant.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Converts a <see cref="T:System.DateTimeOffset"/> into a new Instant representing the same instant in time. Note that
            the offset information is not preserved in the returned Instant.
            </summary>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the same instant in time as the given <see cref="T:System.DateTimeOffset"/>.</returns>
            <param name="dateTimeOffset">Date and time value with an offset.</param>
        </member>
        <member name="M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> into a new Instant representing the same instant in time.
            </summary>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the same instant in time as the given universal <see cref="T:System.DateTime"/>.</returns>
            <param name="dateTime">Date and time value which must have a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/></param>
            <exception cref="T:System.ArgumentException"><paramref name="dateTime"/> is not of <see cref="P:System.DateTime.Kind"/>
            <see cref="F:System.DateTimeKind.Utc"/>.</exception>
        </member>
        <member name="M:NodaTime.Instant.FromSecondsSinceUnixEpoch(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of seconds since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
            <param name="seconds">Number of seconds since the Unix epoch. May be negative (for instants before the epoch).</param>
            <returns>An <see cref="T:NodaTime.Instant"/> at exactly the given number of seconds since the Unix epoch.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The constructed instant would be out of the range representable in Noda Time.</exception>
        </member>
        <member name="M:NodaTime.Instant.FromMillisecondsSinceUnixEpoch(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of milliseconds since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
            <param name="milliseconds">Number of milliseconds since the Unix epoch. May be negative (for instants before the epoch).</param>
            <returns>An <see cref="T:NodaTime.Instant"/> at exactly the given number of milliseconds since the Unix epoch.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The constructed instant would be out of the range representable in Noda Time.</exception>
        </member>
        <member name="M:NodaTime.Instant.FromTicksSinceUnixEpoch(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of ticks since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
            <remarks>This is equivalent to calling the constructor directly, but indicates
            intent more explicitly.</remarks>
            <returns>An <see cref="T:NodaTime.Instant"/> at exactly the given number of ticks since the Unix epoch.</returns>
            <param name="ticks">Number of ticks since the Unix epoch. May be negative (for instants before the epoch).</param>
        </member>
        <member name="M:NodaTime.Instant.InUtc">
            <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime"/> representing the same point in time as this instant, in the UTC time
            zone and ISO-8601 calendar. This is a shortcut for calling <see cref="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone)" /> with an
            argument of <see cref="P:NodaTime.DateTimeZone.Utc"/>.
            </summary>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> for the same instant, in the UTC time zone
            and the ISO-8601 calendar</returns>
        </member>
        <member name="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone)">
            <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime"/> representing the same point in time as this instant, in the
            specified time zone and ISO-8601 calendar.
            </summary>
            <param name="zone">The time zone in which to represent this instant.</param>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> for the same instant, in the given time zone
            and the ISO-8601 calendar</returns>
        </member>
        <member name="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
            <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime"/> representing the same point in time as this instant, in the
            specified time zone and calendar system.
            </summary>
            <param name="zone">The time zone in which to represent this instant.</param>
            <param name="calendar">The calendar system in which to represent this instant.</param>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> for the same instant, in the given time zone
            and calendar</returns>
        </member>
        <member name="M:NodaTime.Instant.WithOffset(NodaTime.Offset)">
            <summary>
            Returns the <see cref="T:NodaTime.OffsetDateTime"/> representing the same point in time as this instant, with
            the specified UTC offset in the ISO calendar system.
            </summary>
            <param name="offset">The offset from UTC with which to represent this instant.</param>
            <returns>An <see cref="T:NodaTime.OffsetDateTime"/> for the same instant, with the given offset
            in the ISO calendar system</returns>
        </member>
        <member name="M:NodaTime.Instant.WithOffset(NodaTime.Offset,NodaTime.CalendarSystem)">
            <summary>
            Returns the <see cref="T:NodaTime.OffsetDateTime"/> representing the same point in time as this instant, with
            the specified UTC offset and calendar system.
            </summary>
            <param name="offset">The offset from UTC with which to represent this instant.</param>
            <param name="calendar">The calendar system in which to represent this instant.</param>
            <returns>An <see cref="T:NodaTime.OffsetDateTime"/> for the same instant, with the given offset
            and calendar</returns>
        </member>
        <member name="M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Instant.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.Instant.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.Interval">
            <summary>
            An interval between two instants in time (start and end).
            </summary>
            <remarks>
            <para>
            The interval includes the start instant and excludes the end instant, unless the end instant
            is <see cref="F:NodaTime.Instant.MaxValue"/> in which case it's deemed to be inclusive.
            (An interval stretching to infinity includes the end of time.)
            </para>
            <para>
            The end may equal the start (resulting in an empty interval), but will not be before the start.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Interval.start">
            <summary>The start of the interval.</summary>
        </member>
        <member name="F:NodaTime.Interval.end">
            <summary>The end of the interval. This will never be earlier than the start.</summary>
        </member>
        <member name="M:NodaTime.Interval.#ctor(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Interval"/> struct.
            The interval includes the <paramref name="start"/> instant and excludes the
            <paramref name="end"/> instant. The end may equal the start (resulting in an empty interval), but must not be before the start.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="end"/> is earlier than <paramref name="start"/>.</exception>
            <param name="start">The start <see cref="T:NodaTime.Instant"/>.</param>
            <param name="end">The end <see cref="T:NodaTime.Instant"/>.</param>
        </member>
        <member name="P:NodaTime.Interval.Start">
            <summary>
            Gets the start instant - the inclusive lower bound of the interval.
            </summary>
            <remarks>
            This will never be later than <see cref="P:NodaTime.Interval.End"/>, though it may be equal to it.
            </remarks>
            <value>The start <see cref="T:NodaTime.Instant"/>.</value>
        </member>
        <member name="P:NodaTime.Interval.End">
            <summary>
            Gets the end instant - the exclusive upper bound of the interval.
            </summary>
            <remarks>
            This will never be earlier than <see cref="P:NodaTime.Interval.Start"/>, though it may be equal to it.
            If this value is <see cref="F:NodaTime.Instant.MaxValue"/>, it is treated as an inclusive
            upper bound: an interval stretching to infinity includes the end of time.
            </remarks>
            <value>The end <see cref="T:NodaTime.Instant"/>.</value>
        </member>
        <member name="P:NodaTime.Interval.Duration">
            <summary>
            Returns the duration of the interval.
            </summary>
            <remarks>
            This will always be a non-negative duration, though it may be zero.
            </remarks>
            <value>The duration of the interval.</value>
        </member>
        <member name="M:NodaTime.Interval.Contains(NodaTime.Instant)">
            <summary>
            Returns whether or not this interval contains the given instant.
            </summary>
            <remarks>
            The interval is considered to include the <see cref="P:NodaTime.Interval.Start"/> instant but
            not the <see cref="P:NodaTime.Interval.End"/> instant - unless the end is <see cref="F:NodaTime.Instant.MaxValue"/>, in
            which case it's considered to be infinite from the start point onwards.
            </remarks>
            <param name="instant">Instant to test.</param>
            <returns>True if this interval contains the given instant; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Interval.Equals(NodaTime.Interval)">
            <summary>
            Indicates whether the value of this interval is equal to the value of the specified interval.
            </summary>
            <param name="other">The value to compare with this instance.</param>
            <returns>
            true if the value of this instant is equal to the value of the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Interval.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Interval.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Interval.ToString">
            <summary>
            Returns a string representation of this interval, in extended ISO-8601 format: the format
            is "start/end" where each instant uses a format of "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF'Z'".
            </summary>
            <returns>A string representation of this interval.</returns>
        </member>
        <member name="M:NodaTime.Interval.op_Equality(NodaTime.Interval,NodaTime.Interval)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.Interval.op_Inequality(NodaTime.Interval,NodaTime.Interval)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Interval.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.Interval.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:NodaTime.NodaConstants">
            <summary>
            Useful constants, mostly along the lines of "number of milliseconds in an hour".
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerMillisecond">
            <summary>
            A constant for the number of ticks in a millisecond. The value of this constant is 10,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerSecond">
            <summary>
            A constant for the number of ticks in a second. The value of this constant is 10,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerMinute">
            <summary>
            A constant for the number of ticks in a minute. The value of this constant is 600,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerHour">
            <summary>
            A constant for the number of ticks in an hour. The value of this constant is 36,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerStandardDay">
            <summary>
            A constant for the number of ticks in a standard 24-hour day.
            The value of this constant is 864,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerStandardWeek">
            <summary>
            A constant for the number of ticks in a standard week of seven 24-hour days.
            The value of this constant is 6,048,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerSecond">
            <summary>
            A constant for the number of milliseconds per second.
            The value of this constant is 1000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerMinute">
            <summary>
            A constant for the number of milliseconds per minute.
            The value of this constant is 60,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerHour">
            <summary>
            A constant for the number of milliseconds per hour.
            The value of this constant is 3,600,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerStandardDay">
            <summary>
            A constant for the number of milliseconds per standard 24-hour day.
            The value of this constant is 86,400,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerStandardWeek">
            <summary>
            A constant for the number of milliseconds per standard week of seven 24-hour days.
            The value of this constant is 604,800,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerMinute">
            <summary>
            A constant for the number of seconds per minute.
            The value of this constant is 60.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerHour">
            <summary>
            A constant for the number of seconds per hour.
            The value of this constant is 3,600.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerStandardDay">
            <summary>
            A constant for the number of seconds per standard 24-hour day.
            The value of this constant is 86,400.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerWeek">
            <summary>
            A constant for the number of seconds per standard week of seven 24-hour days.
            The value of this constant is 604,800.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerHour">
            <summary>
            A constant for the number of minutes per hour.
            The value of this constant is 60.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerStandardDay">
            <summary>
            A constant for the number of minutes per standard 24-hour day.
            The value of this constant is 1,440.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerStandardWeek">
            <summary>
            A constant for the number of minutes per standard week of seven 24-hour days.
            The value of this constant is 10,080.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.HoursPerStandardDay">
            <summary>
            A constant for the number of hours in a standard day. Note that the number of hours
            in a day can vary due to daylight saving effects.
            The value of this constant is 24.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.HoursPerStandardWeek">
            <summary>
            A constant for the number of hours in a standard week of seven 24-hour days.
            The value of this constant is 168.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.DaysPerStandardWeek">
            <summary>
            Number of days in a standard Gregorian week.
            The value of this constant is 7.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.UnixEpoch">
            <summary>
            The instant at the Unix epoch of midnight 1st January 1970 UTC.
            </summary>
            <remarks>
            This value is not only the Unix epoch, but the Noda Time epoch, as it represents the value
            with a <see cref="P:NodaTime.Instant.Ticks"/> property of 0.
            </remarks>
        </member>
        <member name="F:NodaTime.NodaConstants.BclEpoch">
            <summary>
            The instant at the BCL epoch of midnight 1st January 0001 UTC.
            </summary>
        </member>
        <member name="T:NodaTime.Utility.BclConversions">
            <summary>
            Conversion methods which don't naturally fit into any other types - for example, for
            enums which can't specify any other code. In most cases, conversions to and from BCL types
            are provided within the type itself - such as <see cref="M:NodaTime.LocalDateTime.ToDateTimeUnspecified"/>
            and <see cref="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)"/>.
            </summary>
            <remarks>
            Many of the methods within this class could be expressed as extension methods - but currently
            Noda Time always builds against .NET 2. In a future version, there may be multiple build targets,
            allowing these to become extension methods for the builds which use .NET 3.5 and higher.
            </remarks>
            <threadsafety>All members of this type are thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.Utility.BclConversions.ToDayOfWeek(NodaTime.IsoDayOfWeek)">
            <summary>
            Converts from the Noda Time <see cref="T:NodaTime.IsoDayOfWeek"/> enum to the equivalent BCL
            <see cref="T:System.DayOfWeek"/> value. Other than Sunday, the BCL and ISO values are the same -
            but ISO 8601 defines Sunday as day 7, and the BCL defines it as day 0.
            </summary>
            <param name="isoDayOfWeek">ISO day of week value to convert.</param>
            <returns>The ISO day of week value equivalent to the one passed in.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="isoDayOfWeek"/> parameter
            is not a valid day of the week.</exception>
        </member>
        <member name="M:NodaTime.Utility.BclConversions.ToIsoDayOfWeek(System.DayOfWeek)">
            <summary>
            Converts from the BCL <see cref="T:System.DayOfWeek"/> enum to the equivalent Noda Time <see cref="T:NodaTime.IsoDayOfWeek"/> value.
            Other than Sunday, the BCL and ISO values are the same - but ISO 8601 defines
            Sunday as day 7, and the BCL defines it as day 0.
            </summary>
            <param name="dayOfWeek">ISO day of week value to convert.</param>
            <returns>The BCL day of week value equivalent to the one passed in.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="dayOfWeek"/> parameter
            is not a valid day of the week.</exception>
        </member>
        <member name="T:NodaTime.Utility.HashCodeHelper">
            <summary>
            Provides method to help with generating hash codes for structures and classes. This handles
            value types, nullable type, and objects.
            </summary>
            <remarks>
            The basic usage pattern is:
            <example>
            <code>
               public override int GetHashCode()
               {
                   int hash = HashCodeHelper.Initialize();
                   hash = HashCodeHelper.Hash(hash, Field1);
                   hash = HashCodeHelper.Hash(hash, Field1);
                   hash = HashCodeHelper.Hash(hash, Field1);
                   ...
                   return hash;
               }
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:NodaTime.Utility.HashCodeHelper.HashcodeMultiplier">
            <summary>
            The multiplier for each value.
            </summary>
        </member>
        <member name="F:NodaTime.Utility.HashCodeHelper.HashcodeInitializer">
            <summary>
            The initial hash value.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.Initialize">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <returns>The initial interger value.</returns>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.Hash``1(System.Int32,``0)">
            <summary>
            Adds the hash value for the given value to the current hash and returns the new value.
            </summary>
            <typeparam name="T">The type of the value being hashed.</typeparam>
            <param name="code">The previous hash code.</param>
            <param name="value">The value to hash.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.MakeHash(System.Int32,System.Int32)">
            <summary>
            Adds the hash value for a int to the current hash value and returns the new value.
            </summary>
            <param name="code">The previous hash code.</param>
            <param name="value">The value to add to the hash code.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="T:NodaTime.Utility.InvalidNodaDataException">
            <summary>
            Exception thrown when data read by Noda Time (such as serialized time zone data) is invalid. This includes
            data which is truncated, i.e. we expect more data than we can read.
            </summary>
            <remarks>
            This type only exists as <c>InvalidDataException</c> doesn't exist in the Portable Class Library.
            Unfortunately, <c>InvalidDataException</c> itself is sealed, so we can't derive from it for the sake
            of backward compatibility.
            </remarks>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.Utility.InvalidNodaDataException.#ctor(System.String)">
            <summary>
            Creates an instance with the given message.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="M:NodaTime.Utility.InvalidNodaDataException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance with the given message.
            </summary>
            <param name="message">The message for the exception.</param>
            <param name="innerException">Underlying cause of the error.</param>
        </member>
        <member name="T:NodaTime.Utility.Cache`2">
            <summary>
            Implements a thread-safe cache of a fixed size, with a single computation function.
            (That happens to be all we need at the time of writing.)
            </summary>
            <remarks>
            For simplicity's sake, eviction is currently on a least-recently-added basis (not LRU). This
            may change in the future.
            </remarks>
            <typeparam name="TKey">Type of key</typeparam>
            <typeparam name="TValue">Type of value</typeparam>
        </member>
        <member name="M:NodaTime.Utility.Cache`2.GetOrAdd(`0)">
            <summary>
            Fetches a value from the cache, populating it if necessary.
            </summary>
            <param name="key">Key to fetch</param>
            <returns>The value associated with the key.</returns>
        </member>
        <member name="P:NodaTime.Utility.Cache`2.Count">
            <summary>
            Returns the number of entries currently in the cache, primarily for diagnostic purposes.
            </summary>
        </member>
        <member name="P:NodaTime.Utility.Cache`2.Keys">
            <summary>
            Returns a copy of the keys in the cache as a list, for diagnostic purposes.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.Cache`2.Clear">
            <summary>
            Clears the cache.
            </summary>
        </member>
        <member name="T:NodaTime.Utility.NamespaceDoc">
            <summary>
            <para>
            The NodaTime.Utility namespace contains helper classes which don't really fit anywhere else...
            </para>
            </summary>
        </member>
        <member name="T:NodaTime.Utility.NodaReadOnlyDictionary`2">
            <summary>
            Implementation of IDictionary{,} which delegates to an underlying dictionary for read, but 
            doesn't support any mutation operations.
            </summary>
            <remarks>The "Noda" prefix is to avoid any confusion with the BCL ReadOnlyDictionary type
            introduced in .NET 4.5.</remarks>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="T:NodaTime.Utility.ReferenceEqualityComparer`1">
            <summary>
            An equality comparer which compares references for equality and uses the "original" object hash code
            for hash codes.
            </summary>
        </member>
        <member name="T:NodaTime.Utility.Preconditions">
            <summary>
            Helper static methods for argument/state validation.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.Preconditions.CheckNotNull``1(``0,System.String)">
            <summary>
            Returns the given argument after checking whether it's null. This is useful for putting
            nullity checks in parameters which are passed to base class constructors.
            </summary>
        </member>
        <member name="T:NodaTime.ZonedDateTime">
            <summary>
            A <see cref="T:NodaTime.LocalDateTime" /> in a specific time zone and with a particular offset to distinguish
            between otherwise-ambiguous instants. A <see cref="T:NodaTime.ZonedDateTime"/> is global, in that it maps to a single
            <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>
            <para>Although <see cref="T:NodaTime.ZonedDateTime" /> includes both local and global concepts, it only supports
            duration-based - and not calendar-based - arithmetic. This avoids ambiguities
            and skipped date/time values becoming a problem within a series of calculations; instead,
            these can be considered just once, at the point of conversion to a <see cref="T:NodaTime.ZonedDateTime"/>.
            </para>
            <para>Comparisons of values can be handled in a way which is either calendar and zone sensitive or insensitive.
            Noda Time implements all the operators (and the <see cref="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)"/> method) such that all operators other than <see cref="M:NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)"/>
            will return false if asked to compare two values in different calendar systems or time zones.
            </para>
            <para>
            However, the <see cref="M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)"/> method (implementing <see cref="T:System.IComparable`1"/>) is calendar and zone insensitive; it compares the two
            global instants in terms of when they actually occurred.
            </para>
            <para>
            It's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,
            it would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly
            consider which calendar system they're working in anyway.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.Offset,NodaTime.DateTimeZone)">
            <summary>
            Internal constructor used by other code that has already validated and 
            computed the appropriate field values. No further validation is performed.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime"/> struct.
            </summary>
            <param name="instant">The instant.</param>
            <param name="zone">The time zone.</param>
            <param name="calendar">The calendar system.</param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime" /> struct in the specified time zone
            and the ISO calendar.
            </summary>
            <param name="instant">The instant.</param>
            <param name="zone">The time zone.</param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime"/> struct in the specified time zone
            from a given local time and offset. The offset is validated to be correct as part of initialization.
            In most cases a local time can only map to a single instant anyway, but the offset is included here for cases
            where the local time is ambiguous, usually due to daylight saving transitions.
            </summary>
            <param name="localDateTime">The local date and time.</param>
            <param name="zone">The time zone.</param>
            <param name="offset">The offset between UTC and local time at the desired instant.</param>
            <exception cref="T:System.ArgumentException"><paramref name="offset"/> is not a valid offset at the given
            local date and time.</exception>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Offset">
            <summary>Gets the offset of the local representation of this value from UTC.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Zone">
            <summary>Gets the time zone associated with this value.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.LocalInstant">
            <summary>Gets the local instant associated with this value.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.LocalDateTime">
            <summary>
            Gets the local date and time represented by this zoned date and time. The returned
            <see cref="T:NodaTime.LocalDateTime"/> will have the same calendar system and return the same values for
            each of the calendar properties (Year, MonthOfYear and so on), but will not be associated with any
            particular time zone.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Calendar">
            <summary>Gets the calendar system associated with this zoned date and time.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Date">
            <summary>
            Gets the local date represented by this zoned date and time. The returned <see cref="T:NodaTime.LocalDate"/>
            will have the same calendar system and return the same values for each of the date-based calendar
            properties (Year, MonthOfYear and so on), but will not be associated with any particular time zone.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.TimeOfDay">
            <summary>
            Gets the time portion of this zoned date and time. The returned <see cref="T:NodaTime.LocalTime"/> will
            return the same values for each of the time-based properties (Hour, Minute and so on), but
            will not be associated with any particular time zone.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Era">
            <summary>Gets the era for this zoned date and time.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.CenturyOfEra">
            <summary>Gets the century within the era of this zoned date and time.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Year">
            <summary>Gets the year of this zoned date and time.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
        </member>
        <member name="P:NodaTime.ZonedDateTime.YearOfCentury">
            <summary>Gets the year of this zoned date and time within its century.</summary>
            <remarks>This always returns a value in the range 0 to 99 inclusive.</remarks>
        </member>
        <member name="P:NodaTime.ZonedDateTime.YearOfEra">
            <summary>Gets the year of this zoned date and time within its era.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.WeekYear">
            <summary>
            Gets the "week year" of this date and time.
            </summary>
            <remarks>
            <para>
            The WeekYear is the year that matches with the <see cref="P:NodaTime.ZonedDateTime.WeekOfWeekYear"/> field.
            In the standard ISO-8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day.
            </para>
            <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Month">
            <summary>Gets the month of this zoned date and time within the year.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.WeekOfWeekYear">
            <summary>Gets the week within the WeekYear. See <see cref="P:NodaTime.ZonedDateTime.WeekYear"/> for more details.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.DayOfYear">
            <summary>Gets the day of this zoned date and time within the year.</summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Day">
            <summary>
            Gets the day of this zoned date and time within the month.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.IsoDayOfWeek">
            <summary>
            Gets the week day of this zoned date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value,
            for calendars which use ISO days of the week.
            </summary>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <seealso cref="P:NodaTime.ZonedDateTime.DayOfWeek"/>
        </member>
        <member name="P:NodaTime.ZonedDateTime.DayOfWeek">
            <summary>
            Gets the week day of this zoned date and time as a number.
            </summary>
            <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
            <seealso cref="P:NodaTime.ZonedDateTime.IsoDayOfWeek"/>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Hour">
            <summary>
            Gets the hour of day of this zoned date and time, in the range 0 to 23 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this zoned date and time, in the range 1 to 12 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Minute">
            <summary>
            Gets the minute of this zoned date and time, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Second">
            <summary>
            Gets the second of this zoned date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Millisecond">
            <summary>
            Gets the millisecond of this zoned date and time within the second, in the range 0 to 999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.TickOfSecond">
            <summary>
            Gets the tick of this zoned date and time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
        </member>
        <member name="P:NodaTime.ZonedDateTime.TickOfDay">
            <summary>
            Gets the tick of this zoned date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToInstant">
            <summary>
            Converts this value to the instant it represents on the time line.
            </summary>
            <remarks>
            This is always an unambiguous conversion. Any difficulties due to daylight saving
            transitions or other changes in time zone are handled when converting from a
            <see cref="T:NodaTime.LocalDateTime" /> to a <see cref="T:NodaTime.ZonedDateTime"/>; the <c>ZonedDateTime</c> remembers
            the actual offset from UTC to local time, so it always knows the exact instant represented.
            </remarks>
            <returns>The instant corresponding to this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.WithZone(NodaTime.DateTimeZone)">
            <summary>
            Creates a new <see cref="T:NodaTime.ZonedDateTime"/> representing the same instant in time, in the
            same calendar but a different time zone.
            </summary>
            <param name="targetZone">The target time zone to convert to.</param>
            <returns>A new value in the target time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
            <returns>True if the specified value is the same instant in the same time zone; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to.</param> 
            <filterpriority>2</filterpriority>
            <returns>True if the specified value is a <see cref="T:NodaTime.ZonedDateTime"/> representing the same instant in the same time zone; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.GetHashCode">
            <summary>
            Computes the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Equality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The first value to compare</param>
            <param name="right">The second value to compare</param>
            <returns>True if the two operands are equal according to <see cref="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)"/>; false otherwise</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The first value to compare</param>
            <param name="right">The second value to compare</param>
            <returns>False if the two operands are equal according to <see cref="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)"/>; true otherwise</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_LessThan(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime"/> values to see if the left one is strictly earlier than the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars or time zones.
            See the top-level type documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_LessThanOrEqual(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime"/> values to see if the left one is earlier than or equal to the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars or time zones.
            See the top-level type documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_GreaterThan(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime"/> values to see if the left one is strictly later than the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars or time zones.
            See the top-level type documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_GreaterThanOrEqual(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime"/> values to see if the left one is later than or equal to the right
            one.
            </summary>
            <remarks>
            This operator always returns false if the two operands have different calendars or time zones.
            See the top-level type documentation for more information about comparisons.
            </remarks>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)">
            <summary>
            Indicates whether this date/time is earlier, later or the same as another one.
            </summary>
            <remarks>
            This is purely done in terms of the instant represented; the calendar system and time zone are ignored.
            </remarks>
            <param name="other">The other zoned date/time to compare this one with</param>
            <returns>A value less than zero if the instant represented by this zoned date/time is earlier than the one in
            <paramref name="other"/>; zero if the instant is the same as the one in <paramref name="other"/>;
            a value greater than zero if the instant is later than the one in <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two ZonedDateTimes.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.ZonedDateTime"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this ZonedDateTime with another one; see <see cref="M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Addition(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Returns a new <see cref="T:NodaTime.ZonedDateTime"/> with the time advanced by the given duration. Note that
            due to daylight saving time changes this may not advance the local time by the same amount.
            </summary>
            <remarks>
            The returned value retains the calendar system and time zone of the <see cref="T:NodaTime.ZonedDateTime"/>.
            </remarks>
            <param name="zonedDateTime">The <see cref="T:NodaTime.ZonedDateTime"/> to add the duration to.</param>
            <param name="duration">The duration to add.</param>
            <returns>A new value with the time advanced by the given duration, in the same calendar system and time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Add(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Adds a duration to a zoned date and time. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="zonedDateTime">The value to add the duration to.</param>
            <param name="duration">The duration to add</param>
            <returns>A new value with the time advanced by the given duration, in the same calendar system and time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Plus(NodaTime.Duration)">
            <summary>
            Returns the result of adding a duration to this zoned date and time, for a fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="duration">The duration to add</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Subtracts a duration from a zoned date and time. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="zonedDateTime">The value to subtract the duration from.</param>
            <param name="duration">The duration to subtract.</param>
            <returns>A new value with the time "rewound" by the given duration, in the same calendar system and time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Minus(NodaTime.Duration)">
            <summary>
            Returns the result of subtracting a duration from this zoned date and time, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="duration">The duration to subtract</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Returns a new ZonedDateTime with the duration subtracted. Note that
            due to daylight saving time changes this may not change the local time by the same amount.
            </summary>
            <remarks>
            The returned value retains the calendar system and time zone of the <see cref="T:NodaTime.ZonedDateTime"/>.
            </remarks>
            <param name="zonedDateTime">The value to subtract the duration from.</param>
            <param name="duration">The duration to subtract.</param>
            <returns>A new value with the time "rewound" by the given duration, in the same calendar system and time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.GetZoneInterval">
            <summary>
            Returns the <see cref="T:NodaTime.TimeZones.ZoneInterval"/> containing this value, in the time zone this
            value refers to.
            </summary>
            <remarks>
            This is simply a convenience method - it is logically equivalent to converting this
            value to an <see cref="T:NodaTime.Instant"/> and then asking the appropriate <see cref="T:NodaTime.DateTimeZone"/>
            for the <c>ZoneInterval</c> containing that instant.
            </remarks>
            <returns>The <c>ZoneInterval</c> containing this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.IsDaylightSavingTime">
            <summary>
            Indicates whether or not this <see cref="T:NodaTime.ZonedDateTime"/> is in daylight saving time
            for its time zone. This is determined by checking the <see cref="P:NodaTime.TimeZones.ZoneInterval.Savings"/> property
            of the zone interval containing this value.
            </summary>
            <seealso cref="M:NodaTime.ZonedDateTime.GetZoneInterval"/>
            <returns><c>true</c> if the zone interval containing this value has a non-zero savings
            component; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeOffset">
            <summary>
            Constructs a <see cref="T:System.DateTimeOffset"/> value with the same local time and offset from
            UTC as this value.
            </summary>
            <remarks>
            An offset does not convey as much information as a time zone; a <see cref="T:System.DateTimeOffset"/>
            represents an instant in time along with an associated local time, but it doesn't allow you
            to find out what the local time would be for another instant.
            </remarks>
            <returns>A <see cref="T:System.DateTimeOffset"/> representation of this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Returns a new <see cref="T:NodaTime.ZonedDateTime"/> representing the same instant in time as the given
            <see cref="T:System.DateTimeOffset"/>.
            The time zone used will be a fixed time zone, which uses the same offset throughout time.
            </summary>
            <param name="dateTimeOffset">Date and time value with an offset.</param>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> value representing the same instant in time as the given <see cref="T:System.DateTimeOffset"/>.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeUtc">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this <see cref="T:NodaTime.ZonedDateTime"/> which has a
            <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/> and represents the same instant of time as
            this value rather than the same local time.
            </summary>
            <returns>A <see cref="T:System.DateTime"/> representation of this value with a "universal" kind, with the same
            instant of time as this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this <see cref="T:NodaTime.ZonedDateTime"/> which has a
            <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Unspecified"/> and represents the same local time as
            this value rather than the same instant in time.
            </summary>
            <remarks>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset.
            </remarks>
            <returns>A <see cref="T:System.DateTime"/> representation of this value with an "unspecified" kind, with the same
            local date and time as this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToOffsetDateTime">
            <summary>
            Constructs an <see cref="T:NodaTime.OffsetDateTime"/> with the same local date and time, and the same offset
            as this zoned date and time, effectively just "removing" the time zone itself.
            </summary>
            <returns>An OffsetDateTime with the same local date/time and offset as this value.</returns>
        </member>
        <member name="T:NodaTime.ZonedDateTime.Comparer">
            <summary>
            Base class for <see cref="T:NodaTime.ZonedDateTime"/> comparers.
            </summary>
            <remarks>
            <para>Use the static properties of this class to obtain instances.</para>
            <para>For the curious: this class only exists so that in the future, it can expose more functionality - probably
            implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>. If we simply provided properties on ZonedDateTime of type
            <see cref="T:System.Collections.Generic.IComparer`1"/> we'd have no backward-compatible way of adding to the set of implemented interfaces.</para>
            </remarks>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Comparer.Local">
            <summary>
            Returns a comparer which compares <see cref="T:NodaTime.ZonedDateTime"/> values by their local date/time, without reference to
            the time zone, offset or the calendar system.
            </summary>
            <remarks>
            <para>For example, this comparer considers 2013-03-04T20:21:00 (Europe/London) to be later than
            2013-03-04T19:21:00 (America/Los_Angeles) even though the second value represents a later instant in time.</para>
            <para>This property will return a reference to the same instance every time it is called.</para>
            </remarks>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Comparer.Instant">
            <summary>
            Returns a comparer which compares <see cref="T:NodaTime.ZonedDateTime"/> values by the instants obtained by applying the offset to
            the local date/time, ignoring the calendar system.
            </summary>
            <remarks>
            <para>For example, this comparer considers 2013-03-04T20:21:00 (Europe/London) to be earlier than
            2013-03-04T19:21:00 (America/Los_Angeles) even though the second value has a local time which is earlier; the time zones
            mean that the first value occurred earlier in the universal time line.</para>
            <para>This comparer behaves the same way as the <see cref="M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)"/> method; it is provided for symmetry with <see cref="P:NodaTime.ZonedDateTime.Comparer.Local"/>.</para>
            <para>This property will return a reference to the same instance every time it is called.</para>
            </remarks>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Comparer.#ctor">
            <summary>
            Internal constructor to prevent external classes from deriving from this.
            (That means we can add more abstract members in the future.)
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Comparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime"/> values and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first value to compare.</param>
            <param name="y">The second value to compare.</param>
            <returns>A signed integer that indicates the relative values of <paramref name="x"/> and <paramref name="y"/>, as shown in the following table.
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>Less than zero</term>
                  <description><paramref name="x"/> is less than <paramref name="y"/>.</description>
                </item>
                <item>
                  <term>Zero</term>
                  <description><paramref name="x"/> is equals to <paramref name="y"/>.</description>
                </item>
                <item>
                  <term>Greater than zero</term>
                  <description><paramref name="x"/> is greater than <paramref name="y"/>.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="T:NodaTime.ZonedDateTime.LocalComparer">
            <summary>
            Implementation for <see cref="P:NodaTime.ZonedDateTime.Comparer.Local"/>.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.LocalComparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.ZonedDateTime.InstantComparer">
            <summary>
            Implementation for <see cref="P:NodaTime.ZonedDateTime.Comparer.Instant"/>.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.InstantComparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Private constructor only present for serialization.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to fetch data from.</param>
            <param name="context">The source for this deserialization.</param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation of <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to populate with data.</param>
            <param name="context">The destination for this serialization.</param>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the method doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/>
            or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
    </members>
</doc>
